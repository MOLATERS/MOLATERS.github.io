<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Molaters</title>
  
  <subtitle>Michael Slater Lee</subtitle>
  <link href="https://molaters.github.io/atom.xml" rel="self"/>
  
  <link href="https://molaters.github.io/"/>
  <updated>2023-11-18T05:09:05.135Z</updated>
  <id>https://molaters.github.io/</id>
  
  <author>
    <name>Michael Slater</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CA-量化设计的基本原则</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E9%87%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E9%87%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</id>
    <published>2023-11-24T03:30:49.040Z</published>
    <updated>2023-11-18T05:09:05.135Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 量化设计的基本原则<h2 id="CourseNotes-计算机体系结构-CA-CPU性能公式"><a href="#CourseNotes-计算机体系结构-CA-CPU性能公式" class="headerlink" title="[[CourseNotes&#x2F;计算机体系结构&#x2F;CA-CPU性能公式]]"></a>[[CourseNotes&#x2F;计算机体系结构&#x2F;CA-CPU性能公式]]</h2><h2 id="大概率事件优先原则"><a href="#大概率事件优先原则" class="headerlink" title="大概率事件优先原则"></a>大概率事件优先原则</h2><p><strong>基本思想</strong>：对于大概率事件，赋予它优先的处理权和资源使用权，以获得全局的最优结果，以达到事半功倍的效果</p><p>类似于：哈夫曼编码</p><p>比如说：CPU在进行加法的时候，运算结果无溢出为大概率事件，溢出是小概率事件，所以就针对无溢出情况来做CPU优化设计</p><h2 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h2><p>Amdahl定律既可以用来<strong>确定系统中对性能限制最大的组件</strong>,也可以用来<em><strong>计算通过改进某些部件所获得的系统性能的提高</strong></em></p><p><strong>加快某部件执行速度所获得的系统性能加速比,受限于该部件在系统中所占的重要性</strong></p><h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><h4 id="系统加速比"><a href="#系统加速比" class="headerlink" title="系统加速比"></a>系统加速比</h4><p>$$<br>系统加速比 &#x3D; \frac{系统性能_{改进之后}}{系统性能_{改进之前}}<br>$$<br><strong>或者</strong><br>$$<br>系统加速比 &#x3D; \frac{总执行时间_{改进之前}}{总执行时间_{改进之后}}<br>$$</p><p><code>系统加速比</code> 可以告诉人们 <strong>改进之后的机器比改进之前快多少</strong></p><p><code>系统加速比</code>依赖于两个因素</p><ol><li>可改进部分在原系统计算时间中所占的比例</li></ol><p><strong>可改进比例</strong> $\in (0,1) \rightarrow \delta$ </p><ol start="2"><li>该部分改进之后的性能提高</li></ol><p><strong>部件加速比</strong> $\in (1,\infty) \rightarrow \alpha$</p><p>所以总执行时间:</p><p>$T &#x3D; (1-\delta) \times T_{改进前} + \frac{\delta \times T_{改进前}}{\alpha}$</p><p>所以系统加速比:</p><p>$\alpha_{系统}&#x3D;\frac{1}{(1-\delta)+\frac{\delta}{\alpha}}$</p><h2 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h2><p>程序的局部性原理（Principle of Locality）是指在程序访问内存时，往往倾向于访问最近才使用过的数据和即将使用的数据。这个原理可以分为两个方面：时间局部性和空间局部性。</p><p>时间局部性（Temporal Locality）指的是程序中的数据项一旦被访问，很可能在不久的将来再次被访问。这意味着在程序的执行过程中，某个数据项的访问往往会连续发生，因此将该数据项保留在高速缓存中，可以显著提高程序的性能。</p><p>空间局部性（Spatial Locality）指的是程序中的数据项的访问往往是以连续的方式进行的，即如果一个数据项被访问，那么与之相邻的数据项也很可能被访问。因此，将这些连续的数据项一起加载到高速缓存中，可以提高缓存的命中率，从而减少了访问内存的时间。</p><p>在程序设计和优化中，能够充分利用局部性原理可以提高程序的性能。例如，可以通过使用数组而不是链表来提高空间局部性，因为数组中的元素在内存中是连续存储的；可以通过合理安排数据访问的顺序来提高时间局部性，避免频繁地访问不相邻的数据。</p><p>参考来源：<a class="link"   href="https://zhuanlan.zhihu.com/p/30127242" >知乎专栏：深入理解程序的局部性原理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><blockquote><p>[!hello]</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-读书报告-李煦-2021112864</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A-%E6%9D%8E%E7%85%A6-2021112864/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A-%E6%9D%8E%E7%85%A6-2021112864/</id>
    <published>2023-11-24T03:30:49.039Z</published>
    <updated>2023-10-12T09:04:02.788Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 需求、瓶颈和好运:微处理器进化的动因## Part 1 基础架构<img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230921182614.png"                      alt="image.png" style="zoom: 67%;"                 ><h3 id="A-计算机体系结构是一门权衡的科学"><a href="#A-计算机体系结构是一门权衡的科学" class="headerlink" title="A. 计算机体系结构是一门权衡的科学"></a>A. 计算机体系结构是一门权衡的科学</h3><p>计算机体系结构更多地是一门“艺术”而不是“科学”。</p><p>计算机如果真的是一门科学，那就是一门权衡的科学。计算机架构师不断发展知识基础，这样就能够来更好的进行权衡；这个过程尤其表现在微处理器的演变过程中。</p><h3 id="B-转化的级别"><a href="#B-转化的级别" class="headerlink" title="B. 转化的级别"></a>B. 转化的级别</h3><p>在问题的解决过程中，需要通过一系列的转换过程来逐步将问题转化到电子（或设备）级别。转换的级别可以分为算法、机械语言、指令集架构（ISA）、微架构和电子数字电路。每个微处理器都由实现硬件结构（微架构）的电路组成，为软件提供一个接口（ISA）。不同的ISA会影响编译器开发的接口质量以及微架构执行的工作方式。在层次结构的每个步骤中，从算法的选择到语言、ISA、微架构和电路的选择都需要在性能和成本之间进行权衡。这些转换的选择都是基于性能和经济之间的权衡。</p><p>以下是按照转化的方法来构建的流程图：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A(算法) --&gt; B(机械语言)</span><br><span class="line"></span><br><span class="line">B --&gt; C(指令集架构)</span><br><span class="line"></span><br><span class="line">C --&gt; D(微架构)</span><br><span class="line"></span><br><span class="line">D --&gt; E(电子数字电路)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>从算法的选择到语言、ISA架构、电路的选择，每个层级都存在选择和权衡。通常情况下，但并非总是如此，选择是在更高的性能和更低的成本之间进行。</p><h3 id="C-设计的关键点"><a href="#C-设计的关键点" class="headerlink" title="C. 设计的关键点"></a>C. 设计的关键点</h3><p>设计处理器涉及到做出权衡，所以要考虑微处理器里面最重要的特征。强烈影响设计的有性能、成本、散热和功耗；同时另一个设计点是高可用性，也就是不会产生错误；追求高性能和低功耗。</p><h3 id="D-应用空间"><a href="#D-应用空间" class="headerlink" title="D. 应用空间"></a>D. 应用空间</h3><p>应用程序的空间越来越大，是因为人们对计算机的用途也越来越广泛，也就导致了对微处理器的需求和每个需求所做的权衡就会不断扩展。</p><p>计算机和微处理器的使用方面可以在<strong>科学应用</strong>，<strong>基于交易的应用</strong>、<strong>网络应用</strong>、<strong>确保交付应用</strong>、<strong>嵌入式应用</strong>、<strong>媒体应用</strong>、<strong>随机软件包</strong>等地方发挥作用。</p><p>每一个这样的应用都有他们的不同的地方、每一个应用区域都针对微处理器需要不同程度的统筹协调的进行特殊处理，以完成对应的工作。</p><h3 id="E-处理的基础"><a href="#E-处理的基础" class="headerlink" title="E. 处理的基础"></a>E. 处理的基础</h3><p>简单的把一个微处理器的行为定义为执行命令。为了做到这一点，处理器需要做到下面三件事：</p><ul><li>为能够让每个指令正确运行的处理器核心提供命令</li><li>为每一条指令提供所需要的数据</li><li>运行每一个被要求的指令</li></ul><h3 id="F-指令的提供"><a href="#F-指令的提供" class="headerlink" title="F. 指令的提供"></a>F. 指令的提供</h3><p>在过去的取指方案里，一条指令被提取，解码并传送给处理器核心进行处理。现在随着技术的发展，从一次性提取一条指令变成了一次性可以提取四条指令，甚至现在有可能已经能够一次性提取六条或者八条。有三件事情会阻碍我们将指令完全传输给内核并执行：</p><ul><li>指令Cache的不命中</li><li>取指暂停（fetch misses）</li><li>条件预测错误。</li></ul><h3 id="G-数据的提供"><a href="#G-数据的提供" class="headerlink" title="G. 数据的提供"></a>G. 数据的提供</h3><p>为了提供有效的数据，需要满足三个条件：</p><ul><li><p>具备提供无线的所需要的数据的能力</p></li><li><p>能够以极快的速度提供数据的能力</p></li><li><p>能够用合理的成本提供数据的能力</p></li></ul><p>现在使用的是存储的层次结构，一小部分数据能够在一到三个时间周期获取，更多的程序能够在十到十六个时钟周期获取，这些都是在芯片内的存储的情况；更多的数据是在芯片以外的方式进行存储，获取数据可能需要到数百个时间周期。</p><p>实际上，在作者的那个年代，外部芯片的延迟还很糟糕，作者提出，在几年内在外部内存访问数据可能需要数千个处理器周期。</p><h3 id="H-指令处理"><a href="#H-指令处理" class="headerlink" title="H. 指令处理"></a>H. 指令处理</h3><p>要执行这些指令所需的操作，需要足够数量的功能单元来处理数据，一旦数据可用，即时提供结果到需要它作为源操作数的功能单元。然而，足够的互连并不足够。随着芯片周期时间的减小，将一个部分芯片中的功能单元产生的结果转发到另一个部分芯片中需要这些结果作为源操作数的功能单元的延迟也会变得更糟。</p><h2 id="Part-2-处理器发展的推动因素"><a href="#Part-2-处理器发展的推动因素" class="headerlink" title="Part 2 处理器发展的推动因素"></a>Part 2 处理器发展的推动因素</h2><p>许多因素帮助了微处理器的发展：</p><ol><li>购买大众的意愿抢购供应商生产的产品——如果没有市场，任何产品都无法产生。</li><li>工程师在遇到问题时想出答案的创造力——没有解决方案，就不会有进化。</li><li>❗进化的动因则是：新的需求、瓶颈和好运。</li></ol><h3 id="A-新的需求"><a href="#A-新的需求" class="headerlink" title="A. 新的需求"></a>A. 新的需求</h3><p>早期处理器限制在每个周期获取一条指令，对指令进行解码并交给核心中的单元进行处理。 </p><p>对高性能的需求。有一个演变方向是变成了宽问题处理器，能够每个周期提取、解码和发送多个指令到执行核心。有另外一个演变方向，能够在执行核心中包含多个功能单元，一次可以做多个指令的操作。</p><p>又出现了新的功耗需求。要求是提供先前相同的计算机性能，但是能够降低先前的功耗。</p><p>预测未来的需求是人机交互的需求。</p><h3 id="B-瓶颈"><a href="#B-瓶颈" class="headerlink" title="B. 瓶颈"></a>B. 瓶颈</h3><p>我们已经在上面确定了指令处理的三个组成部分(指令提供、数据提供和执行指令的操作)，以及它们各自需要做什么。到目前为止，微处理器的大部分改进都是由于试图消除阻碍这三个组件工作的瓶颈。</p><p><strong>解决取指周期太长的问题</strong></p><p>解决方法：指令缓存。</p><p><strong>由条件分支导致取指令的过程当中不能取到的指令</strong></p><p>解决方法：条件分支预测器</p><h3 id="C-好运气"><a href="#C-好运气" class="headerlink" title="C. 好运气"></a>C. 好运气</h3><p>能够使用之前没有优化的剩余空间来做更多的优化，这就是作者所陈述的好运气（Good Furtune）的内容。作者给出的例子是引入了片上浮点加速器和片商多媒体指令扩展功能。</p><h2 id="Part-3-演化：从1971到如今（2001）"><a href="#Part-3-演化：从1971到如今（2001）" class="headerlink" title="Part 3 演化：从1971到如今（2001）"></a>Part 3 演化：从1971到如今（2001）</h2><p>微处理器已经从Intel 4004的2300个晶体管发展到今天的样子。这种进化是由上面所说的几个因素造成的。最后演变出来的结果就是，奔腾IV与1971年的英特尔4004几乎没有相似之处。下面是这种进化的一些例子。</p><h3 id="A-流水线"><a href="#A-流水线" class="headerlink" title="A. 流水线"></a>A. 流水线</h3><p>早期的微处理器在开始处理下一条指令之前先处理一条指令从取到执行结束。流水线，至少从20世纪60年代开始就出现在大型计算机中，是解决性能瓶颈的一个明显的解决方案。商业上可行的微处理器，如英特尔8086，在20世纪70年代末通过在当前指令执行时预取下一条指令，向流水线迈出了第一步。</p><h3 id="B-芯片内缓存"><a href="#B-芯片内缓存" class="headerlink" title="B. 芯片内缓存"></a>B. 芯片内缓存</h3><p>芯片内缓存的发展过程</p><ul><li>1984年摩托罗拉推出了一个具有商业可行性的芯片缓存处理器。</li><li>1986年，摩托罗拉公司推出了首款包含独立片上指令和数据缓存的微处理器。</li><li>1994年开始出现拥有两级缓存的高性能微处理器。</li></ul><h3 id="C-分支预测"><a href="#C-分支预测" class="headerlink" title="C. 分支预测"></a>C. 分支预测</h3><p>如果需要等待上一条指令产生条件跳转所需要的结果，那么条件跳转的线路的优势就会丢失。硬件(运行时)<strong>分支预测器</strong>直到20世纪90年代初才出现在微处理器芯片上。一些早期引入运行时分支预测器的微处理器是摩托罗拉的MC88110、Digital的Alpha 21064和英特尔的Pentium。</p><h3 id="D-片上的浮点单元"><a href="#D-片上的浮点单元" class="headerlink" title="D. 片上的浮点单元"></a>D. 片上的浮点单元</h3><p>片上浮点单元早期的微处理器有一个<u>单独的芯片来处理浮点运算</u>。随着晶体管越来越小，芯片越来越大，晶体管数量达到了浮点单元可以与主处理单元放在同一芯片上的程度，利用了“新的”备用容量，节省了不必要的片外通信。摩托罗拉MC88100和英特尔486是20世纪80年代末在主处理器芯片上采用浮点单元的两种早期芯片</p><h3 id="E-额外特殊功能单元"><a href="#E-额外特殊功能单元" class="headerlink" title="E. 额外特殊功能单元"></a>E. 额外特殊功能单元</h3><p>早期的微处理器只有一个或者很少的功能单元。但是人们发现可以<strong>利用多个单元来并发执行提高效率</strong>。后面先后引入了单独地址的<code>ALU</code>、更复杂的LOAD&#x2F;STORE存储单元、辅助图形处理单元等。</p><h3 id="F-乱序执行"><a href="#F-乱序执行" class="headerlink" title="F. 乱序执行"></a>F. 乱序执行</h3><p>最初，指令只能顺序执行，如果有数据正在执行，且下一条指令需要上一条指令产生的结果，就会产生瓶颈。<br>从20世纪60年代以来，IBM就饶过了这个瓶颈，使用了<strong>乱序处理</strong>。后来出现了乱序处理和精确异常处理的结合。为了适应乱序执行，就使用了大量的寄存器混叠和保留站。<strong>遵循的思想就是，只要指令的资源可用，指令就被允许执行。</strong> 但是它们在退出的时候还是严格按照顺序。要做大这一点就要一个在发生异常恢复状态的结构，这在现在大多数微处理器上表现的就是Recorder Buffer。</p><h3 id="G-集群处理器"><a href="#G-集群处理器" class="headerlink" title="G. 集群处理器"></a>G. 集群处理器</h3><p>由于片上的频率增加，导致芯片内一个功能单元产生的数值不能传递到对应的接受单元，所以有了将执行核心划分为多个<strong>集群</strong>的概念。一个集群的功能单元产生的结果将由同一个集群中的另一个单元来使用。</p><h3 id="H-芯片内的多处理器"><a href="#H-芯片内的多处理器" class="headerlink" title="H. 芯片内的多处理器"></a>H. 芯片内的多处理器</h3><p>问题出现：当指令缓存访问导致缓存缺失的时候，指令供应就会受到影响，在等待缓存确实被满足的过程中会浪费大量的容量。所以出现了<strong>备用容量</strong>的概念，在20世纪90年代出现之后，它被扩展到允许在交替的周期中从单个指令流里面单独获取。</p><h3 id="I-高频率内核"><a href="#I-高频率内核" class="headerlink" title="I. 高频率内核"></a>I. 高频率内核</h3><p>在计算密集型任务中，等待早期指令生成结果的源操作数的流依赖关系可能是一个重要的瓶颈。一个解决方案——以比微处理器其他部分快得多的频率运行执行核。奔腾IV芯片于2000年推出，其工作频率为1.7 GHz，但ALU的工作频率为3.4 GHz。</p><h2 id="Part-4-十亿晶体管芯片的未来"><a href="#Part-4-十亿晶体管芯片的未来" class="headerlink" title="Part 4 十亿晶体管芯片的未来"></a>Part 4 十亿晶体管芯片的未来</h2><p>讨论了在未来的十年里（指的是2001到2011），如何利用10亿个晶体管的技术能力来涉及计算机架构。作者介绍了几种不同的设计方案，包括CMP，SMT、单处理器、简单核心和片上系统，并且表达了自己对最高性能处理器的偏好。所以作者接下来进行更加细致的讲解：</p><h3 id="A-新型微处理器"><a href="#A-新型微处理器" class="headerlink" title="A. 新型微处理器"></a>A. 新型微处理器</h3><p>也就是将原来在软件层面实现的算法和程序放在硬件上来实现，真正的成为一个能够解决问题的处理器，就是新型处理器的进化方向。可以采用的形式是：使用可重构的逻辑、在ISA中设置特殊的专用指令，或者是在芯片上提供的集成功能单元。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230923145827.png"                      alt="image.png" style="zoom:50%;"                 ><h3 id="B-新型数据通路"><a href="#B-新型数据通路" class="headerlink" title="B. 新型数据通路"></a>B. 新型数据通路</h3><p>新型数据通路的挑战就在于根据新的导线长度限制重新设计数据路径。</p><h3 id="C-软错误的纠错机制"><a href="#C-软错误的纠错机制" class="headerlink" title="C. 软错误的纠错机制"></a>C. 软错误的纠错机制</h3><p>另外一个需要考虑的因素就是那些容易受到时钟频率影响的材质问题，会不经意的让处理器出现错误。所以未来的处理器需要能够纠正这样的错误功能。</p><h3 id="D-异步和同步单元的共存问题"><a href="#D-异步和同步单元的共存问题" class="headerlink" title="D. 异步和同步单元的共存问题"></a>D. 异步和同步单元的共存问题</h3><p>由于部分模块同步和异步的性质，当时钟周期在六千兆赫的时候情况就会更糟。作者的期望是能看到在一定的固定时间内进行异步运行的结构，同时和全局的时钟进行同步。不同的结构将要不同的时间，所以就更需要异步操作来解决独特的倾斜问题。</p><h3 id="E-不同功能的不同周期时间"><a href="#E-不同功能的不同周期时间" class="headerlink" title="E. 不同功能的不同周期时间"></a>E. 不同功能的不同周期时间</h3><p>因为不同的模块功能所需要时间（时钟周期数）不同，所以可以例如通过让不需要快速运行的部件设计为慢速运行来达到优化时钟分配的作用，为了解决不同功能的不同周期时间，作者提出希望未来的处理器能够只能的使用时钟，在需要的提放提高速度，在不需要的地方降低速度。这样就能动态的分配资源，节约资源。</p><h3 id="F-新材料"><a href="#F-新材料" class="headerlink" title="F. 新材料"></a>F. 新材料</h3><p>作者不了解未来的材料怎么出现，但是根据摩尔定律，每隔五年就会有关键材料的提升，作者希望未来的材料能够胜任够优秀处理器的功率要求和散热问题。</p><h3 id="G-扩展使用微程序"><a href="#G-扩展使用微程序" class="headerlink" title="G. 扩展使用微程序"></a>G. 扩展使用微程序</h3><p>作者基于离片带宽和片上带宽的成本和丰富性，提出未来的处理器需要更有效的利用片上的带宽。使用扩展的微程序是实现设一个目标的方式。这些微代码能够进行动态的重新编译，计算一些符合指令，调整缓存的替换策略或者用其他的方式来执行计算从而使得主要指令流速度更快。</p><h3 id="H-可重构逻辑"><a href="#H-可重构逻辑" class="headerlink" title="H. 可重构逻辑"></a>H. 可重构逻辑</h3><p>未来的微处理器可能会采用较高粒度的可重构逻辑结构。这种结构可以根据不同应用的需求动态调整，使得微处理器能够更有效地满足特定应用的要求。</p><h3 id="I-展望综合"><a href="#I-展望综合" class="headerlink" title="I. 展望综合"></a>I. 展望综合</h3><p>作者根据自己对未来处理器的设想提出了如下的清单内容：</p><ol><li>类似于块结构的ISA或者重播机制</li><li>利用核心的剩余能力来调整硬件结构的片上微程序</li><li>动态编译正在执行程序</li><li>三级缓存</li><li>用于数值预测的硬件</li><li>监视和影响芯片能源使用的片上结构</li></ol><h2 id="Part-5-总结"><a href="#Part-5-总结" class="headerlink" title="Part 5 总结"></a>Part 5 总结</h2><p>自1971年被发明以来，微处理器经历了一段激动人心的旅程。很少有技术能像它那样取得如此巨大的进步。不幸的是，有些人认为这个黄金时代即将结束。但这种唱反调的人以前也有过。他们说MIPS R2000是1986年所有人都需要的微处理器，十年后，他们说英特尔奔腾Pro是所有人都需要的微处理器。该行业继续做得更好，该技术的用户继续使用“更好”。这并不是说事情不会改变，不再需要新的创造力。在下游，我们可能需要一个彻底的范式转变，比如量子计算来拯救我们，但我们现在几乎没有受到限制。当然，我们需要开发更好的CAD工具。当前的CAD工具在验证当今的微处理器方面存在困难，更不用说本文中的建议了。当然，我们需要更广泛地思考微处理器的概念。但最重要的是，摩尔定律仍然存在，而且仍然提供了大量的机会。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-计算机体系结构第一章作业</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BD%9C%E4%B8%9A/</id>
    <published>2023-11-24T03:30:49.037Z</published>
    <updated>2023-10-12T09:02:57.692Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[CourseNotes/计算机体系结构/CA-CPU性能公式]]# Homework 1<h3 id="💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10-，现在希望对浮点操作进行加速。"><a href="#💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10-，现在希望对浮点操作进行加速。" class="headerlink" title="💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10%，现在希望对浮点操作进行加速。"></a>💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10%，现在希望对浮点操作进行加速。</h3><ol><li>设对浮点操作的加速比为$S_r$。画出程序总加速比$S_p$和$S_r$之间的关系曲线</li></ol><p><strong>1~10&#x2F;9 ,  单调递增</strong></p><ol><li>请问程序的最大加速比可以达到多少</li></ol><p><strong>10&#x2F;9, 此时Sf趋于无穷大</strong></p><hr><h3 id="💯计算机系统中有三个部件可以改进，这三个部件的加速比如下："><a href="#💯计算机系统中有三个部件可以改进，这三个部件的加速比如下：" class="headerlink" title="💯计算机系统中有三个部件可以改进，这三个部件的加速比如下："></a>💯计算机系统中有三个部件可以改进，这三个部件的加速比如下：</h3><blockquote><pre><code>        $部件加速比_1 = 30$        $部件加速比_2 = 20$        $部件加速比_3 = 10$</code></pre></blockquote><ol><li>如果部件1和部件2的可改进比例均为30%，那么当部件3的可改进比例为多少的时候，系统加速比才能达到10%。</li></ol><p><strong>约为36.1%</strong></p><ol start="3"><li>如果三个不见的可改进比例分别为30%、30%和20%，三个部件同时改进，那么系统中不可加速部分的执行时间在总执行时间中的比例是多少？</li></ol><p><strong>为22.5%</strong></p><ol start="5"><li>如果相对某个测试程序三个部件的可改进比例分别为20%、20%和70%，要达到最好的改进效果，仅对一个部件改进的时候，要选择哪个部件？如果允许改进两个部件，又应该怎么选择？</li></ol><p><strong>仅改进一个部件的时候,选择改进部件3;<br>改进两个部件的时候,选择改进部件1,3;</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-计算机体系结构第二章作业</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A/</id>
    <published>2023-11-24T03:30:49.037Z</published>
    <updated>2023-10-12T09:03:24.042Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>### 2. 区别不同指令系统的主要因素是什么？根据这个主要因素可以将指令系统结构分为哪三类？>区别不同指令系统的主要因素是指令的长度和操作码的结构。根据这个主要因素，指令系统结构可以分为以下三类：>1. 固定指令长度结构：指令长度固定且操作码结构简单，例如MIPS指令集。>2. 变长指令长度结构：指令长度可变且操作码结构复杂，例如x86指令集。>3. 配位码结构：指令长度固定且操作码结构复杂，例如IBM System/360指令集。这些分类是根据指令的长度和操作码的结构来区分不同的指令系统结构。来源：[计算机科学与技术词典 - 指令系统](https://www.itsfun.com.tw/指令系统/wiki-9390980-7806088)<h3 id="12-根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点"><a href="#12-根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点" class="headerlink" title="12. 根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点"></a>12. 根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点</h3><blockquote><p>RISC和CISC是两种常见的指令集结构。RISC表示精简指令集计算机（Reduced Instruction Set Computer），而CISC表示复杂指令集计算机（Complex Instruction Set Computer）。</p></blockquote><p><strong>RISC指令集结构计算机的性能特点包括</strong>：</p><ol><li>简化的指令集：RISC计算机使用更少、更简单的指令，使得指令执行速度更快。</li><li>精简的指令：RISC指令通常只执行基本操作，如加载、存储、算术和逻辑操作，并不包含复杂的指令。</li><li>流水线技术：RISC计算机通常采用流水线技术，可以同时执行多个指令，提高了指令执行效率。</li><li>高效的编译器：RISC指令集可由编译器更轻松地优化和转换，提高执行效率。<br><strong>CISC指令集结构计算机的性能特点包括</strong>：</li><li>复杂的指令集：CISC计算机提供丰富的指令集，包含复杂的指令和多种寻址模式，提供更高级别的指令操作。</li><li>高级的指令：CISC指令可以执行复杂的操作，如字符串处理、数据类型转换等，减少了编程的复杂度。</li><li>变长指令：CISC指令长度可以不固定，能够执行更多的操作，但也增加了指令的复杂度和执行时间。</li><li>快速的内存访问：CISC计算机通常具有高速缓存，可以减少内存访问时间。</li></ol><h3 id="15-某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？"><a href="#15-某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？" class="headerlink" title="15. 某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？"></a>15. 某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？</h3><p>（16-A）* 64</p><h3 id="18-某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。"><a href="#18-某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。" class="headerlink" title="18. 某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。"></a>18. 某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。</h3><p><strong>1. 如果二指令地址有15条，单地址指令和零地址指令的条数基本相等，那么单地址指令和零地址指令各有多少条，为三类指令分配操作码。</strong><br><strong>2. 如果指令系统要求这三类指令条数比例为1：9：9，那么这三类指令各有多少条?为三类指令分配操作码。</strong></p><p>15 63 63</p><p>14 126 126</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="指令系统" scheme="https://molaters.github.io/tags/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CA-编译器控制的预取</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A2%84%E5%8F%96/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A2%84%E5%8F%96/</id>
    <published>2023-11-24T03:30:49.035Z</published>
    <updated>2023-11-01T01:37:16.445Z</updated>
    
    <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><p>Cache性能分析</p><p>✔️ 平均访存失效</p><p>✔️ CPU时间</p><p>改进Cache性能</p><p>降低失效率</p><p>✔️ 3C失效 （强制性失效，容量失效，冲突失效）</p><p>✔️ 调节块的大小</p><p>✔️ 提高相联度</p><p>✔️ Victim Cache 和伪相连Cache</p><p>✔️ 硬件预取</p><p>✔️ 编译器控制的预取</p><h2 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h2><p>$T_{访存} &#x3D; T_H + F \times T_M$</p><p>没有预取的时候 251次失效</p><p>有预取的时候：19次失效</p><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><ol><li><p>基本思想 ： 在编译的时候，对程序中的执行和数据进行重新的组织，降低Cache失效率</p></li><li><p>可以重新组织程序不影响程序的正确性</p></li></ol><ul><li>把一个程序中的过程重新排序，就可能会减少冲突不命中，从而降低不命中率。</li></ul><p>✔️ 研究如何使用配置文件来执行优化</p><p>✔️ 2K字节，缺失率降低50%，8K字节，缺失率降低75%</p><p>针对数据的编译优化技术包括：</p><ul><li>数组合并</li></ul><blockquote><p>存的位置更集中，更容易进行访存</p></blockquote><ul><li>内外循环交换</li></ul><blockquote><p>有些计算是用列来进行运算的时候将数组进行转置，转换成行的计算</p></blockquote><ul><li>循环融合</li></ul><blockquote><p>对同样的数据做不同的运算，就能够在一个循环里面进行，可以在读入Cache的数据在被替换出去之前得到反复的使用</p></blockquote><ul><li>分块</li></ul><h2 id="降低Cache失效率的方法"><a href="#降低Cache失效率的方法" class="headerlink" title="降低Cache失效率的方法"></a>降低Cache失效率的方法</h2><p>增加块的大小</p><p>提高相联度</p><p>牺牲Cache</p><p>伪相连</p><p>硬件预取指令和数据</p><p>编译器控制的预取</p><p>用编译技术减少Cache不命中次数</p><h1 id="减少Cache失效开销"><a href="#减少Cache失效开销" class="headerlink" title="减少Cache失效开销"></a>减少Cache失效开销</h1><h2 id="写缓冲和写合并"><a href="#写缓冲和写合并" class="headerlink" title="写缓冲和写合并"></a>写缓冲和写合并</h2><p>写直达Cache </p><ul><li><p>依靠写缓冲来减少对下一级存储器写操作的时间</p></li><li><p>如果写缓冲其为空，就把数据和对应的地址写入缓冲器</p></li><li><p>从CPU的角度来看，写操作就是完成了</p></li></ul><p>提高写缓冲的效率和利用率 <code>写合并</code></p><p>提好了写缓冲器的空间利用率，而且还能减少因为写缓冲器满了而要进行的等待时间。</p><ul><li><p>如果写缓冲器中已经有了待写入的数据，就要把这次的写入地址与写缓冲器中已有的所有地址进行比较，看是否有匹配的项如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据与该项合并。这就叫写缓冲合并。</p></li><li><p>如果写缓冲器满且又没有能进行写合并的项，就必须等待</p></li></ul><h2 id="让读失效也优先于写"><a href="#让读失效也优先于写" class="headerlink" title="让读失效也优先于写"></a>让读失效也优先于写</h2><ol><li>Cache中的写缓冲器导致对存储器访问的复杂化</li></ol><p>在读不命中时，所读单元的最新值有可能还在写缓冲器中，尚未写入主存。</p><p><strong>例5.9 考虑以下指序列:</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SW R3,512(R0),  ;M[512]-R3 (Cache Index =0)</span><br><span class="line">LW R1，1024(R0) ;R1-M[1024](Cache Index =0)</span><br><span class="line">LW R2, 512(R0)  ;R2-M512](Cache Index =0)</span><br></pre></td></tr></table></figure></div><p>假设Cache采用写直达法和直接映像，并且地址512和1024映射到同一块，写缓冲器为4个字，问R2的值总等于R3吗?</p><blockquote><p>在执行SW指令之后，R3中数据放入ndex为0的Cache块和写缓器。第一条LW指令将该位置上的数据替换成MI[1024] (读失效)，第条LW指令又要替换这块Cache为M[512] (读失效)如果此时写缓冲还未更新完MI[512]，则R2不等于R3</p></blockquote><ol start="2"><li>解决问题的方法(读失效的处理)</li></ol><h3 id="推迟读失效的处理直到写缓冲排空"><a href="#推迟读失效的处理直到写缓冲排空" class="headerlink" title="推迟读失效的处理直到写缓冲排空"></a>推迟读失效的处理直到写缓冲排空</h3><p>缺点: 读失效的开销增加</p><h3 id="优先读操作"><a href="#优先读操作" class="headerlink" title="优先读操作"></a>优先读操作</h3><p>读失效时先检查写缓冲器中的内容<br>缺点:增加硬件</p><h2 id="请求字处理"><a href="#请求字处理" class="headerlink" title="请求字处理"></a>请求字处理</h2><ol><li>请求字(Requested Word)</li></ol><p>从下一级存储器调入Cache的块中，只有一个字是立即需要的。这个字称为请求字。</p><ol start="2"><li>应尽早把请求字发送给CPU</li></ol><p><strong>尽早重启动</strong>：调块时，从块的起始位置开始读起旦请求字到达，就立即发送给CPU，让CPU继续执行。</p><p><strong>请求字优先</strong>：调块时，从请求字所在的位置读起。这样，第一个读出的字便是请求字。将之立即发送给CPU。</p><ol start="3"><li>这种技术在Cache块比较小的情况下的效果不大，下一指令正好访问同一个Cache块的另一个部分</li></ol><h2 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h2><ol><li>应把Cache做得更快?还是更大?</li></ol><p>答案:二者兼顾，再增加一级Cache</p><ul><li>第一级Cache(L1)小而快。</li></ul><p>与快速的CPU运行时钟周期时间相匹配</p><ul><li>第二级Cache(L2)容量大</li></ul><p>捕捉到对主存进行的大多数访问</p><ol start="2"><li>性能分析</li></ol><p>$平均访问时间 &#x3D; 命中时间_{L1} + 失效率_{L1} \times 失效开销_{L1}$</p><ol start="3"><li>局部失效率和全局失效率</li></ol><p>$局部失效率 &#x3D; 该级Cache的失效次数&#x2F;到达该级Cache的访问次数$</p><p>$全局失效率 &#x3D; n级Cache的失效次数&#x2F;CPU发出的访存总次数$</p><p>$全局失效率 &#x3D; 失效率_{L1} \times 失效率_{L2}$</p><p>评价多级Cache的时候应该使用<strong>全局失效率</strong>的指标</p><p>假设某一两级Cache: 第一级Cache为L1，第二级Cache为L2(1) 设在1000次访存中，L1的不命中是40，L2的不命中是20。求各种局部不命中率和全局不命中率。(2L210个，L2开200时钟周期，L1的命中时间是1个时钟周期，平均每条指令访存1.5次，不考虑写操作的影响。问:平均访存时间是多少?每条指令的平均停顿时间是多少个时钟周期?</p><p>解<br>(1)<br>第一级Cache的不命中率(全局和局部) 是40&#x2F;1000，即4%;<br>第二级Cache的局部不命中率是20&#x2F;40，即50%;<br>第二级Cache的全局不命中率是20&#x2F;1000，即2%。<br>(2)<br>平均访存时间 &#x3D; 命中时间_{L1}<br>&#x3D;1+4% * (10+50% *200)<br>&#x3D;1+4% * 110 &#x3D; 5.4个时钟周期<br>每次访存的平均停顿时间为:  5.4-1.0&#x3D;4.4<br>所以:<br>由于平均每条指令访存1.5次每条指令的平均停顿时间&#x3D;4.4 * 1.5&#x3D;6.6个时钟周期</p><h3 id="Miss-Status-Holding-Register"><a href="#Miss-Status-Holding-Register" class="headerlink" title="Miss Status Holding Register"></a>Miss Status Holding Register</h3><p>MSHR包含正在等待处理的失效</p><p>相同的块可以包含多个未解决的Load&#x2F;Store失效</p><p>可以有多个没有解决的块地址</p><p>失效可以分为：</p><ol><li>第一次发起存储请求的时候的字符串</li></ol><h3 id="MSHR-Operation"><a href="#MSHR-Operation" class="headerlink" title="MSHR Operation"></a>MSHR Operation</h3><p>当失效的时候</p><table><thead><tr><th align="left">优化技术</th><th align="left">命中开销</th><th align="left">硬件复杂度</th></tr></thead><tbody><tr><td align="left">写缓冲写合并</td><td align="left">+</td><td align="left">1</td></tr><tr><td align="left">使读失效优先于写</td><td align="left">+</td><td align="left">1</td></tr><tr><td align="left">请求字处理</td><td align="left">+</td><td align="left">2</td></tr><tr><td align="left">两级cache</td><td align="left">+</td><td align="left">2</td></tr><tr><td align="left">非阻塞cache</td><td align="left">+</td><td align="left">3</td></tr></tbody></table><h2 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h2><p>命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是Cache的访问时间限制了处理器的时钟频率</p><h3 id="容量小，结构简单的Cache"><a href="#容量小，结构简单的Cache" class="headerlink" title="容量小，结构简单的Cache"></a>容量小，结构简单的Cache</h3><p>硬件越简单 速度就越快。</p><p>应该让Cache足够小，便于可以和CPU一起放在同一块芯片上。</p><p>折衷：Cache放在片内，把Cache的数据存储器放在片外，这样既可以实现快速标识检测，又能利用独立的存储芯片来提供更大的容量。</p><p>多级Cache，一级Cache大多采用2路组相联或者直接映像。</p><p>In recent designs, there are <strong>three</strong> other factors that have led to the use of higher associativity in first-level caches</p><ul><li><p>many processors take at least two clock cycles toaccess the cache and thus the impact of a longer hittime may not be critical</p></li><li><p>with the introduction of multithreading, conflict missescan increase, making higher associativity moreattractive</p></li><li><p>keep the TLB out of the critical path (a delay thatwould be larger than that associated with increasedassociativity</p></li></ul><h1 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h1><p>存储器组织技术</p><p>假设基本存储器结构的性能为：</p><p>送地址需要4个时钟周期，每个字访问时间为24个时钟周期</p><p>传送一个字的数据需要4个时钟周期</p><p>如果Cache大小是4个字，那么：</p><p>$失效开销&#x3D;4 \times (4+24+4) &#x3D; 128(时钟周期)$</p><p>存储器组织技术：</p><ol><li>增加存储器的宽度</li></ol><blockquote><p>增设Cache和多路选择器</p></blockquote><p><strong>性能分析</strong>:失效开销更改为32周期，带宽变为0.5字节&#x2F;周期</p><p><strong>缺点</strong>：</p><ul><li>增加CPU和存储器之间的连接通路宽度</li><li>CPU和Cache之间有一个多路选择器</li><li>扩充主存的最小增量增加了相应的倍数</li><li>写入有可能变得复杂</li></ul><p><strong>实例</strong>：DEC的Alpha Axp21064</p><ol start="2"><li>采用简单的多体交叉存储器</li></ol><p>存储系统中采用多个DRAM，利用它们潜在的并行性</p><p>分时启动</p><p>每个个体都有独立的MAR和读&#x2F;写电路</p><p>初始的时间是CPI&#x3D;3.15</p><p>块 2个字</p><p>64位总线和存储器，不采用多体交叉</p><p>性能提高了14%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[[CA-NotesView]]&lt;/p&gt;
&lt;h2 id=&quot;Recap&quot;&gt;&lt;a href=&quot;#Recap&quot; class=&quot;headerlink&quot; title=&quot;Recap&quot;&gt;&lt;/a&gt;Recap&lt;/h2&gt;&lt;p&gt;Cache性能分析&lt;/p&gt;
&lt;p&gt;✔️ 平均访存失效&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-第十四讲 分支目标缓冲</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AE%B2%20%E5%88%86%E6%94%AF%E7%9B%AE%E6%A0%87%E7%BC%93%E5%86%B2/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AE%B2%20%E5%88%86%E6%94%AF%E7%9B%AE%E6%A0%87%E7%BC%93%E5%86%B2/</id>
    <published>2023-11-24T03:30:49.033Z</published>
    <updated>2023-10-18T01:24:21.598Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<h2 id="BTB实现"><a href="#BTB实现" class="headerlink" title="BTB实现"></a>BTB实现</h2><p>分支目标缓存BTB每个单元应该包括</p><ul><li>分支指令的地址</li><li>分支目标的地址</li><li>分支预测标识</li></ul><p>取指阶段，所有指令地址都和BTB中保存的分支指令地址作比较，一旦相同，就认为本指令是分支指令，并且分支成功</p><p>它的目标地址就是保存在缓冲区内的分支目标地址</p><ul><li>取出之后直接送入NPC</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018081222.png"                      alt="image.png"                ></p><h2 id="BTB的执行过程"><a href="#BTB的执行过程" class="headerlink" title="BTB的执行过程"></a>BTB的执行过程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018081242.png"                      alt="image.png"                ></p><h2 id="采用BTB技术的时候在各种情况下的延迟"><a href="#采用BTB技术的时候在各种情况下的延迟" class="headerlink" title="采用BTB技术的时候在各种情况下的延迟"></a>采用BTB技术的时候在各种情况下的延迟</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018081330.png"                      alt="image.png"                ></p><h2 id="BTB的改进"><a href="#BTB的改进" class="headerlink" title="BTB的改进"></a>BTB的改进</h2><p>分支预测技术受限于预测精度，以预测失效之后产生的开销</p><p>根据不同程序特点以及缓冲区的大小，典型的BTB可以实现80%到95%的预测精度</p><p>降低失效开销技术：在一个时钟周期内同时取出不同分支路径的指令</p><ul><li>会引入其他开销，比如存储器洗头膏的端口加倍</li></ul><h2 id="Instruction-Fech-Unit"><a href="#Instruction-Fech-Unit" class="headerlink" title="Instruction Fech Unit"></a>Instruction Fech Unit</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018082131.png"                      alt="image.png"                ></p><h2 id="分支预测局限性总结"><a href="#分支预测局限性总结" class="headerlink" title="分支预测局限性总结"></a>分支预测局限性总结</h2><p>预测的准确性：80% ~ 90%</p><p>预测性能依赖于</p><ul><li>程序类型</li><li>缓冲区大小</li></ul><p>预测失效开销的优化</p><ul><li>预测不同分支路径指令</li><li>存储端口数目加倍，交叉存取缓冲</li></ul><h2 id="Corei7分支预测浪费的指令"><a href="#Corei7分支预测浪费的指令" class="headerlink" title="Corei7分支预测浪费的指令"></a>Corei7分支预测浪费的指令</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018082652.png"                      alt="image.png"                ></p><h1 id="基于硬件的前瞻执行"><a href="#基于硬件的前瞻执行" class="headerlink" title="基于硬件的前瞻执行"></a>基于硬件的前瞻执行</h1><p><strong>前瞻执行的基本思想</strong>：</p><p>对于分支指令的结果进行猜测，并假设这个猜测总是对的，然后按照这个猜测结果继续取、流出和执行后续的指令。</p><p>执行指令的结果不是写回到寄存器或者是存储器，而是写入一个称为再定序缓冲器ROB（ReOrder Buffer。得到相应的指令得到”确认“(commit)（也就是确实是应该执行的）之后，才将结果写入寄存器或者存储器</p><p>基于硬件的前瞻执行结合了<strong>3种思想</strong>：</p><ul><li>采用动态分支预测来选择后续执行的指令</li><li>在控制相关的结果尚未出来之前，前瞻的执行后续指令</li><li>对基本块采用动态调度</li></ul><p>对Tomasulo算法加以扩充，就可以支持前瞻执行。</p><ul><li>把Tomasulo算法的写结果和指令完成加以区分写成两个不同的段：<ul><li>写结果，指令确认</li></ul></li></ul><h3 id="写结果段"><a href="#写结果段" class="headerlink" title="写结果段"></a>写结果段</h3><ul><li>把前瞻执行的结果写到ROB种</li><li>通过CDB在指令之间传送结果，供需要用到这些结果的指令使用</li></ul><h3 id="指令确认段"><a href="#指令确认段" class="headerlink" title="指令确认段"></a>指令确认段</h3><p>在分支指令结果出来之后，对相应的指令的前瞻执行给予确认。</p><ul><li>如果前面所做的猜测是正确的，把ROB中的结果写到寄存器或者存储器。</li><li>如果发现前面对分支结果的猜测是错误的，那就不予以确认，刷新ROB，并从那条分支指令的另一条路径开始重新执行</li></ul><p><strong>ROB中的每一项由以下的4个字段组成</strong>：</p><ul><li>指令类型（instruction）</li><li>状态（state）</li><li>目标地址（destination)</li><li>数据值（value）</li></ul><p><strong>保留站RS中增加的域</strong>：</p><ul><li>目标地址(destination)：对应的ROB编号</li></ul><p>In-Order Issue&#x2F;Commit<br>Out-of-order Execution&#x2F;Writeback</p><h2 id="前瞻执行的流程"><a href="#前瞻执行的流程" class="headerlink" title="前瞻执行的流程"></a>前瞻执行的流程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018085112.png"                      alt="image.png"                ></p><h2 id="支持前瞻执行的Tomasulo算法的总结"><a href="#支持前瞻执行的Tomasulo算法的总结" class="headerlink" title="支持前瞻执行的Tomasulo算法的总结"></a>支持前瞻执行的Tomasulo算法的总结</h2><p>实际系统的实现非常相似</p><ul><li>Pretium P6 PowerPC,MIPS多种型号等</li></ul><p>不足之处：硬件非常复杂</p><ul><li><p>Too many value copy operations</p><ul><li>Register File RS ROB Register</li></ul></li><li><p>Too many muxes&#x2F;buses(CDB)</p><ul><li>Values are from everywhere to every</li></ul></li></ul><h2 id="超标量"><a href="#超标量" class="headerlink" title="超标量"></a>超标量</h2><p>超标量处理器的可获得的并行度，需要才哟个更有效的编译技术</p><p>循环展开成5个副本</p><p>使用先前用到的代码作为例子</p><p>在超标量流水线上对代码进行调度以获得更多的指令机并行度</p><p>每一次迭代需要12个时钟周期。</p><p>每个迭代的时候为2.4个时钟周期</p><ul><li>前面在普通的流水线上，通过循环展和调度，可以达到每个迭代为3.5个时钟周期</li><li>超标量可以获得更好的性能，代价是硬件复杂性大幅度增加</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-第十二讲 指令集并行</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/</id>
    <published>2023-11-24T03:30:49.032Z</published>
    <updated>2023-10-16T02:05:36.651Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<p>Recap</p><p>ILP是指令序列潜在的并行性、软硬件技术相结合<br>结构冲突、数据冲突、控制冲突对CPI的影响<br>基本块和循环级并行</p><p><strong>循环展开调度的基本方法</strong><br>浮点流水线、整数流水线的特性<br>循环无调度执行<br>循环调度、循环展开<br>循环展开并结合调度执行</p><h1 id="指令的动态调度"><a href="#指令的动态调度" class="headerlink" title="指令的动态调度"></a>指令的动态调度</h1><h2 id="动态调度原理"><a href="#动态调度原理" class="headerlink" title="动态调度原理"></a>动态调度原理</h2><p>编译器本质上通过对循环中的寄存器重命名开展开循环</p><p>硬件也可以通过寄存器重命名和乱序执行的方法（OoO）来获得同样的效果</p><h3 id="冲突的检测和调度"><a href="#冲突的检测和调度" class="headerlink" title="冲突的检测和调度"></a>冲突的检测和调度</h3><p>存在数据相关：</p><ol><li>暂停</li><li>停止取指和发射指令</li></ol><p><em><strong>静态调度</strong></em>：</p><p>依靠编译器</p><p>编译期间的代码调度和优化</p><p>相关指令拉开距离来减少可能产生的停顿</p><p><em><strong>动态调度</strong></em>：</p><p>依靠专门硬件对代码进行调度</p><h3 id="动态调度的原理"><a href="#动态调度的原理" class="headerlink" title="动态调度的原理"></a>动态调度的原理</h3><p>指令是按照顺序流出的，是按照顺序执行的</p><div class="highlight-container" data-rel="Basic"><figure class="iseeu highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIVD F4 F0 F2</span><br><span class="line">ADDD F10 F4 F6</span><br><span class="line">SUBD F12 F6 F14</span><br></pre></td></tr></table></figure></div><p>ADDD指令和DIVD指令关于F4相关，导致流水线停顿</p><p>SUBD指令虽然无关，<strong>但是也会被阻塞</strong></p><p>在基本流水线中</p><ul><li>检测结构冲突</li><li>检测数据冲突</li></ul><p>乱序执行</p><p>指令的执行顺序和程序的顺序不同<br>指令的完成也不同</p><p>为了支持<strong>乱序执行</strong></p><p><strong>流出</strong>：指令译码，检查是否有数据冲突</p><p><strong>读操作数</strong></p><h3 id="动态调度算法之一：记分牌"><a href="#动态调度算法之一：记分牌" class="headerlink" title="动态调度算法之一：记分牌"></a>动态调度算法之一：记分牌</h3><p>记分牌在1964年被Cray用于CDC 6600</p><p>记分牌允许乱序执行，前提是：</p><ul><li><p>充足的资源</p></li><li><p>指令可以乱序执行</p></li></ul><p>基本原理：</p><p>每条指令经过记分牌，记录各个指令之间的数据相关的信息，进行相关的检测，控制指令的流出和执行</p><p>如果记分牌判断出一条指令不能立即执行，它就检测硬件的变化从而决定什么时候可以执行</p><p>集中控制寄存器和处理单元的数据传送，检测或者消除数据的相关性，加快程序的执行速度</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011082554.png"                      alt="image.png" style="zoom:50%;"                 ><h4 id="记分牌的执行过程"><a href="#记分牌的执行过程" class="headerlink" title="记分牌的执行过程"></a>记分牌的执行过程</h4><ol><li><p>流出</p><ul><li>本指令所需要的功能部件有空闲</li><li>正在执行指令使用的目的寄存器和本指令不同<br>  :heavy_check_mark: 保证没有写后写相关（<code>WAW</code>）</li><li>如果存在结构冲突或者WAW相关，这个指令就不会流出，本指令就不会流出，后面的指令也不会流出，直至阻塞消失</li></ul></li><li><p>读操作数</p><ul><li>前面已经流出的还在运行的指令不会本指令的源操作数寄存器进行写操作</li><li>一个正在工作的功能部件已经完成了对这个寄存器的写操作<br>  :heavy_check_mark: 动态解决RAW相关</li></ul></li></ol><blockquote><p><strong>前面两步完成了原来ID段的功能</strong></p></blockquote><ol start="3"><li>执行</li></ol><ul><li>开始于取到操作数之后</li><li>结果产生之后，修改记分牌</li><li>FP流水部件会占用多个周期</li></ul><ol start="4"><li>写结果：<strong>检查WAR相关</strong></li></ol><p>  出现以下的情况的时候，不允许指令写结果</p><ul><li>前面某条指令（已经按照顺序）还没有读取操作数</li><li>而且其中某个源造作书和本指令的目的寄存器相同</li></ul><h4 id="记分牌结构"><a href="#记分牌结构" class="headerlink" title="记分牌结构"></a>记分牌结构</h4><p>指令状态表</p><p>功能部件的状态表</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231011084825332.png"                      alt="image-20231011084825332" style="zoom:50%;"                 ><p>结果寄存器状态表</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231011083849333.png"                      alt="image-20231011083849333" style="zoom:50%;"                 >#### 记分牌实例<img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011084344.png"                      style="zoom:50%;"                 ><p>In-order Issue</p><p>out-of-order execute</p><p>out-of-order WR</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231011090944982.png"                      alt="image-20231011090944982" style="zoom:50%;"                 >### 动态调度算法之二：Tomasulo算法<p>整个360系列仅一个指令系统和一个编译器</p><p>要求具有很高的浮点性能，但是不是通过高端机器的专用的编译器实现</p><p>只有四个双精度浮点寄存器，编译器调度的有效性受到很大的限制</p><p>访存时间和浮点运算的时间都很长</p><p>可以支持的循环的多次迭代重叠执行</p><h3 id="Tamassulo和记分牌"><a href="#Tamassulo和记分牌" class="headerlink" title="Tamassulo和记分牌"></a>Tamassulo和记分牌</h3><p>采用了很多和记分牌中的理念</p><p>两个较大的差异</p><ul><li><p>Tomasulo算法中，冲突检测和执行控制是分布的，利用保留站实现</p></li><li><p>Tomasulo算法不检查WAR和WAW相关通过算法本身消除。<strong>计算结果</strong>通过专用通道直接从功能部件<strong>进入到保留站进行缓冲</strong>，而不是写到寄存器。</p></li></ul><h3 id="Tomasulo算法核心思想"><a href="#Tomasulo算法核心思想" class="headerlink" title="Tomasulo算法核心思想"></a>Tomasulo算法核心思想</h3><p>记录并检测指令的RAW相关，操作数一旦准备就绪就立即执行，把发生RAW冲突的可能性降到最低。</p><p>不检查WAR和WAW相关，通过换名（Remainning）技术来消除WAR和WAW冲突</p><p>✔️ 基于Tomasulo算法的MIPS处理器浮点部件的基本结构</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011092721.png"                      alt="image.png" style="zoom: 50%;"                 ><p><strong>MIPS五阶段的流水线的改造</strong></p><ol><li>流出（数据就已经在保留栈中）<br>✨ 所以就不需要进行读出数据了</li><li>执行</li><li>结果写回</li></ol><p>Tomasulo算法的三阶段</p><ol><li><p>Issue：从队列中取出指令，如果存在一个空闲的保留站，就控制发射指令和操作数，消除WAR，WAW相关</p></li><li><p>Execution：当两个操作数就绪的时候就可以执行；如果没有准备好，就检测Common Data Bus 来获取结果；通过推迟指令执行避免RAW相关</p></li><li><p>Write result：将结果通过Common Data Bus 传给所有等待该结果的部件</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093440.png"                      alt="image.png" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093449.png"                      alt="image.png" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093458.png"                      alt="image.png" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093507.png"                      alt="image.png" style="zoom:67%;"                 >#### 和记分牌的不同<p>无需任何的操作来检查数据的写后写WAW和先读后写WAR冲突，在指令流出的过程中，操作数寄存器号换成操作数本身（如果已经就绪）或者相应的保留站标识</p><p>通过公共数据总线来广播结果，将计算结果直接东产生的保留站传送到所有需要它的功能部件而不需要经过寄存器（动态解决了RAW）</p><p>存储器存和取都能作为基本的功能部件</p><p>由于保留站技术能够有效的解决先写后读，记分牌中的用于判断RAW的’<em>取操作数</em>‘段被取消。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="指令集并行" scheme="https://molaters.github.io/tags/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>CA-第十三讲</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AE%B2%20Tomasulo%20%E5%92%8C%20%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%A3%E5%86%B3%E6%8A%80%E6%9C%AF/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AE%B2%20Tomasulo%20%E5%92%8C%20%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%A3%E5%86%B3%E6%8A%80%E6%9C%AF/</id>
    <published>2023-11-24T03:30:49.030Z</published>
    <updated>2023-10-18T00:08:18.679Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<h2 id="Reservation-Station-结构"><a href="#Reservation-Station-结构" class="headerlink" title="Reservation Station 结构"></a>Reservation Station 结构</h2><p><code>Op</code>: 部件所进行的操作<br><code>Vj</code>, <code>Vk</code>: 源操作数的值。Store 缓冲区有Vk域，用于存放要写入存储器的 值。V域和Q域不同时有效。<br><code>A</code>：存放存储器地址。开始存立即数，计算出有效地址后，存放有效地址<br><code>Qj</code>, <code>Qk</code>: 产生源操作数的保留站号<br>✓ 没有记分牌中的准备就绪标志， Qj, Qk&#x3D;0 &#x3D;&gt; ready<br>✓ Store 缓存区只有Qk表示产生结果的保留站号<br><code>Busy</code>: 标识保留站RS或相应的功能部件FU是否空闲</p><p>Register result status—如果存在对寄存器的写操作，指示对该寄存器 进行写操作的部件. <code>Qi</code>: 保留站的编号</p><h2 id="Tomasulo实例"><a href="#Tomasulo实例" class="headerlink" title="Tomasulo实例"></a>Tomasulo实例</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016102533.png"                      alt="image.png"                ></p><p>Note：不像是记分牌，两个Lw指令可以一起流出</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016103304.png"                      alt="image.png"                ></p><p>在第六拍的时候所有指令就全部流出了</p><p>减法完成之后，需要去做什么？<strong>可以看到加法指令在第八拍的时候需要</strong></p><p>Add2拿到的两个操作数之后就立即启动</p><p>加法做完之后也可以把结果写回 <strong>这是和记分牌最不一样的地方</strong></p><p>根本上来讲也是按序的流出，乱序的进行执行，乱序的写入</p><h2 id="基于Tomasulo算法的动态循环展开"><a href="#基于Tomasulo算法的动态循环展开" class="headerlink" title="基于Tomasulo算法的动态循环展开"></a>基于Tomasulo算法的动态循环展开</h2><p>为了保证正确的异常行为，Tomasulo算法对指令的执行有一个限制：一旦有一条分支指令还没有执行完，其后的指令是不允许进入执行段的</p><p>动态存储器地址判别技术，解决存储器访问的时候的RAW、WAW、WAR冲突</p><p>第一次取数LD，由于Cache miss,需要8个时钟周期延迟，之后的取数LD，只需要一个时钟周期，存数SD需要3个时钟周期。</p><p>乘法需要4个时钟周期</p><h2 id="Tomasulo循环实例"><a href="#Tomasulo循环实例" class="headerlink" title="Tomasulo循环实例"></a>Tomasulo循环实例</h2><p>Loop： LD F0, 0(R1)<br>           MULTD F4, F0, F2<br>           SD 0(R1), F4<br>           SUBI R1, R1, #8<br>           BNEZ R1, Loop</p><p>存在隐含的换名情况</p><p>[[课件综合&#x2F;计算机体系结构 - 第13讲.pdf#page&#x3D;35&amp;selection&#x3D;236,0,239,7|计算机体系结构 - 第13讲, page 35]]</p><p>F0被动态的消除了</p><h2 id="Tomasulo算法的优点"><a href="#Tomasulo算法的优点" class="headerlink" title="Tomasulo算法的优点"></a>Tomasulo算法的优点</h2><p>分布式硬件冲突检测</p><p>利用寄存器换名，彻底消除WAW和WAR这两种名相关</p><p>如果多个保留站等待同一个操作数，当操作数在CDB上广播的时候，它们可以同时获得所需要的数据</p><p>对于存储器访问，<strong>动态存储器地址判别技术</strong>可以解决RAW冲突（取操作数的时候判断）、WAR和WAW冲突（存操作数的时候判断）</p><p>能够达到很高的性能</p><h2 id="Tomasulo-算法的缺点"><a href="#Tomasulo-算法的缺点" class="headerlink" title="Tomasulo 算法的缺点"></a>Tomasulo 算法的缺点</h2><p>高复杂性：需要大量的硬件</p><p>存在瓶颈：单个数据总线会引发竞争</p><p>需要额外的数据总线：在每个保留站上需要为每条总线都设置重复的硬件接口</p><p>为了保证正确的异常行为，对指令的执行有一个限制：</p><p><strong>一旦有一条指令还没有执行完，其后的指令是不允许进入执行段</strong></p><h2 id="动态调度方法中的异常行为处理"><a href="#动态调度方法中的异常行为处理" class="headerlink" title="动态调度方法中的异常行为处理"></a>动态调度方法中的异常行为处理</h2><p>指令乱序大大增加了异常处理的复杂度。</p><p>不精确异常（Imprecise Exeption）：当指令i导致发生异常的时候，处理机的现场（状态）和严格按照程序顺序执行不相同。</p><p>精确异常(Precise Exception)：处理机现场和严格按照程序新婚徐执行的时候指令i的现场相同</p><p>不精确异常产生的原因：</p><p>:heavy_check_mark: 流水线可能已经执行完按照程序顺序是位于指令i之后的指令</p><p>:heavy_check_mark:流水线可能还没有完成按照程序顺序是指令i之前的指令</p><h2 id="动态调度方法中的异常行为处理-1"><a href="#动态调度方法中的异常行为处理-1" class="headerlink" title="动态调度方法中的异常行为处理"></a>动态调度方法中的异常行为处理</h2><p>ADD指令LW指令SUB指令没有数据相关，可以乱序执行</p><p>SUB指令在LW指令执行完之前，更改R7</p><p>但是LW指令可能会硬气存储器的异常（如访存缺页、访存越界等）</p><h1 id="控制相关的动态解决技术"><a href="#控制相关的动态解决技术" class="headerlink" title="控制相关的动态解决技术"></a>控制相关的动态解决技术</h1><h2 id="分支预测缓冲"><a href="#分支预测缓冲" class="headerlink" title="分支预测缓冲"></a>分支预测缓冲</h2><p>动态分支的两个理由</p><ul><li>n流出的处理器加速上限为n倍</li><li>Amdahl定律提示：在较低CPI机器上，控制相关导致的空转对机器性能影响大</li></ul><p>前面解决控制相关的静态策略</p><ul><li>需要编译器将一条或者多条指令移动到流水线产生的分支延迟槽中</li></ul><p>关于分支预测的两部分工作</p><ul><li>预测的分支是否成功</li><li>执行分支目标指令</li></ul><h2 id="分支预测的效果"><a href="#分支预测的效果" class="headerlink" title="分支预测的效果"></a>分支预测的效果</h2><p>预测的准确率</p><p>分支的开销</p><ul><li>预测正确的开销</li><li>预测错误的开销</li><li>决定分支开销的因素：流水线的结构、预测的方法、预测错误的时候的回复策略等</li></ul><h2 id="分支预测缓冲（BPB）：原理"><a href="#分支预测缓冲（BPB）：原理" class="headerlink" title="分支预测缓冲（BPB）：原理"></a>分支预测缓冲（BPB）：原理</h2><p>最简单的分支预测策略</p><p>BPB也被称为BHT（Branch History Table,BHT）</p><p>分支预测缓冲是一个小的存储器阵列</p><ul><li>每个单元最小可以只有一位，记录最近一次的分支是否成功的信息</li><li>预测位为1的时候，标识预测分支成功，并从目标分支位置开始取指令</li><li>在预测错误的时候，要作废已经预取和分析的指令，恢复现场，并从零一条分支路径重新取指令</li></ul><h2 id="分支预测指令不成功和重新执行过程"><a href="#分支预测指令不成功和重新执行过程" class="headerlink" title="分支预测指令不成功和重新执行过程"></a>分支预测指令不成功和重新执行过程</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016112704067.png"                      alt="image-20231016112704067" style="zoom:67%;"                 ><h3 id="一位的BOB的状态图"><a href="#一位的BOB的状态图" class="headerlink" title="一位的BOB的状态图"></a>一位的BOB的状态图</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016112809699.png"                      alt="image-20231016112809699"                ></p><p>这种单位预测策略：</p><ul><li>当分支不成功的时候，将会发生连续两次预测出错</li><li>2位预测策略能够改善这种情况</li></ul><h3 id="2位BPB工作原理"><a href="#2位BPB工作原理" class="headerlink" title="2位BPB工作原理"></a>2位BPB工作原理</h3><p>在两位的预测策略中，一个预测必须错误两次才会改变。</p><p>对于一个2096条记录的BPB，利用两位预测策略，用SPEC89测试，命中率位82%到99%</p><p>准确率最高的测试程序一般包含大量的循环</p><p>没有循环的线性代码一般准确率最差</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016113235730.png"                      alt="image-20231016113235730" style="zoom:67%;"                 ><p>还有另外一种的状态转化图：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016113405020.png"                      alt="image-20231016113405020" style="zoom:67%;"                 ><h2 id="4096单元2位BPB的预测错误率"><a href="#4096单元2位BPB的预测错误率" class="headerlink" title="4096单元2位BPB的预测错误率"></a>4096单元2位BPB的预测错误率</h2><p>测试程序位SPEC89</p><p>整数测试程序：平均11%</p><ul><li>gcc, espresso,eqntott,li</li></ul><p>浮点测试程序：平均4%</p><ul><li>nasa7,matrix300,tomcatv</li></ul><p>为什么？</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016113854745.png"                      alt="image-20231016113854745" style="zoom:50%;"                 ><h2 id="BPB实现"><a href="#BPB实现" class="headerlink" title="BPB实现"></a>BPB实现</h2><p>BPB的实现方案</p><ul><li>实现一个小而特殊的”cache“，利用指令地址进行寻址，在IF流水段访问</li><li>为指令cache中每一块增加附加位，与指令一起取出</li></ul><p>如果一个指令在ID段被译码位分支指令，且对应的BPB标志位预测其成功，则</p><ul><li>一旦PC已知，立刻从分支目标位置开始取指</li></ul><p>对于改进MIPS，分支判断和计算分支目标地址都在ID段完成，BPB无效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-第八讲 流水线技术</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%85%AB%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%85%AB%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/</id>
    <published>2023-11-24T03:30:49.028Z</published>
    <updated>2023-10-12T09:04:06.777Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># Recap<ul><li>流水线的基本概念<ul><li><input checked="" disabled="" type="checkbox"> 流水技术的定义</li><li><input checked="" disabled="" type="checkbox"> 流水线的特点</li></ul></li><li>流水线的分类<ul><li><input checked="" disabled="" type="checkbox"> 实现的功能（单功能和双功能）</li><li><input checked="" disabled="" type="checkbox"> 连接方式（静态和动态）</li><li><input checked="" disabled="" type="checkbox"> 子过程的粒度（部件级、处理机级和处理机间）</li><li><input checked="" disabled="" type="checkbox"> 数据表示（标量和向量）</li><li><input checked="" disabled="" type="checkbox"> 反馈回路 （线性和非线性）</li></ul></li><li>MIPS基本流水线<ul><li><input checked="" disabled="" type="checkbox"> 将数据通路划分流水段，加入段间寄存器文件</li><li><input checked="" disabled="" type="checkbox"> 没功能段完成指令子过程的相应操作</li><li><input checked="" disabled="" type="checkbox"> 多路线选择器的控制</li></ul></li></ul><h2 id="流水线性能分析"><a href="#流水线性能分析" class="headerlink" title="流水线性能分析"></a>流水线性能分析</h2><p><strong>三项性能指标：吞吐率、加速比和效率</strong></p><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>是衡量流水线的重要指标</p><ul><li><p>吞吐率是指单位时间内流水线所完成的任务数或输出结果的数量</p></li><li><p>最大吞吐率$TP_{max}$是指流水线在达到稳定状态后所得到的吞吐率。</p></li><li><p>设流水线由m段组成，完成n个任务的吞吐率称为 <strong>实际吞吐率</strong>，记作<strong>TP</strong></p></li></ul><h3 id="最大吞吐率"><a href="#最大吞吐率" class="headerlink" title="最大吞吐率"></a>最大吞吐率</h3><p>假设流水线的隔断时间相等，均为$\Delta t_0$，则：<br>$TP_{max}&#x3D;1&#x2F;\Delta t_0$<br>假设流水线隔段时间不等，第i段时间为$\Delta t_i$,则：<br>$TP_{max}&#x3D;1&#x2F;max{\Delta t_i}$</p><ul><li>最大吞吐率取决于流水线中最慢的一段时间，这段称为流水线的瓶颈</li></ul><p><strong>- 消除瓶颈的方法</strong></p><ul><li>细分瓶颈段</li><li>重复设置瓶颈段</li></ul><h3 id="实际吞吐率"><a href="#实际吞吐率" class="headerlink" title="实际吞吐率"></a>实际吞吐率</h3><ul><li>如果隔断时间相等（假设均为$\Delta t_0$）,则完成时间</li></ul><p>$T_{流水}&#x3D;m\Delta t_0 + (n-1)\Delta t_0$</p><h3 id="实际吞吐率-1"><a href="#实际吞吐率-1" class="headerlink" title="实际吞吐率"></a>实际吞吐率</h3><p>$$<br>TP&#x3D;\frac n{T_{\textit{流水}} }&#x3D;\frac n{<em>{m{\Delta}t</em>{0}+(n-1)\bullet{\Delta}t_{0}}}<br>$$<br>$$<br>TP&#x3D;\frac{n}{\sum_{\mathrm{i}&#x3D;1}^{m}\Delta t_{i}+(n-1):\Delta t_{j}}<br>$$</p><h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><p>如果流水线是m段，每一段时间均为$\Delta t_0$,那么<br>$$<br>S&#x3D;\frac{\mathrm{mn}}{m+n-1}&#x3D;\frac{m}{1+\frac{m-1}n}<br>$$</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>通过时间和排空时间使得各段不是一直满负载工作</p><p>$$<br>E&#x3D;\frac{n\triangle t_{o}}{T_{流水}}&#x3D;\frac{n}{m+n-1}&#x3D;\frac{1}{1+\frac{m-1}{n}}<br>$$</p><h2 id="流水线举例"><a href="#流水线举例" class="headerlink" title="流水线举例"></a>流水线举例</h2><p>$$<br>\sum^{4}_{i&#x3D;1}A_iB_i&#x3D; A_1B_1+A_2B_2+A_3B_3+A_4B_4<br>$$</p><p>乘法：1，6，7，8 —— 4次<br>加法：1，2，3，4，5，8 —— 3次</p><h3 id="有关流水线性能的若干问题"><a href="#有关流水线性能的若干问题" class="headerlink" title="有关流水线性能的若干问题"></a>有关流水线性能的若干问题</h3><ul><li>流水线并不能减少单条指令的执行时间，但是能够提高吞吐率</li></ul><h2 id="流水线中的冲突"><a href="#流水线中的冲突" class="headerlink" title="流水线中的冲突"></a>流水线中的冲突</h2><p>结构冲突<br>数据冲突<br>控制冲突</p><p>导致结构冲突的常见原因</p><ul><li>功能部件不是全流水</li><li>重复设置的资源数量不足</li></ul><p>示例：当数据和指令在同一个寄存器中的时候，访存指令回应一存储器访问冲突</p><p>解决方法：</p><ul><li>插入暂停周期</li><li>将指令寄存器和数据存储器分离</li></ul><h3 id="避免结构冲突的方法"><a href="#避免结构冲突的方法" class="headerlink" title="避免结构冲突的方法"></a>避免结构冲突的方法</h3><ul><li>所有功能单元完全流水化</li><li>设置足够多的硬件资源 但是硬件代价很大！</li></ul><p>当前许多机器都没有将浮点功能单元完全流水，比如在MIPS实现中，浮点乘需要5个时钟周期但对该指令不流水。请分析由此引起的结构冲突对mdlidp2基准程序在MIPS上运行的性能有何影响? 为简单起见，假设浮点乘法服从均匀分布。</p><blockquote><p>mdljdp2中浮点乘法出现的频率约为14%<br><strong>最坏情况</strong>：每个浮点成都要和其他操作重叠执行，都需要五个周期，此时的CPI为1.56<br><strong>最好情况</strong>：可以完全重叠执行，仅需要一个周期，此时没有性能损失</p></blockquote><h2 id="流水线的数据冲突"><a href="#流水线的数据冲突" class="headerlink" title="流水线的数据冲突"></a>流水线的数据冲突</h2><p>数据冲突简介</p><p>产生原因：当指令在流水线中重叠执行的时候，流水线有可能改变指令读&#x2F;写操作数的顺序，使之不同于它们在非流水实现的时候的顺序，这将导致数据冲突。</p><p><strong>消除方法</strong>：<em>向流水线中插入暂停周期</em></p><h3 id="通过定向技术减少数据冲突带来的暂停"><a href="#通过定向技术减少数据冲突带来的暂停" class="headerlink" title="通过定向技术减少数据冲突带来的暂停"></a>通过<em>定向技术</em>减少数据冲突带来的暂停</h3><p>定向（Forwarding），也称为旁路（Bypassing），是指在计算机指令流水线中，将运算结果从前一条指令的执行阶段直接送往下一条指令的执行阶段，而不需要等待写回阶段的结果。这样可以节省一部分时间，提高计算机的运算效率。定向可以理解为”抄近道”，不必等待写回阶段的结果即可将数据直接送往下一指令的输入端。</p><p>工作过程</p><p>主要思路：将计算结果从其产生的地方直接送到真正需要它的地方，就可以避免暂停。</p><ul><li>寄存器文件中的ALU运算结果总是回送到ALU的输入寄存器</li><li>从定向通路得到输入数据的ALU操作不必从源寄存器中读取操作数</li></ul><h3 id="通过定向技术减少数据冲突带来的暂停-1"><a href="#通过定向技术减少数据冲突带来的暂停-1" class="headerlink" title="通过定向技术减少数据冲突带来的暂停"></a>通过定向技术减少数据冲突带来的暂停</h3><p><strong>进一步推广</strong>：一个结果不经可以从某一个功能单元的输出定向到其自身的输入，而且还可以定向到其它功能单元的输入。</p><p>在MIPS中，任何流水寄存器到任何功能单元的输入都可能需要定向路径，将形成复杂的旁路网络。</p><p>两条指令访问同一个存储单元，也可能引起数据冲突，例如访问数据Cache失效的时候</p><p><strong>只讨论寄存器数据冲突！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="流水线技术" scheme="https://molaters.github.io/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CA-第十一讲 指令集并行</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/</id>
    <published>2023-11-24T03:30:49.028Z</published>
    <updated>2023-10-12T09:04:39.396Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<h1 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h1><p><strong>流水线控制冲突</strong></p><p>分支指令的行为特点</p><p>减少流水线分支损失的方法（冻结或排空、预测分支转移失败、预测分支转移成功、分支延迟槽）</p><p><strong>流水线的实例</strong> MIPS R4000</p><p>整形流水线</p><p>浮点流水线</p><p>流水线性能分析</p><p>向量处理机 Cray-I</p><p>性能指标、基本结构</p><p>链接技术</p><h1 id="指令集并行"><a href="#指令集并行" class="headerlink" title="指令集并行"></a>指令集并行</h1><ol><li>指令集并行的概念</li><li>指令的动态调度</li><li>控制相关的动态解决技术</li><li>多指令流水技术</li></ol><p>基于预测的乱序执行</p><h2 id="指令集并行的概念"><a href="#指令集并行的概念" class="headerlink" title="指令集并行的概念"></a>指令集并行的概念</h2><p>循环展开调度的基本方法</p><p><strong>相关性</strong></p><p>指令之间不存在相关的时候，它们在流水线中式可以重叠起来执行的。这种指令序列中存在的潜在并行性称为指令集并行</p><p><strong>怎么知道指令之间需要并行？软硬件如何支持指令级并行，怎么研究这些问题？</strong></p><p>硬件技术或者软件技术都可以提高指令级并行性</p><h2 id="性能评价"><a href="#性能评价" class="headerlink" title="性能评价"></a>性能评价</h2><p>流水线处理器的实际CPI</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231009101405.png"                      alt="image.png" style="zoom:50%;"                 ><p>软件和硬件的支持</p><h2 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h2><p><strong>基本（程序）块</strong>：一段除了入口和出口之外的不包含其他分支的线性代码段</p><ul><li>程序平均每 6 ~ 7条指令就会有一个分支</li><li>必须在多个基本块之间开发指令级的并行性</li></ul><blockquote><p><em>所以最重要的就是循环</em></p></blockquote><p><strong>循环级并行</strong>：开发循环体的不同迭代之间存在的并行性</p><p>开发循环级并行的基本技术方法：</p><ol><li>指令调度</li><li>循环展开</li><li>换名</li></ol><h2 id="循环展开调度的基本方法"><a href="#循环展开调度的基本方法" class="headerlink" title="循环展开调度的基本方法"></a>循环展开调度的基本方法</h2><p><code>循环展开</code>指的是展开循环体若干次，将<strong>循环级并行</strong>转换为 <strong>指令级并行</strong>的技术</p><p>这个过程：编译器静态完成 &amp;&amp; 硬件动态完成</p><p><strong>分支指令</strong> $\iff$ <strong>条件分支指令</strong></p><p>编译器在完成这种指令调度的时候，受限于两个特性</p><h2 id="整数流水线特性说明"><a href="#整数流水线特性说明" class="headerlink" title="整数流水线特性说明"></a>整数流水线特性说明</h2><p>载入延迟为一个节拍</p><p>由于数据的取操作的结果可以毫无停顿的通过相关通路机制传送到数据存部件，所以延迟为0.</p><p>分支指令，由整数流水线执行</p><p>分支条件检测搭调整到ID段</p><p>如果分支指令使用上一条指令的结果作为分支条件，就要延迟一个节拍</p><p>分支指令有一个节拍的延迟操</p><p>浮点运算一般为64位</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="指令集并行" scheme="https://molaters.github.io/tags/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>CA-第九讲 流水线中的冲突</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B9%9D%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B9%9D%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81/</id>
    <published>2023-11-24T03:30:49.026Z</published>
    <updated>2023-10-12T09:04:20.326Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<p><strong>流水线的性能</strong></p><p>吞吐率 加速比 效率</p><p>流水线性能的若干问题</p><p><strong>流水线的冲突</strong></p><p>产生的原因</p><p>冲突的分类</p><p><strong>流水线的结构冲突</strong></p><p>产生的原因</p><p>避免结构冲突的办法</p><p>有些流水线的设计允许结构冲突的存在</p><p><strong>流水线的数据冲突（暂停和定向）</strong></p><h2 id="流水线的数据冲突"><a href="#流水线的数据冲突" class="headerlink" title="流水线的数据冲突"></a>流水线的数据冲突</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925100551.png"                      alt="image.png"                ></p><p><em><strong>产生的原因</strong></em>：当指令在流水线中重叠执行时，流水线有可能改变指令读&#x2F;写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据冲突。</p><p><em><strong>消除方法</strong></em>: 向流水线中插入暂停周期</p><h3 id="通过定向技术减少数据冲突带来的暂停"><a href="#通过定向技术减少数据冲突带来的暂停" class="headerlink" title="通过定向技术减少数据冲突带来的暂停"></a>通过定向技术减少数据冲突带来的暂停</h3><p>定向（forwarding）, <strong>也称为旁路</strong></p><p><strong>工作过程</strong></p><p>主要思路：将计算结果直接从产生的地方送到正需要的地方，就可以避免暂停。</p><ul><li><p>寄存器文件EX&#x2F;MEM中的ALU运算结果总是回送到ALU的输入寄存器</p></li><li><p>从定向通路得到输入数据的ALU操作不必从源寄存器里面读取操作数</p></li></ul><h4 id="进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入"><a href="#进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入" class="headerlink" title="进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入"></a>进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925101208.png"                      alt="image.png"                ></p><h3 id="数据冲突的分类"><a href="#数据冲突的分类" class="headerlink" title="数据冲突的分类"></a>数据冲突的分类</h3><p>两条指令 i 和 j, 都会访问同一个寄存器R，假设i先进入流水线，那么它们对R有四种不同的访问顺序：</p><p><u>先写后读冲突</u>（RAW）—— i 写 j 读</p><p>最常见的数据冲突，是程序最重要的特征之一。</p><p><u>先写后写冲突</u>（WAW）—— i 写 j 写</p><p>修改之后的DLX流水线就会产生WAW相关</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925101914.png"                      alt="image.png"                ></p><p><em><strong>这个是后面的指令在前面的指令之前就写回</strong></em></p><p><u>先读后写冲突</u>（WAR）—— i 读 j 写</p><p>注意没有读后读冲突。</p><h3 id="需要暂停的数据冲突"><a href="#需要暂停的数据冲突" class="headerlink" title="需要暂停的数据冲突"></a>需要暂停的数据冲突</h3><p>并非所有的冲突都可以通过定向技术解决</p><p>增加流水线“<strong>流水线互锁</strong>”部件，当互锁硬件发现这样的冲突之后，就<u>暂停流水线</u>，直到相关解除。</p><p>在这种情况下，暂停的时钟周期数就称为“<strong>载入延迟</strong>”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925103031.png"                      alt="image.png"                ></p><p>解决的方法：就是产生气泡，将之前出现数据冲突的方式给再隔开</p><h3 id="对数据冲突的编译调度方法"><a href="#对数据冲突的编译调度方法" class="headerlink" title="对数据冲突的编译调度方法"></a>对数据冲突的编译调度方法</h3><p>流水线中会遇到多类型的暂停</p><p>编译器可以通过重新排列代码的顺序来消除这种暂停，这就是”<strong>流水线调度</strong>“和“<strong>指令调度</strong>”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925103501.png"                      alt="image.png"                ></p><p>基于调度来执行暂停的方法，可以将不相关的指令来进行调度，可以不仅起到气泡的作用，还可以不影响正常的执行速度</p><h3 id="对MIPS流水线控制的实现"><a href="#对MIPS流水线控制的实现" class="headerlink" title="对MIPS流水线控制的实现"></a>对MIPS流水线控制的实现</h3><p><strong>指令发射</strong>：指令从流水线的译码段进入执行段的过程称为指令的发射</p><p><strong>检测数据冲突</strong>：</p><ul><li>ID段可以检测所有的数据冲突</li><li>也可以在使用一个操作数的时钟周期的开始，并确定必须的定向</li><li>流水线相关硬件可以检测到的各种冲突情况</li></ul><p>针对不同的数据相关的内容，就需要检测数据相关的问题：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925104601.png"                      alt="image.png"                ></p><h4 id="Load互锁的检测与实现"><a href="#Load互锁的检测与实现" class="headerlink" title="Load互锁的检测与实现"></a>Load互锁的检测与实现</h4><p>在ID段检测是否需要启动Load互锁，必须进行三种比较</p><p>一旦检测到冲突，控制部件必须在流水线中插入暂停周期，并使IF和ID段中的指令停止前进。</p><ul><li>讲ID&#x2F;EX中控制部分清0</li><li>保持IF&#x2F;ID的内容不变</li></ul><h4 id="对MIPS流水线控制的实现-1"><a href="#对MIPS流水线控制的实现-1" class="headerlink" title="对MIPS流水线控制的实现"></a>对MIPS流水线控制的实现</h4><p>定向逻辑的实现</p><ul><li>所有定向都是从ALU&#x2F;DM的输出到ALU、DM或者0单元的输入</li><li>形成了一个<em><strong>旁路网络</strong></em><br>✔️需要比较哪些信息？<br>✔️ALU输入端应该采用多少个输入的MUX？</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925110658.png"                      alt="image.png"                ></p><h2 id="流水线的控制冒险"><a href="#流水线的控制冒险" class="headerlink" title="流水线的控制冒险"></a>流水线的控制冒险</h2><h3 id="分支指令的实现"><a href="#分支指令的实现" class="headerlink" title="分支指令的实现"></a>分支指令的实现</h3><ul><li>一旦分支转移成功，正确的地址要在Mem段才会被写入PC。</li><li>一旦ID段检测到分支指令，就执行执行其后的指令，直到分支指令到达Mem段，确定新的PC为止</li><li>分支转移成功将导致MIPS流水线暂停3个周期</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925112814.png"                      alt="image.png"                ></p><h3 id="减少分支开销的途径"><a href="#减少分支开销的途径" class="headerlink" title="减少分支开销的途径"></a>减少分支开销的途径</h3><p>✔️ 两个基本途径：同时采用，缺一不可！</p><p>:luc_check:在流水线尽早哦按段分支转移是否成功<br>:luc_check:转移成功的时候，尽早计算出转移目标地址</p><p>经过改进，MIPS流水线可以将分支开销减少一拍</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925113236.png"                      alt="image.png"                ></p><table><thead><tr><th>流水段</th><th>分支指令操作</th></tr></thead><tbody><tr><td>IF</td><td>IF&#x2F;ID.IR $\leftarrow$ Mem[PC]; IF&#x2F;ID.NPC,PC $\leftarrow$ (if ID&#x2F;EX.Cond {ID&#x2F;EX.NPC} else {PC+4})</td></tr><tr><td>ID</td><td></td></tr><tr><td>EX</td><td></td></tr><tr><td>MEM</td><td></td></tr><tr><td>WB</td><td></td></tr></tbody></table><p>再改进，MIPS流水线可以将分支开销再减少一拍</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925113253.png"                      alt="image.png"                ></p><p><em><strong>减少分支开销的途径</strong></em></p><h4 id="程序中分支指令的行为特点"><a href="#程序中分支指令的行为特点" class="headerlink" title="程序中分支指令的行为特点"></a>程序中分支指令的行为特点</h4><p>各种能改变PC值的指令的执行额度</p><p>条件分支：</p><ul><li>整数程序: 14-15%</li><li>浮点程序: 3-12%</li></ul><p>其中，向前分支和向后分支的比：3：1</p><p>条件分支转移成功的概率</p><ul><li>向前转移成功率：60%；向后转移成功率：85%</li></ul><h4 id="减少流水线分支损失的方法"><a href="#减少流水线分支损失的方法" class="headerlink" title="减少流水线分支损失的方法"></a>减少流水线分支损失的方法</h4><ol><li><p><strong>冻结或者排空流水线</strong></p><p> 思路：在流水线中停住或者删除分支之后的指令，直到知道转移目标地址</p><p> 优点：简单</p></li><li><p><strong>预测分支转移失败</strong></p><p> 思路：流水线继续照常流动，如果分支转移成功，就将分支指令后的指令转换为空操作，并从分支目标处开始取指令执行；否则照常执行</p></li><li><p><strong>预测分支转移成功</strong></p><p> 思路：始终假设分支成功，直接从分支目标处取指令执行，对MIPS没有任何好处</p></li><li><p><strong>延迟分支</strong></p><p> ⭐思路：分支开销为n的分支指令后面紧跟有n个延迟槽，流水线遇到分支指令的时候，按照正常方式来处理，顺带执行延迟槽中的指令，从而减少分支开销。</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927082642.png"                      alt="image.png"                ></p><p>所以什么样的指令能够放入分支延迟槽</p><p>三种调度方法：</p><ul><li>从前调度</li><li>从目标处调度</li><li>从失败的位置调度</li></ul><h4 id="各种分支处理方法的性能"><a href="#各种分支处理方法的性能" class="headerlink" title="各种分支处理方法的性能"></a>各种分支处理方法的性能</h4><ol><li>假设理想CPI &#x3D; 1，则加速比</li></ol><p>$$<br>S &#x3D; D &#x2F; (1+C) &#x3D; D &#x2F; (1+f \times p_{分支})<br>$$<br>这里，D为流水线的深度，$p_{分支}$为分支开销，C为分支引起的流水线暂停时钟周期数</p><h2 id="实例分析-：-MIPS-R4000"><a href="#实例分析-：-MIPS-R4000" class="headerlink" title="实例分析 ： MIPS R4000"></a>实例分析 ： MIPS R4000</h2><p>MIPS R4000的整型流水线<br>MIPS R4000的浮点流水线<br>MIPS R4000流水线性能分析</p><p>整型流水线</p><p>指令集：64位MIPS-3指令集</p><p>MIPS R4000流水线结构</p><ul><li>超流水结构</li><li>访存操作流水化</li></ul><p>流水线各段的功能</p><p>指令序列在流水线中的重叠执行过程。</p><p><strong>定向+插入暂停周期</strong></p><p>载入延迟为两个时钟周期</p><p>指令序列在流水线中的<strong>执行时空图</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927090904.png"                      alt="image.png"                ></p><p>R4000流水线的定向路径远多于MIPS流水线</p><p>ALU输入端的定向源有4个：EX&#x2F;DF,DF&#x2F;DS,DS&#x2F;TC,TC&#x2F;WB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="流水线技术" scheme="https://molaters.github.io/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CA-第七讲 流水线技术</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B8%83%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B8%83%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/</id>
    <published>2023-11-24T03:30:49.025Z</published>
    <updated>2023-10-12T09:03:02.202Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h1><h2 id="流水线的基本概念"><a href="#流水线的基本概念" class="headerlink" title="流水线的基本概念"></a>流水线的基本概念</h2><h3 id="产品生产流水线"><a href="#产品生产流水线" class="headerlink" title="产品生产流水线"></a>产品生产流水线</h3><p>一个问题</p><p>假设某个产品需要四道工序；1工人，1机器，8小时可以生产120件</p><p><strong>要将该产品8小时提高到480件</strong>，怎么实现目标</p><h4 id="两种解决方法"><a href="#两种解决方法" class="headerlink" title="两种解决方法"></a>两种解决方法</h4><p><strong>方案一</strong>：增加3名工人、三套设备</p><p><strong>方案二</strong>：产品生产采用流水线的方式，分为4道工序；增加3名工人，每人一道工序</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918101255.png"                      alt="Pasted image 20230918101255"                ></p><h4 id="两种方案的工作过程对比"><a href="#两种方案的工作过程对比" class="headerlink" title="两种方案的工作过程对比"></a>两种方案的工作过程对比</h4><p>两种方案中每一件生产时间不变</p><p><strong>但是在稳定情况下</strong>：</p><p>方案一：需要三套设备</p><p>方案二：不需要增加任何设备</p><p>使得每件产品的产出时间从表面上来看是从原来的4分钟缩减到1分钟</p><h3 id="计算机中的流水线"><a href="#计算机中的流水线" class="headerlink" title="计算机中的流水线"></a>计算机中的流水线</h3><h4 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918101705.png"                      alt="Pasted image 20230918101705"                ></p><h4 id="功能部件流水线"><a href="#功能部件流水线" class="headerlink" title="功能部件流水线"></a>功能部件流水线</h4><h3 id="流水技术的定义"><a href="#流水技术的定义" class="headerlink" title="流水技术的定义"></a>流水技术的定义</h3><p>将一重复的时序过程分解为若干子过程，每个子过程都可有效地在其专用功能段上与其它子过程同时执行这种技术称为流水技术。</p><h3 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h3><p>从时间和空间两个方面来描述流水线的工作流程，横坐标表示时间，纵坐标表示各个流水段。</p><p><strong>流水线需要改造的话需要考虑的原则</strong>：</p><p><strong>1. Repetition of identical operations</strong><br>Repetition of identical operations refers to the practice of carrying out the same set of tasks multiple times. This can be done intentionally to achieve a specific goal or unintentionally due to errors or inefficiencies in a process. Repetition of identical operations can be seen in various domains, including manufacturing, software development, data entry, and administrative tasks.</p><p><strong>2. Repetition of independent operations</strong><br>Repetition of independent operations refers to the process of repeatedly carrying out the same operations on different elements or data sets. </p><p>For example, if you have a list of numbers and you want to multiply each number by 2, you can use repetition of independent operations to apply the same multiplication operation to each number in the list. This can be achieved through looping or iterating over the data set and performing the operation on each element.</p><p>By utilizing repetition of independent operations, you can save time and effort by avoiding the need to manually perform the operation on each element individually. Instead, you can automate the process and apply the operation to all the elements in a more efficient manner.</p><h4 id="流水线技术原理"><a href="#流水线技术原理" class="headerlink" title="流水线技术原理"></a>流水线技术原理</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918102435.png"                      alt="Pasted image 20230918102435"                ></p><p>左边的三角表示的是<strong>载入时间</strong></p><p>右边的三角叫做<strong>排空时间</strong></p><h3 id="流水线的特点"><a href="#流水线的特点" class="headerlink" title="流水线的特点"></a>流水线的特点</h3><ul><li><p>流水过程由多个相关的子过程组成，这些子过程称为流水线的“级” 和 “段” 。 </p></li><li><p>每个子过程由专用的功能段实现</p></li><li><p>各个功能段的时间应该基本相等，通常为一个时钟周期</p></li><li><p>流水线需要一定的 <strong>通过时间</strong>才能稳定</p></li><li><p>流水技术适合于<strong>大量重复的时序过程</strong></p></li></ul><h2 id="流水线分类"><a href="#流水线分类" class="headerlink" title="流水线分类"></a>流水线分类</h2><h3 id="单功能流水线和多功能流水线"><a href="#单功能流水线和多功能流水线" class="headerlink" title="单功能流水线和多功能流水线"></a>单功能流水线和多功能流水线</h3><ul><li>按照流水线所完成的功能分类</li><li><strong>单功能流水线</strong></li></ul><p>A single-function pipeline refers to a type of manufacturing or production system where each stage of the process is dedicated to performing a specific task. This means that the different stages of the pipeline are set up to carry out only one particular function or operation. Single-function pipelines are commonly used in industries such as assembly lines, where each stage focuses on a specific task to achieve efficiency and specialization.<br>Source: <a class="link"   href="https://en.wikipedia.org/wiki/Assembly_line" >Wikipedia - Assembly line <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li><strong>多功能流水线</strong><br>多功能流水线是一种在制造过程中用于完成多种任务的系统。它可以自动化地将产品从一个工作站传递到另一个工作站，实现高效的生产和制造。</li></ul><p>加工、装配或检测操作。这样，同一条流水线可以生产多种不同的产品，实现灵活的生产线调整。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918103607.png"                      alt="Pasted image 20230918103607"                ></p><h3 id="静态流水线和动态流水线"><a href="#静态流水线和动态流水线" class="headerlink" title="静态流水线和动态流水线"></a><em>静态流水线和动态流水线</em></h3><p><strong>静态流水线</strong>和<strong>动态流水线</strong>是计算机体系结构中常见的两种流水线设计方式。静态流水线是指在工作期间固定不变的流水线，而动态流水线则允许流水线结构在运行过程中进行改变。</p><p><code>静态流水线</code>的特点是流水线的各个阶段的<strong>功能和顺序是固定不变的</strong>。这种设计适用于执行时间相对稳定且操作相对简单的任务。静态流水线的优点是结构简单，并且可以通过合理安排各个阶段的操作来达到最小化时钟周期的效果。但是，静态流水线的缺点是对于执行时间不稳定的任务不太适用，并且无法处理<br>控制流转移和异常。</p><p><code>动态流水线</code>允许在运行过程中根据需要改变流水线结构。这种设计更适用于执行时间波动较大或包含复杂分支转移的任务。动态流水线的优点是可以根据任务的要求动态地修改流水线的结构，以充分利用各个阶段的处理能力。但是，动态流水线的缺点是在改变流水线结构时会带来额外的开销，并且可能导致流水线中的指令乱序执行，影响性能。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918103804.png"                      alt="Pasted image 20230918103804"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918103815.png"                      alt="Pasted image 20230918103815"                ></p><h3 id="部件级、处理机级以及处理机之间的流水线"><a href="#部件级、处理机级以及处理机之间的流水线" class="headerlink" title="部件级、处理机级以及处理机之间的流水线"></a>部件级、处理机级以及处理机之间的流水线</h3><ul><li><p>按照流水的级别划分</p></li><li><p>部件级流水线 <strong>运算操作流水线</strong></p></li><li><p>处理机级流水线 <strong>指令流水线</strong></p></li><li><p>处理机间流水线 <strong>宏流水线</strong></p></li></ul><h3 id="标量流水处理机和向量流水处理机"><a href="#标量流水处理机和向量流水处理机" class="headerlink" title="标量流水处理机和向量流水处理机"></a>标量流水处理机和向量流水处理机</h3><ul><li><p>按照数据来表示分类</p></li><li><p>标量流水处理机</p></li><li><p>向量流水处理机</p></li></ul><blockquote><p>According to my knowledge, there are several ways to classify processors based on their data representation and processing methods. Two common classifications are scalar pipeline processing and vector pipeline processing.</p></blockquote><blockquote><p>Scalar pipeline processing, also known as scalar processing, operates on one data element at a time. It follows a single instruction stream and performs sequential execution of instructions.</p></blockquote><blockquote><p>Vector pipeline processing, on the other hand, operates on multiple data elements simultaneously. It uses vector instructions that can perform the same operation on multiple data elements in parallel.</p></blockquote><blockquote><p>For more detailed information and examples of these classifications, you can refer to the following source: [source URL]</p></blockquote><h3 id="线性流水线和非线性流水线"><a href="#线性流水线和非线性流水线" class="headerlink" title="线性流水线和非线性流水线"></a>线性流水线和非线性流水线</h3><ul><li><p>按照是否有回馈回路来进行分类</p></li><li><p><strong>线性流水线</strong>是指流水线的隔断串行连接，没有反馈回路</p></li><li><p><strong>非线性流水线</strong>指的是流水线中除了有串行连接的通路之外，还有反馈回路</p></li></ul><p><strong>存在流水线调度问题</strong></p><p>确定什么时候想流水线引进新的输入，从而使得新输入的数据和先前操作的反馈数据在流水线中不产生冲突，这就是 <strong>流水线调度的问题</strong></p><h1 id="MIPS基本流水线"><a href="#MIPS基本流水线" class="headerlink" title="MIPS基本流水线"></a>MIPS基本流水线</h1><h2 id="基本MIPS流水线"><a href="#基本MIPS流水线" class="headerlink" title="基本MIPS流水线"></a>基本MIPS流水线</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918104742.png"                      alt="Pasted image 20230918104742"                ></p><p>要好好讲一讲上面这个图 ⬆</p><ol><li>I类 SW&#x2F;LW ADDI&#x2F;SUBI</li><li>R类 AND&#x2F;OR</li><li>J类 J name</li></ol><p>这几类指令在上图中都有什么操作？</p><hr><p><strong>取指</strong>：IR $\leftarrow$ IMem[PC] NPC $\leftarrow$ PC+4<br><strong>译码</strong>：A $\leftarrow$ $Regs[IR_{6…10}]$ B $\leftarrow Regs[IR_{11…15}]$ Imm $\leftarrow$ $Regs[(IR_{16})^{16}# #IR_{17…32}]$<br><strong>执行</strong>：SW&#x2F;LW ALUoutput $\leftarrow$ A+Imm<br><strong>ALU</strong>：<br>ADDI&#x2F;SUBI ALUoutput $\leftarrow$ A op Imm<br>ADD&#x2F;OR ALUoutput $\leftarrow$ A Func B<br>BEQZ ALUoutput $\leftarrow$ NPC + Imm, Cond $\leftarrow$ A op 0<br><strong>访存</strong>：<br>SW DMEM[ALUoutput] $\leftarrow$ B<br>LW LDM $\leftarrow$ DMEM[ALUoutput]<br>BEQZ if(Cond) PC $\leftarrow$ ALUoutput else PC $\leftarrow$ NPC<br><strong>写回</strong>：<br>ADDI&#x2F;SUBI  $Regs[IR_{11…15}]$ $\leftarrow$ ALUoutput<br>AWB&#x2F;OR $Regs[IR_{16…20}]$ $\leftarrow$ ALUoutput<br>LW $Regs[IR_{11…15}]$ $\leftarrow$ LMD</p><hr><h3 id="MIPS32的一种简单实现"><a href="#MIPS32的一种简单实现" class="headerlink" title="MIPS32的一种简单实现"></a>MIPS32的一种简单实现</h3><p>性能分析</p><p>在数据通路商，分支指令需要4个时钟周期</p><p>其他指令需要5个时钟周期</p><p>假设分支指令占总指令数量的12%，问CPI &#x3D; ？</p><p>$CPI &#x3D; 4 \times 12% + 5 \times(1-12%)&#x3D;4.88$</p><p><strong>结论：就性能和硬件开销而言，上述实现不是一种优化实现</strong>！</p><h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><p>在Mem周期完成ALU指令</p><blockquote><p>假设ALU指令数占指令总数的44%，则在时钟周期不变的同时，CPI可以降低至4.44</p></blockquote><p>如果要进一步降低CPI，可能需要延长时钟周期时间，使得每个时钟周期能够完成更多的工作</p><p>采用单周期实现，可以将CPI降低为1，但是时钟周期时间却会增加为原来的5倍</p><p><strong>一般不采用这种方法，为什么？</strong></p><h3 id="一种简单的MIPS流水线"><a href="#一种简单的MIPS流水线" class="headerlink" title="一种简单的MIPS流水线"></a>一种简单的MIPS流水线</h3><p>数据通路流水画<br>数据通路中的每一个周期就成为流水线的一段<br>每个时钟周期启动一条指令<br><strong>——得到了一条简单的MIPS流水线</strong><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918111702.png"                      alt="Pasted image 20230918111702"                ></p><h3 id="实现流水技术应该解决的一些问题"><a href="#实现流水技术应该解决的一些问题" class="headerlink" title="实现流水技术应该解决的一些问题"></a>实现流水技术应该解决的一些问题</h3><h4 id="应该保证流水线各个段不会在同一周期内使用相同的通路资源"><a href="#应该保证流水线各个段不会在同一周期内使用相同的通路资源" class="headerlink" title="应该保证流水线各个段不会在同一周期内使用相同的通路资源"></a>应该保证流水线各个段不会在同一周期内使用相同的通路资源</h4><ul><li>例如，不能要求一个ALU既做有效地址结算，又做减法操作</li><li>IF和Mem两个阶段都要访问存储器，怎样避免访存冲突</li><li>ID和WB两个阶段都要访问存储器，<strong>是否存在冲突</strong>？<strong>怎样避免</strong>？</li></ul><h4 id="PC计算问题"><a href="#PC计算问题" class="headerlink" title="PC计算问题"></a>PC计算问题</h4><p>为了能够在每个时钟周期启动一条新的指令，流水线必须在IF段获得下一条指令的地址，并保存在PC中</p><p>但是，分支指令会改变PC的值，而且只有在Mem结束时，这个新的值才会被写入PC，出现矛盾</p><p>对于顺序执行，<strong>可以修改数据通路</strong>在IF段完成PC计算，但是分支指令怎么处理？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918112327.png"                      alt="Pasted image 20230918112327"                ></p><h4 id="合理划分流水段，每段内的操作都必须在一个时钟周期内完成"><a href="#合理划分流水段，每段内的操作都必须在一个时钟周期内完成" class="headerlink" title="合理划分流水段，每段内的操作都必须在一个时钟周期内完成"></a>合理划分流水段，每段内的操作都必须在一个时钟周期内完成</h4><h4 id="流水线寄存器设计"><a href="#流水线寄存器设计" class="headerlink" title="流水线寄存器设计"></a>流水线寄存器设计</h4><ul><li>设置<strong>流水线寄存器文件</strong></li><li>流水线寄存器文件的命名</li><li>段A和段B之间的流水线寄存器称为A&#x2F;B</li><li>[[#流水线寄存器的作用]]</li><li>[[#流水线寄存器文件的构成]]</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918112749.png"                      alt="Pasted image 20230918112749"                ></p><h3 id="MIPS流水线的操作"><a href="#MIPS流水线的操作" class="headerlink" title="MIPS流水线的操作"></a>MIPS流水线的操作</h3><p>在任意时刻，流水中的指令旨在流水线中的某一段内执行操作。</p><p>因此，只要知道了每一个流水段在各个至零下进行何种操作，就知道了整个流水线的操作</p><ul><li>[[#MIPS流水线每个流水段的操作]]</li></ul><h3 id="MIPS流水线中多路选择器的控制"><a href="#MIPS流水线中多路选择器的控制" class="headerlink" title="MIPS流水线中多路选择器的控制"></a>MIPS流水线中多路选择器的控制</h3><p>主要是确定如何 <strong>控制那四个多路选择器</strong></p><p>ALU输入端的两个MUX由ID&#x2F;EX.IR所指出的指令类型限制</p><p>IF段的MUX由EX&#x2F;MEM。Cond域的值控制<br>WB段的MUX由当前指令类型Load&#x2F;ALU控制</p><h2 id="流水线性能分析"><a href="#流水线性能分析" class="headerlink" title="流水线性能分析"></a>流水线性能分析</h2><hr><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h4 id="流水线寄存器的作用"><a href="#流水线寄存器的作用" class="headerlink" title="流水线寄存器的作用"></a>流水线寄存器的作用</h4><p>[[#流水线寄存器设计]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918113024.png"                      alt="Pasted image 20230918113024"                ></p><h4 id="流水线寄存器文件的构成"><a href="#流水线寄存器文件的构成" class="headerlink" title="流水线寄存器文件的构成"></a>流水线寄存器文件的构成</h4><p>[[#流水线寄存器设计]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918113156.png"                      alt="Pasted image 20230918113156"                ></p><h4 id="MIPS流水线每个流水段的操作"><a href="#MIPS流水线每个流水段的操作" class="headerlink" title="MIPS流水线每个流水段的操作"></a>MIPS流水线每个流水段的操作</h4><p>[[#MIPS流水线的操作]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918114008.png"                      alt="Pasted image 20230918114008"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918113739.png"                      alt="Pasted image 20230918113739"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="流水线技术" scheme="https://molaters.github.io/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CA-改进Cache的性能</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%94%B9%E8%BF%9BCache%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%94%B9%E8%BF%9BCache%E7%9A%84%E6%80%A7%E8%83%BD/</id>
    <published>2023-11-24T03:30:49.023Z</published>
    <updated>2023-10-30T02:39:43.118Z</updated>
    
    <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><h2 id="改进Cache的性能"><a href="#改进Cache的性能" class="headerlink" title="改进Cache的性能"></a>改进Cache的性能</h2><p>从三个方面改进Cache的措施：</p><ol><li><p>降低失效率</p></li><li><p>减少失效开销</p></li><li><p>减少Cache命中时间</p></li></ol><p>一共有17种Cache优化技术</p><h3 id="降低失效率"><a href="#降低失效率" class="headerlink" title="降低失效率"></a>降低失效率</h3><p>三种失效：</p><ol><li>强制性失效</li><li>容量失效</li><li>冲突失效（碰撞失效，干扰失效）</li></ol><p>相联度越高，冲突失效就越小；<br>强制性失效不受Cache容量的影响，但是容量是小却随着容量的增加而减少；强制失效和容量失效不受相联度的影响</p><h3 id="调节块的大小"><a href="#调节块的大小" class="headerlink" title="调节块的大小"></a>调节块的大小</h3><p>在固定容量的情况下，增加块的大小会降低失效率</p><ul><li>Cache失效率和块大小的关系</li></ul><h3 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h3><h3 id="Victim-Cache"><a href="#Victim-Cache" class="headerlink" title="Victim Cache"></a>Victim Cache</h3><h3 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h3><p>4KB 直接映像Cache,块大小为16字节</p><p>1个块的指令流缓冲器：捕获15%~25%的失效</p><h3 id="编译器控制和预取"><a href="#编译器控制和预取" class="headerlink" title="编译器控制和预取"></a>编译器控制和预取</h3><p><strong>预取指令</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[[CA-NotesView]]&lt;/p&gt;
&lt;h2 id=&quot;改进Cache的性能&quot;&gt;&lt;a href=&quot;#改进Cache的性能&quot; class=&quot;headerlink&quot; title=&quot;改进Cache的性能&quot;&gt;&lt;/a&gt;改进Cache的性能&lt;/h2&gt;&lt;p&gt;从三个方面改进Cache的措</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-模块体系</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%A8%A1%E5%9D%97%E4%BD%93%E7%B3%BB/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%A8%A1%E5%9D%97%E4%BD%93%E7%B3%BB/</id>
    <published>2023-11-24T03:30:49.023Z</published>
    <updated>2023-10-12T09:02:26.707Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><ol><li><p><code>IMEM</code>模块用于指令存储器的读取，将PC地址传递给存储器，读取当前指令到<code>IRin</code>。</p></li><li><p><code>PC</code>模块用于管理程序计数器，包括在时钟上升沿时选择下一条指令的地址，以及处理复位信号。</p></li><li><p><code>ADD</code>模块用于计算下一条指令的地址，将当前PC地址传递给<code>PC</code>模块。</p></li><li><p><code>NPC</code>模块用于存储下一条指令的地址。</p></li><li><p><code>IR</code>模块用于指令寄存器的加载，将当前指令传递给<code>IRout</code>。</p></li></ol><p><strong>ID (Instruction Decode) 模块:</strong></p><ol><li><p><code>Regfile</code>模块用于管理寄存器堆的读和写操作，根据指令选择寄存器读取和写入。</p></li><li><p><code>CU</code>模块用于控制单元，解析指令并生成相应的控制信号，例如ALU操作码、写寄存器使能等。</p></li><li><p><code>A</code>和<code>B</code>模块用于选择和加载寄存器A和B的数据。</p></li><li><p><code>Extender</code>模块用于符号扩展立即数。</p></li><li><p><code>Imm</code>模块用于加载立即数。</p></li></ol><p><strong>EX (Execution) 模块:</strong></p><ol><li><p><code>A_MUX</code>和<code>B_MUX</code>模块用于选择ALU的输入数据，可以选择寄存器数据、NPC、基址或立即数。</p></li><li><p><code>ALU</code>模块执行ALU操作，并生成结果和零标志。</p></li></ol><p><strong>MEM (Memory) 模块:</strong></p><ol><li><p><code>ALU_out</code>模块用于加载ALU的结果。</p></li><li><p><code>PC_MUX</code>模块用于选择下一个PC地址，可以选择NPC、ALU结果或分支指令的目标地址。</p></li><li><p><code>WB_Reg_MUX</code>模块用于选择写回数据，可以选择ALU结果、内存读取结果或寄存器A的数据。</p></li><li><p><code>WB_Reg_Addr_MUX</code>模块用于选择写回寄存器的地址。</p></li><li><p><code>DMEM</code>模块用于数据存储器的读写操作。</p></li><li><p><code>LDM</code>模块用于加载内存数据。</p></li></ol><p><strong>其他：</strong></p><ul><li><code>debug_wb_pc</code>、<code>debug_wb_rf_wen</code>、<code>debug_wb_rf_addr</code>、<code>debug_wb_rf_wdata</code>用于调试目的，输出当前执行指令的信息。</li></ul><p>这个CPU的基本架构是一个五级流水线，包括IF、ID、EX、MEM和WB（写回）阶段。每个阶段由不同的模块负责执行特定的任务，并在时钟上升沿进行数据传递。各个模块之间通过信号进行通信，根据指令的不同，选择不同的数据路径和操作。</p><p>以下是在前面的叙述中添加了原始Verilog代码的版本：</p><p><strong>IF (Instruction Fetch) 模块:</strong></p><ol><li><code>IMEM</code>模块用于指令存储器的读取，将PC地址传递给存储器，读取当前指令到<code>IRin</code>。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMEM U_IMEM (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="variable">.imem_addr</span>(PCout[<span class="number">7</span>:<span class="number">0</span>]),   <span class="comment">// 选定存储地址</span></span><br><span class="line">    <span class="variable">.imem_rdata</span>(IRin)         <span class="comment">// 读出的指令</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="2"><li><code>PC</code>模块用于管理程序计数器，包括在时钟上升沿时选择下一条指令的地址，以及处理复位信号。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PC U_PC (</span><br><span class="line">    <span class="variable">.Reset</span>(!resetn),</span><br><span class="line">    <span class="variable">.Clk</span>(clk),</span><br><span class="line">    <span class="variable">.PCwen</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.NPC</span>(PC_chosen),          <span class="comment">// 是由选择器给出的</span></span><br><span class="line">    <span class="variable">.PC</span>(PCout)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>ADD</code>模块用于计算下一条指令的地址，将当前PC地址传递给<code>PC</code>模块。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD U_ADD (</span><br><span class="line">    <span class="variable">.PC</span>(PCout),</span><br><span class="line">    <span class="variable">.NextPC</span>(NewPC)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="4"><li><code>NPC</code>模块用于存储下一条指令的地址。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NPC U_NPC (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                 <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),             <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.NPCin</span>(NewPC),</span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),               <span class="comment">// 载入使能</span></span><br><span class="line">    <span class="variable">.NPCout</span>(NPC)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="5"><li><code>IR</code>模块用于指令寄存器的加载，将当前指令传递给<code>IRout</code>。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IR U_IR (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                 <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),             <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.IRin</span>(IRin),</span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),               <span class="comment">// 载入使能</span></span><br><span class="line">    <span class="variable">.IRout</span>(IRout)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p><strong>ID (Instruction Decode) 模块:</strong></p><ol><li><code>Regfile</code>模块用于管理寄存器堆的读和写操作，根据指令选择寄存器读取和写入。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Regfile U_regfile (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="variable">.raddr1</span>(IRout[<span class="number">25</span>:<span class="number">21</span>]),    <span class="comment">// 寄存器堆读地址1</span></span><br><span class="line">    <span class="variable">.rdata1</span>(reg_a_out),       <span class="comment">// 返回数据1</span></span><br><span class="line">    <span class="variable">.raddr2</span>(IRout[<span class="number">20</span>:<span class="number">16</span>]),    <span class="comment">// 寄存器堆读地址2</span></span><br><span class="line">    <span class="variable">.rdata2</span>(reg_b_out),       <span class="comment">// 返回数据2</span></span><br><span class="line">    <span class="variable">.we</span>(reg_w &amp;&amp; IRout),      <span class="comment">// 写使能</span></span><br><span class="line">    <span class="variable">.waddr</span>(reg_addr_choose[<span class="number">4</span>:<span class="number">0</span>]), <span class="comment">// 写地址</span></span><br><span class="line">    <span class="variable">.wdata</span>(reg_mux_out)       <span class="comment">// 写数据</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="2"><li><code>CU</code>模块用于控制单元，解析指令并生成相应的控制信号，例如ALU操作码、写寄存器使能等。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CU U_CU (</span><br><span class="line">    <span class="variable">.Instruct</span>(IRout),          <span class="comment">// 输入指令</span></span><br><span class="line">    <span class="variable">.Zero</span>(zero),               <span class="comment">// 零标志位</span></span><br><span class="line">    <span class="variable">.ram_w</span>(ram_w),             <span class="comment">// 存储器写使能</span></span><br><span class="line">    <span class="variable">.reg_w</span>(reg_w),             <span class="comment">// 寄存器写使能</span></span><br><span class="line">    <span class="variable">.Card</span>(Card),               <span class="comment">// ALU 功能码</span></span><br><span class="line">    <span class="variable">.PC_s</span>(PC_s),               <span class="comment">// PC 数据来源选择</span></span><br><span class="line">    <span class="variable">.regfile_s</span>(regfile_s),     <span class="comment">// 寄存器文件数据来源选择</span></span><br><span class="line">    <span class="variable">.regfile_addr_s</span>(regfile_addr_s), <span class="comment">// 寄存器文件地址来源选择</span></span><br><span class="line">    <span class="variable">.ALU_As</span>(A_s),              <span class="comment">// ALU 输入 A 来源选择</span></span><br><span class="line">    <span class="variable">.ALU_Bs</span>(B_s)               <span class="comment">// ALU 输入 B 来源选择</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>A</code>和<code>B</code>模块用于选择和加载寄存器A和B的数据。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A U_A (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(reg_a_out),            <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(A_out)                <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">B U_B (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(reg_b_out),            <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(B_out)                <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="4"><li><code>Extender</code>模块用于符号扩展立即数。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Extender U_Extender (</span><br><span class="line">    <span class="variable">.Immin</span>(IRout[<span class="number">15</span>:<span class="number">0</span>]),</span><br><span class="line">    <span class="variable">.Immout</span>(Imm)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="5"><li><code>Imm</code>模块用于加载立即数。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Imm U_Imm (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(Imm),                  <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(Imm_out)              <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>这些Verilog模块构成了IF和ID阶段的核心逻辑，负责指令的获取、寄存器堆的读写、控制信号的生成等任务。</p><p><strong>EX (Execution) 模块:</strong></p><ol><li><code>A_MUX</code>和<code>B_MUX</code>模块用于选择ALU的输入数据，可以选择寄存器数据、NPC、基址或立即数。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">A_MUX A_MUX (</span><br><span class="line">    <span class="variable">.A_data1</span>(A_out),                  <span class="comment">// A寄存器的输出</span></span><br><span class="line">    <span class="variable">.A_data2</span>(NPC),                    <span class="comment">// 根据现在的PC产生的NPC值</span></span><br><span class="line">    <span class="variable">.A_data3</span>(A_out),                  <span class="comment">// 代表base的值</span></span><br><span class="line">    <span class="variable">.A_data4</span>(&#123;<span class="number">27&#x27;b0</span>,IRout[<span class="number">10</span>:<span class="number">6</span>]&#125;),    <span class="comment">// 代表左移的偏置量sa</span></span><br><span class="line">    <span class="variable">.A_select</span>(A_s),</span><br><span class="line">    <span class="variable">.A_data_chosen</span>(ALU_A_in)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">B_MUX B_MUX (</span><br><span class="line">    <span class="variable">.B_data1</span>(B_out),              <span class="comment">// B寄存器的输出</span></span><br><span class="line">    <span class="variable">.B_data2</span>(Imm_out),            <span class="comment">// 立即数扩展符号位之后的输出</span></span><br><span class="line">    <span class="variable">.B_data3</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.B_data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.B_select</span>(B_s),</span><br><span class="line">    <span class="variable">.B_data_chosen</span>(ALU_B_in)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALU U_ALU (</span><br><span class="line">    <span class="variable">.A</span>(ALU_A_in),</span><br><span class="line">    <span class="variable">.B</span>(ALU_B_in),</span><br><span class="line">    <span class="variable">.Cin</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.Card</span>(Card),</span><br><span class="line">    <span class="variable">.F</span>(alu_out),</span><br><span class="line">    <span class="variable">.Cout</span>(cout),</span><br><span class="line">    <span class="variable">.Zero</span>(zero)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>这些模块构成了EX阶段的核心逻辑，负责执行ALU操作、选择ALU输入数据等任务。</p><p><strong>MEM (Memory) 模块:</strong></p><ol><li><code>ALU_out</code>模块用于加载ALU的结果。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALU_out U_ALU_output (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(alu_out),              <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(result)               <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="2"><li><code>PC_MUX</code>模块用于选择下一个PC地址，可以选择NPC、ALU结果或分支指令的目标地址。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PC_MUX PC_MUX (</span><br><span class="line">    <span class="variable">.data1</span>(NPC),</span><br><span class="line">    <span class="variable">.data2</span>(result),</span><br><span class="line">    <span class="variable">.data3</span>(&#123;NPC[<span class="number">31</span>:<span class="number">28</span>],IRout[<span class="number">25</span>:<span class="number">0</span>],<span class="number">2&#x27;b0</span>&#125;),</span><br><span class="line">    <span class="variable">.data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.select</span>(PC_s),</span><br><span class="line">    <span class="variable">.data_chosen</span>(PC_chosen)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>WB_Reg_MUX</code>模块用于选择写回数据，可以选择ALU结果、内存读取结果或寄存器A的数据。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WB_DATA_MUX WB_Reg_MUX (</span><br><span class="line">    <span class="variable">.data1</span>(result),</span><br><span class="line">    <span class="variable">.data2</span>(ldm_out),</span><br><span class="line">    <span class="variable">.data3</span>(A_out),</span><br><span class="line">    <span class="variable">.data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.select</span>(regfile_s),</span><br><span class="line">    <span class="variable">.data_chosen</span>(reg_mux_out)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="4"><li><code>WB_Reg_Addr_MUX</code>模块用于选择写回寄存器的地址。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WB_ADDR_MUX WB_Reg_Addr_MUX (</span><br><span class="line">    <span class="variable">.data1</span>(&#123;<span class="number">27&#x27;b0</span>,IRout[<span class="number">15</span>:<span class="number">11</span>]&#125;),</span><br><span class="line">    <span class="variable">.data2</span>(&#123;<span class="number">27&#x27;b0</span>,IRout[<span class="number">20</span>:<span class="number">16</span>]&#125;),</span><br><span class="line">    <span class="variable">.data3</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.select</span>(regfile_addr_s),</span><br><span class="line">    <span class="variable">.data_chosen</span>(reg_addr_choose)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="5"><li><code>DMEM</code>模块用于数据存储器的读写操作。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DMEM U_DMEM (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="variable">.dmem_addr</span>(result[<span class="number">7</span>:<span class="number">0</span>]),    <span class="comment">// 选定存储地址</span></span><br><span class="line">    <span class="variable">.dmem_wdata</span>(reg_b_out),     <span class="comment">// 输入的数据</span></span><br><span class="line">    <span class="variable">.dmem_wen</span>(ram_w),           <span class="comment">// 写使能</span></span><br><span class="line">    <span class="variable">.dmem_rdata</span>(ldm_in)         <span class="comment">// 读出的数据</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="6"><li><code>LDM</code>模块用于加载内存数据。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LDM LDM (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(ldm_in),               <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(ldm_out)              <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>这些模块构成了MEM阶段的核心逻辑，负责执行内存操作、选择写回数据和地址等任务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="CPU设计" scheme="https://molaters.github.io/tags/CPU%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>CA-操作类型和大小</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%A7%E5%B0%8F/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%A7%E5%B0%8F/</id>
    <published>2023-11-24T03:30:49.021Z</published>
    <updated>2023-10-12T09:02:39.680Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[../../计算机体系结构课程总括|计算机体系结构课程总括]]<h1 id="操作类型和大小"><a href="#操作类型和大小" class="headerlink" title="操作类型和大小"></a>操作类型和大小</h1><p>确定操作数表示实际上也是软硬件取舍折中的问题</p><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><p>整数：二进制的补码表示；大小可以是字节，半字和单字</p><p>十进制：<strong>压缩十进制</strong>，<strong>二进制编码十进制</strong>，压缩十进制数据表示用四位编码数字0~9，然后将两个十进制数字压缩在一个字节中 </p><p>存储。</p><p>操作数类型的表示主要有如下的两种方法：</p><ul><li>操作数的类型可以以操作码的编码指定，这也是最常见的一种方法</li><li>数据可以附上由<code>硬件解释的标记（tag）</code>,由这些标记指定操作数的类型，从而选择适当的运算。然而有标记数据的机器非常少见</li></ul><p>操作数的表示是所有类型的子集，是一种折衷。</p><h2 id="操作数的大小"><a href="#操作数的大小" class="headerlink" title="操作数的大小"></a>操作数的大小</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911111339574-1694402576165-4.png"                      alt="image-20230911111339574" style="zoom:67%;"                 ><h2 id="指令系统设计的基本原则"><a href="#指令系统设计的基本原则" class="headerlink" title="指令系统设计的基本原则"></a>指令系统设计的基本原则</h2><h3 id="指令系统的设计"><a href="#指令系统的设计" class="headerlink" title="指令系统的设计"></a>指令系统的设计</h3><ul><li>首先考虑应该事先的基本功能，确定哪些功能应该用硬件实现，哪些功能用软件实现</li><li><strong>包括</strong><ul><li>指令的功能设计</li><li>指令格式的设计</li></ul></li></ul><h3 id="指令系统设计的基本原则-1"><a href="#指令系统设计的基本原则-1" class="headerlink" title="指令系统设计的基本原则"></a>指令系统设计的基本原则</h3><p>指令系统的设计</p><p>在确定这些<code>基础功能</code>之后要考虑<code>三个因素</code>：速度、成本、灵活性</p><p>硬件实现的特点：速度快成本高灵活性差</p><p>软件实现的特点：速度慢价格便宜灵活性高</p><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>在一个有限可用的存储空间内，对于任何可解的问题，在编制计算程序时，指令系统所提供的指令足够使用。完整性要求指令系统功能全、使用方便。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911112139867-1694402569721-1.png"                      alt="image-20230911112139867" style="zoom:67%;"                 ><h3 id="规整性"><a href="#规整性" class="headerlink" title="规整性"></a>规整性</h3><p>规整性主要包括对称性和均匀性。</p><ul><li><p>对称性：对称性是指所有与指令系统相关的<code>存储单元</code>的使用、<code>操作码的设置</code>等都是<strong>对称</strong>的。例如，在存储单元的使用上，所有通用寄存器都要同等对待。</p></li><li><p>均匀性：指对于各种<code>不同</code>的操作数类型、字长和数据存储单元，指令的设置都要<code>同等对待</code>。**例如，如果某机器有 5 种数据表示，4 种字长，两种存储单元，则要设置 5x4x2&#x3D;40 种同一操作的指令(如加法指令)**。不过，这样做太复杂，也不太现实。所以一般是实现有限的规整性。例如，把上述加法指令的种类减少到 10 种以内。</p></li></ul><h3 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h3><ul><li><strong>正交性</strong>：是指在指令中各个不同含义的字段，如操作数类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立。高效率是指指令的执行速度快、使用频度高。在 RISC 结构中，大多数指令都能在一个节拍内完成(流水)，而且只设置使用频度高的指令。</li><li><strong>高效率</strong>：求指令的向后兼容。</li><li><strong>兼容性</strong>主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能。</li></ul><p>在设计系统时，有两种截然不同的设计策略，因而产生了两类不同的计算机系统，CISC 和 RISC。CISC 是增强指令功能，把越来越多的功能交由硬件来实现，指令的数量也是越来越多。RISC 是尽可能地把指令系统简化，不仅指令的条数少，而且指令的功能也比较简单</p><h1 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h1><p>能够改变控制流的指令有4种:<strong>分支</strong> (<em>branch</em>)、<strong>跳转</strong>(<em>jump</em>)、<strong>过程调用</strong> (<em>call</em>)和<strong>过程返回</strong>(<em>return</em>)。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911113245581.png"                      alt="image-20230911113245581"                ></p><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><p>条件分支的分支条件表示：</p><table><thead><tr><th>分支条件表示</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>条件码</strong>：在程序的控制下，由ALU的操作设置特殊的位</td><td><em>可以设置自由设置分支条件</em></td><td>必须从一条指令将分支条件信息传送到分支指令，所以CC是额外状态，条件码限制了执行顺序。</td></tr><tr><td><strong>条件寄存器</strong>：比较指令把比较结果放进任何一个寄存器，检测的时候就检测这个寄存器</td><td><em>简单</em></td><td>占用了一个<code>寄存器</code>。</td></tr><tr><td><strong>比较分支</strong>：受到一定限制</td><td><em>一条指令完成两条指令的功能</em></td><td>分支指令的操作<code>增多</code>。</td></tr></tbody></table><p><strong>小于或者等于分支占主导地位</strong>。</p><p>因为大多数时候写的是</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;length;i++);</span><br></pre></td></tr></table></figure></div><p>所以才会导致$\leq$的数目增多</p><p><strong>分支地址转移目标的表示</strong>：采用4~8位的偏移量字段（以指令字为单位）就能表</p><p>示大多数控制指令的转移目标地址</p><h2 id="过程调用和返回的状态保存"><a href="#过程调用和返回的状态保存" class="headerlink" title="过程调用和返回的状态保存"></a>过程调用和返回的状态保存</h2><p><strong>“调用者保存”方法 vs “被调用者保存”方法</strong></p><p>调用者保存不知道需要用到什么寄存器，而被调用者知道使用什么寄存器来保存断点。</p><p>所以被调用者保存是更加普遍的方法</p><h1 id="指令操作码的优化"><a href="#指令操作码的优化" class="headerlink" title="指令操作码的优化"></a>指令操作码的优化</h1><ol><li><strong>等长扩展码</strong></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694564098310.png"                      alt="1694564098310"                ></p><p>不是说只有一种方法，按照扩展标识的不同，还有其他的许多种扩展方法。</p><p>👩🏻‍🏫扩展操作码必须遵守短码不能是长码的前缀的规则。扩展操作码的编码不唯一，平均码也不唯一。</p><ol start="2"><li><strong>定长操作码</strong></li></ol><p><code>固定长度的操作码</code>:所有指令的操作码都是同一个长度。</p><p>保证操作码的译码速度、减少译码的复杂度。</p><p>按照程序的存储空间为代价去换取硬件上的简单实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="指令系统" scheme="https://molaters.github.io/tags/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CA-指令系统的发展和改进</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%94%B9%E8%BF%9B/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%94%B9%E8%BF%9B/</id>
    <published>2023-11-24T03:30:49.019Z</published>
    <updated>2023-10-12T09:02:43.723Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># CISC指令集功能设计<h2 id="1-面向目标程序增强指令功能"><a href="#1-面向目标程序增强指令功能" class="headerlink" title="1. 面向目标程序增强指令功能"></a>1. 面向目标程序增强指令功能</h2><ul><li><p>对频率高的指令串，用一条<strong>新的指令</strong>来替代</p></li><li><p>既能<strong>减少目标程序的执行时间</strong>，又能有效<strong>缩短程序长度</strong></p></li><li><p><u>改进</u>方面：</p><ul><li><p>增强运算型指令的功能</p></li><li><p>增强数据传送指令的功能</p><ul><li><code>比如说进行数组的搬运等</code></li></ul></li><li><p>增强程序控制指令的功能</p></li></ul></li></ul><hr><h2 id="2-面向高级语言的优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）"><a href="#2-面向高级语言的优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）" class="headerlink" title="2. 面向高级语言的优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）"></a>2. 面向<strong>高级语言的</strong>优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）</h2><ul><li><p><span style="color:#c45a65">高级语言与一般的机器语言的语义差距非常大，为高级语言程序的编译带来了一些问题</span></p></li><li><p>✅编译器本身比较复杂</p></li><li><p>✅编译生成的目标代码比较难达到很好的优化</p><ol><li><p>对高级语言和<strong>编译器</strong>的支持。在高级语言中找一些常用的指令并做一些支持。</p></li><li><p>增强系统结构的规整性，减少系统结构中的各种例外情况。</p></li></ol></li></ul><p><span style="color:#5698c3">“比较简单的系统结构+软件”</span></p><hr><h2 id="3-面向操作系统的优化实现改进指令系统"><a href="#3-面向操作系统的优化实现改进指令系统" class="headerlink" title="3. 面向操作系统的优化实现改进指令系统"></a>3. 面向操作系统的优化实现改进指令系统</h2><ol><li><p>处理机<code>工作状态</code>和<code>访问方式</code>的切换。</p></li><li><p>进程的<code>管理</code>和<code>切换</code>。</p></li><li><p><u>存储管理</u>和<u>信息保护</u></p></li><li><p>进程的同步和排斥，<code>信号灯的管理等</code></p></li></ol><hr><h2 id="CISC结构存在着的缺点"><a href="#CISC结构存在着的缺点" class="headerlink" title="CISC结构存在着的缺点"></a>CISC结构存在着的缺点</h2><ol><li><p>指令出现的频率<code>相差悬殊</code>，很多指令的没办法用到</p></li><li><p>指令系统大，<code>指令条数</code>很多，指令功能复杂</p><ul><li><p>占用<u>大量芯片面积</u></p></li><li><p>增加研制时间和成本，还会造成设计错误</p></li></ul></li><li><p>由于操作繁杂，CPI的值比较大</p></li></ol><hr><h1 id="RISC指令集功能设计原则"><a href="#RISC指令集功能设计原则" class="headerlink" title="RISC指令集功能设计原则"></a>RISC指令集功能设计原则</h1><ol><li><p>指令条数少，<code>指令功能简单</code>。在确定指令系统时，<strong>只选取</strong>使用频度很高的指令，在此基础上<strong>补充一些最有用的指令</strong>(如支持操作系统和高级语言实现的指令)。</p></li><li><p>采用<code>简单而又统一</code>的指令格式，并<code>减少寻址方式</code>。指令字长都为 32 位或64 位。</p></li><li><p>指令的执行在<code>单周期内完成</code>(采用流水线技术后)。</p></li><li><p><u>采用 <em>Load-Store</em> 结构</u>。即只有 Load 和 Store 指令才能访问存储器，<u>其他指令的操作都是在寄存器之间进行的</u>。</p></li><li><p>大多数指令都采用<strong>硬连线逻辑</strong>来实现。</p></li><li><p>强调<span style="color:#5698c3">优化编译器</span>的作用，为高级语言程序生成优化的代码</p></li><li><p>充分利用<strong>流水</strong>技术来<strong>提高性能</strong>。</p></li></ol><hr><h1 id="MIPS指令分析"><a href="#MIPS指令分析" class="headerlink" title="MIPS指令分析"></a><strong>MIPS</strong>指令分析</h1><p>介绍<strong>MIPS</strong>32的一个子集，就称为<strong>MIPS</strong>指令集</p><ol><li><p>32个32位的通用寄存器（<u>GPRs</u>）</p><p> 寄存器R0的内容恒为全0</p></li><li><p>32个32位的浮点寄存器（<u>FPRs</u>）</p><p> 单精度浮点数标识和双精度浮点数表示</p></li></ol><p>💬最重要的是<strong>指令格式</strong></p><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="1-I类指令"><a href="#1-I类指令" class="headerlink" title="1. I类指令"></a>1. I类指令</h3><table><thead><tr><th align="center">op</th><th align="center">rs1</th><th align="center">rs2</th><th align="center">Imm</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">5</td><td align="center">5</td><td align="center">16</td></tr></tbody></table><p>  <strong>Load</strong> &#x2F; <strong>Store</strong></p><p>   <code>寄存器</code>-<code>立即数</code>ALU</p><p>   <code>分支指令</code></p><p>   <em>寄存器跳转 and 链接</em></p><h3 id="2-R类指令"><a href="#2-R类指令" class="headerlink" title="2. R类指令"></a>2. R类指令</h3><table><thead><tr><th align="center">op</th><th align="center">rs1</th><th align="center">rs2</th><th align="center">rd</th><th align="center">Imm</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">5</td><td align="center">5</td><td align="center">5</td><td align="center">11</td></tr></tbody></table><p>  <strong>寄存器-寄存器指令</strong></p><h3 id="3-J类指令"><a href="#3-J类指令" class="headerlink" title="3. J类指令"></a>3. J类指令</h3><table><thead><tr><th align="center">op</th><th align="center">PC的偏移量</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">26</td></tr></tbody></table><p>  <strong>跳转指令</strong></p><h2 id="MIPS效能分析"><a href="#MIPS效能分析" class="headerlink" title="MIPS效能分析"></a>MIPS效能分析</h2><p>指令格式、寻址方式、操作都很简单</p><p>$T_{CPU} &#x3D; IC \times CPI \times T_{CLK}$</p><p>$\frac{T_{CPU-MIPS}}{T_{CPU-VAX}}&#x3D;1.0~2.5 \times \frac{1}{4} * \frac{T_{CLK-MIPS}}{T_{CLK-VAX}}$</p><p><strong>所以性能会更高</strong></p><hr><p>[[CourseNotes&#x2F;计算机体系结构&#x2F;CA-第七讲 流水线技术]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="指令系统" scheme="https://molaters.github.io/tags/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CA-存储层次-1</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1-1/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1-1/</id>
    <published>2023-11-24T03:30:49.018Z</published>
    <updated>2023-11-06T03:14:28.661Z</updated>
    
    <content type="html"><![CDATA[<p>[[CA-NotesView]]<br>#存储器的层次结构<br>#Cache基本知识</p><p>局部性</p><h2 id="存储器芯片技术"><a href="#存储器芯片技术" class="headerlink" title="存储器芯片技术"></a>存储器芯片技术</h2><ol start="2"><li>DIMM (dual inline memory modules )</li></ol><p>多个DRAM芯片经常被组装在称为条的小型板上构成“双列直插式存储模块”</p><p>一个DIMM通常包含4~16片DRAM芯片，这些芯片常被组织成8字节宽的主存 (带ECC校验</p><p>3.DRAM芯片优化技术</p><blockquote><p>芯片内部优化技术是提高主存系统性能的一个重要方面</p></blockquote><p>SDRAM: Synchronous DRAM，DRAM接口增加一个时钟信号可使DRAM能针对一个请求连续同步地传输多个数据而不需同步开销</p><p>DDR (double data rate) :在DRAM时钟的上沿和下沿都进行数据传输，可把数据传输率提高一倍。</p><p>CDRAM ( Cache DRAM) :带Cache的 DRAMDRAM芯片里集成一个小的SRAM，暂存最后读出行数据。</p><h3 id="虚存和Cache关系的例子"><a href="#虚存和Cache关系的例子" class="headerlink" title="虚存和Cache关系的例子"></a>虚存和Cache关系的例子</h3><h2 id="进程保护和虚存实例"><a href="#进程保护和虚存实例" class="headerlink" title="进程保护和虚存实例"></a>进程保护和虚存实例</h2><p><strong>进程：程序呼吸所需要的空气和生存的空间</strong></p><p>进程保护</p><ol><li><p>界地址寄存器</p><p> 基地址 上界地址<br> 检测条件：（基地址+地址）&lt;&#x3D; 上界地址</p></li><li><p>虚拟存储器</p><p> 给每个页面增加访问权限标识</p></li><li><p>环形保护</p></li><li><p>加锁和隔离</p></li></ol><hr><p>本章小结</p><p>多级存储结构</p><p>性能参数</p><p>两级存储层次</p><p>Cache基本知识</p><p>性能分析</p><p>降低Cache失效率</p><p>提高相联度</p><p>调节块大小</p><p>硬件预取</p><p>编译预取</p><p>编译优化</p><p>减少失效开销</p><p>写缓冲和写合并</p><p>容量小&#x2F;结构简单Cache</p><p>请求字优先</p><p>多级Cache</p><p>非阻塞Cache</p><blockquote><p>T4,T6</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[[CA-NotesView]]&lt;br&gt;#存储器的层次结构&lt;br&gt;#Cache基本知识&lt;/p&gt;
&lt;p&gt;局部性&lt;/p&gt;
&lt;h2 id=&quot;存储器芯片技术&quot;&gt;&lt;a href=&quot;#存储器芯片技术&quot; class=&quot;headerlink&quot; title=&quot;存储器芯片技术&quot;&gt;&lt;/a&gt;存储器</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-基本的MIPS流水线（读书）</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%9F%BA%E6%9C%AC%E7%9A%84MIPS%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E8%AF%BB%E4%B9%A6%EF%BC%89/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%9F%BA%E6%9C%AC%E7%9A%84MIPS%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E8%AF%BB%E4%B9%A6%EF%BC%89/</id>
    <published>2023-11-24T03:30:49.016Z</published>
    <updated>2023-10-12T09:04:15.290Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<p>在MIPS多周期实现的基础上，将每个周期看作是流水线的时钟周期。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925090513.png"                      alt="image.png"                ></p><p>要保证在指令重叠的时候没有任何流水线资源的冲突问题，如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925090621.png"                      alt="image.png"                ></p><p><strong>流水线处理器的带宽必须是非流水实现的5倍</strong></p><p><strong>寄存器的读写都是同时发生的时候怎么办</strong>？</p><p>🤔必须要在操作段就完成PC的取指令执行，也就是IF段要在一个时钟周期时间内确定下一个PC的地址。</p><p>如何重新组织数据通路，在下一个IF段到达之前更改下一个PC的值，也就是如何处理分支指令的问题。</p><p>每个周期都要用到所有的流水段，所以每个流水段的操作必须在一个时钟周期内完成。</p><h3 id="改进前的数据通路"><a href="#改进前的数据通路" class="headerlink" title="改进前的数据通路"></a>改进前的数据通路</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925091503.png"                      alt="image.png"                ></p><h3 id="改进后的数据通路"><a href="#改进后的数据通路" class="headerlink" title="改进后的数据通路"></a>改进后的数据通路</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925091248.png"                      alt="image.png"                ></p><p>更改的部分：</p><ul><li>讲PC的选择部分更改到IF段来进行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>CA-体系结构试验1</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%95%E9%AA%8C1/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%95%E9%AA%8C1/</id>
    <published>2023-11-24T03:30:49.012Z</published>
    <updated>2023-10-12T09:04:10.643Z</updated>
    
    <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]][[CourseNotes/计算机体系结构/CA-基本的MIPS流水线（读书）]]<h1 id="1-实验一：流水线处理器-—-CA-Labs-1-0-0-文档"><a href="#1-实验一：流水线处理器-—-CA-Labs-1-0-0-文档" class="headerlink" title="1. 实验一：流水线处理器 — CA-Labs 1.0.0 文档"></a>1. 实验一：流水线处理器 — CA-Labs 1.0.0 文档</h1><p><a class="link"   href="https://hit-coa.gitlab.io/archlab/labs/lab1.html#id2" >https://hit-coa.gitlab.io/archlab/labs/lab1.html#id2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="1-1-实验目的"><a href="#1-1-实验目的" class="headerlink" title="1.1. 实验目的"></a>1.1. 实验目的</h2><ul><li>掌握 Vivado 集成开发环境</li><li>掌握 Verilog 语言</li><li>掌握 FPGA 编程方法及硬件调试手段</li><li>深刻理解流水线型处理器结构和数据冲突解决技术的工作原理</li></ul><h2 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2. 实验环境"></a>1.2. 实验环境</h2><ul><li>Vivado 集成开发环境和龙芯 Artix-7 实验平台</li></ul><h2 id="1-3-实验内容"><a href="#1-3-实验内容" class="headerlink" title="1.3. 实验内容"></a>1.3. 实验内容</h2><ul><li>根据本课程所讲的设计思想，在单周期 CPU 的基础上，设计并实现一个具有五段流水线处理器，并通过暂停和定向（或者说旁路）技术来解决流水线中出现的数据冲突，要求该处理器可以<strong>通过所提供的自动测试环境</strong>。</li></ul><h3 id="1-3-1-流水线处理器的周期划分"><a href="#1-3-1-流水线处理器的周期划分" class="headerlink" title="1.3.1. 流水线处理器的周期划分"></a>1.3.1. 流水线处理器的周期划分</h3><p>与单周期处理器不同，流水线型处理器将“工作”划分为多个流水段来完成一条指令。每个时钟周期对应于流水线的一个阶段。流水线型处理器结构的主要优点是它可以并行执行多个指令：在同一时刻，多个指令可以同时存在于流水线中不同的阶段。在本实验中，流水线划分为五个周期。每个流水段产生的结果都在相应的时钟周期时传递给下一个流水段。</p><h3 id="1-3-2-数据冲突的处理"><a href="#1-3-2-数据冲突的处理" class="headerlink" title="1.3.2. 数据冲突的处理"></a>1.3.2. 数据冲突的处理</h3><p>参照参考书（王志英等著）第3章的3.3.2小节，采用暂停和定向技术来处理流水线中出现的数据冲突。</p><h3 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h3><p>当检测到数据冲突，通过暂停来阻止即将进入流水线中的指令。本实验中，暂停只能在必要时插入流水线。</p><h3 id="定向"><a href="#定向" class="headerlink" title="定向"></a>定向</h3><p>通过增加定向控制所需要的比较器、多路选择器和相关组合逻辑电路，实现对数据的重定向，解决数据冲突。</p><h2 id="1-4-实验要求"><a href="#1-4-实验要求" class="headerlink" title="1.4. 实验要求"></a>1.4. 实验要求</h2><p>按照以上要求将前置实验中所实现的单周期处理器改进成具有五段流水线处理器，并通过暂停和定向技术解决流水线中产生的数据冲突。</p><h3 id="1-4-1-实验预习"><a href="#1-4-1-实验预习" class="headerlink" title="1.4.1. 实验预习"></a>1.4.1. 实验预习</h3><p>在实验开始前给出处理器的设计方案，设计方案要求包括：</p><ul><li>流水线处理器结构设计框图及各段的寄存器文件描述</li><li>定向控制硬件的设计框图及功能描述</li></ul><h3 id="1-4-2-完成实验内容"><a href="#1-4-2-完成实验内容" class="headerlink" title="1.4.2. 完成实验内容"></a>1.4.2. 完成实验内容</h3><p><strong>Verilog 语言实现</strong>：要求采用结构化设计方法，用 Verilog 语言实现处理器的设计。设计包括：</p><ul><li>各模块的详细设计（包括各模块功能详述，设计方法，Verilog 语言实现等）</li><li>各模块的功能测试（每个模块作为一个部分，包括测试方案、测试过程和测试波形等）</li><li>系统的详细设计（包括系统功能详述，设计方法，Verilog 语言实现等）</li><li>系统的功能测试（包括系统整体功能的测试方案、测试过程和测试波形等）</li></ul><p><strong>FPGA 编程下载</strong>：将比特流下载到 Artix-7 实验板中。然后利用 Vivado 的上板调试功能观察 Artix-7 实验板的 FPGA 芯片中的实际运行，观察处理器内部运行状态，显式输出内部状态运行结果。</p><p><strong>对处理器进行功能测试，记录运行过程和结果，完成实验报告</strong>：对处理器进行功能测试，编写处理器功能测试程序，包括指令缓冲存储器和数据缓冲存储器完成处理器功能测试，并观察记录运行过程和结果，完成实验报告。</p><h2 id="1-5-处理器测试环境"><a href="#1-5-处理器测试环境" class="headerlink" title="1.5. 处理器测试环境"></a>1.5. 处理器测试环境</h2><p>要求同学们遵守实验测试环境的相应要求，不允许修改接口，不允许修改trace文件。</p><h3 id="1-5-1-测试用例"><a href="#1-5-1-测试用例" class="headerlink" title="1.5.1. 测试用例"></a>1.5.1. 测试用例</h3><p>我们提供三个测试用例对 CPU 进行测试：</p><ul><li>基础验收指令：存在数据冲突，需要在分析指令间存在的冲突后，手动向指令缓冲存储器中存在冲突的两条指令之间增加气泡（空指令）以避免冲突。</li><li>附加验收指令1：存在数据冲突，需要使用暂停和定向等技术解决数据冲突，不允许修改指令缓冲存储器文件的内容。</li><li>附加验收指令2：存在数据冲突，需要使用暂停和定向等技术解决数据冲突，不允许修改指令缓冲存储器文件的内容。</li></ul><p>备注</p><ul><li>MIPS的<code>nop</code>编码为全0，对应我们未实现的移位指令<code>sll $0, $0, 0</code>，保证你的设计在执行这条指令时，不写寄存器，PC正常+4即可。</li><li>要求 CPU 设计能够通过全部三个用例的仿真测试。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;head&gt;
    &lt;script src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
   </summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    <category term="流水线技术" scheme="https://molaters.github.io/tags/%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CA-RW-CH4</title>
    <link href="https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH4/"/>
    <id>https://molaters.github.io/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH4/</id>
    <published>2023-11-24T03:30:49.011Z</published>
    <updated>2023-11-20T14:17:47.184Z</updated>
    
    <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><p>指令的<strong>静态和动态调度</strong> 解决<strong>控制相关</strong>技术和<strong>多指令流出</strong>等内容</p><p>指令的静态调度 包括循环级并行的处理，寄存器换名和指令调度等等。</p><p>指令的动态调度包括目前最常用的两种硬件策略：计分牌和Tomasulo算法</p><p>解决控制相关的技术，理解分支预测缓冲技术</p><p>多指令流出技术</p><hr><h2 id="指令集并行的概念"><a href="#指令集并行的概念" class="headerlink" title="指令集并行的概念"></a>指令集并行的概念</h2><p>实际的CPI &#x3D; 理想CPI  +  结构相关的停顿 + 先写后读的停顿 + 先读后写的停顿 + 写后写的停顿 + 控制相关的停顿</p><p>本章研究的技术和所克服的停顿：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119151902.png"                      alt="image.png"                ></p><h3 id="循环展开调度的基本方法"><a href="#循环展开调度的基本方法" class="headerlink" title="循环展开调度的基本方法"></a>循环展开调度的基本方法</h3><ol><li>保证正确性</li><li>保证有效性</li><li>使用不同的寄存器</li><li>尽可能地减少循环控制种地测试指令和分支指令</li><li>注意对存储器数据的相关性分析</li><li>注意新的相关性</li></ol><h3 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h3><ol><li>数据相关</li><li><strong>名相关</strong> 如果两个指令使用同名的寄存器但是之间并没有数据流，就叫做名相关；<ol><li><em>反相关</em> 知道是i先执行，j指令需要写的名字是i要读的名 <strong>先读后写相关</strong></li><li><em>输出相关</em> 输出相关的指令是不能颠倒的。 <strong>写后写相关</strong></li></ol></li><li>控制相关</li></ol><h2 id="指令的动态调度"><a href="#指令的动态调度" class="headerlink" title="指令的动态调度"></a>指令的动态调度</h2><h3 id="动态调度原理"><a href="#动态调度原理" class="headerlink" title="动态调度原理"></a>动态调度原理</h3><p>为了 <strong>乱序执行</strong>  </p><p>流出：指令译码 检查是否存在结构的阻塞</p><p>读操作数：没有数据相关引发的阻塞就读操作数</p><h3 id="记分牌"><a href="#记分牌" class="headerlink" title="记分牌"></a>记分牌</h3><p>在第二阶段的读操作数的时候，只要指令所需要的资源都满足而且没有数据阻塞就允许指令乱序执行</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119160231.png"                      alt="image.png"                ></p><p><strong>流水线指令流出和执行的步骤</strong></p><ol><li><p>流出 IS 如果本质零多需要的功能部件有空闲，并且其他的正在执行的指令使用的目的寄存器和本指令不相同，计分配就向功能部件流出这个指令，并修改记分牌内部的数据记录</p></li><li><p>读操作数 RO 记分牌检测源操作数寄存器种数据的有效性，如果前面已经流出的还在运行的指令不对这个指令的源操作数进行写操作，或者一个正在工作的功能部件已经完成了对这个寄存器的写操作，那么此操作数有效。</p></li><li><p>执行 EX</p></li><li><p>写结果 WR</p></li></ol><p>:luc_battery_charging: 注意还是要考虑到带宽</p><p><strong>记分牌记录的信息要分成三个部分</strong></p><p><em>指令状态表</em>：记录正在执行的个条指令已经进入记分牌MIPS流水段四段种的哪一段</p><p><em>功能部件状态表</em>：记录各个功能部件的状态，每个功能部件在状态表中都以剩下的9个域来记录</p><p><code>Busy</code> : 标识功能部件是不是在工作</p><p><code>Op</code> : 功能部件但钱执行的操作.</p><p><code>Fi</code> : 目的寄存器编号</p><p><code>Fj</code> <code>Fk</code> : 代表源寄存器编号</p><p><code>Qj</code> <code>Qk</code> : 代表向Rj,Rk中写结果的功能部件</p><p><code>Rj</code> <code>Rk</code> : 表示Fj  Fk是否就绪，是否已经被使用</p><p><em>结果寄存器状态表</em>：每个寄存器在表中有一个域，用于记录写入这个寄存器功能部件。</p><p>详细分析：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LD      F6,34(R2)</span><br><span class="line">LD      F2,45(R3)</span><br><span class="line">MULID   FO,F2,F4</span><br><span class="line">SUBD    F8,F6,F2</span><br><span class="line">DIVD    F10,FO,F6</span><br><span class="line">ADDD    F6,F8,F2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119163421.png"                      alt="image.png"                ></p><p>记分牌的流水线控制方式：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119171219.png"                      alt="image.png"                ></p><p><strong>记分牌的性能受限于</strong></p><ul><li><p>程序指令中可以开发的并行性，也就是是不是存在可以并行执行的不相关的指令</p></li><li><p>记分牌的容量</p></li><li><p>功能部件的数目和种类</p></li><li><p>反相关和输出相关。会引起记分牌中的先读后写和写后写阻塞</p></li></ul><p>问题2和3可以通过增加记分牌的容量和功能部件的数量来解决，这会导致处理器的成本增加，并可能影响到系统时钟周期时间。</p><h3 id="Tomasulo算法"><a href="#Tomasulo算法" class="headerlink" title="Tomasulo算法"></a>Tomasulo算法</h3><p>将记分牌的关键部分和寄存器换名技术结合在一起，这样的调度机制实现虽然有很多的变化</p><p>三个阶段 IS EX WB</p><p><strong>核心</strong>： 通过寄存器换名的方式来消除写后写和先读后写的相关而可能造成的流水线阻塞</p><p><strong>主要不同</strong>：</p><ol><li><p>指令流出的逻辑和保留站相结合实现寄存器换名，完全消除了数据写后写和先读后写相关这一类的名相关</p></li><li><p>冲突检测和指令执行控制机制分开</p></li><li><p>计算的结果通过相关专用通路直接从功能部件进入对应的保留站进行缓冲，而不一定是写到寄存器</p></li></ol><p><strong>Tomasulo 保留站结构</strong></p><p><code>Op</code> 部件所进行的操作</p><p><code>Vj</code> <code>Vk</code> : 源操作数的值。Store缓冲区有Vk区域，用于存放要写入存储器的值。V域和Q域不同时有效</p><p><code>A</code> : 存放存储器地址开始存立即数，计算出有效的地址之后，存放有效地址</p><p><code>Busy</code>: 标识保留站Rs或者响应的功能部件FU是否空闲</p><p><em>Register result status</em>  如果存在在对寄存器的写操作，指示对这个寄存器进行写操作的部件</p><p><code>Qi</code> : 保留站的编号</p><p><strong>Tomasulo 算法实现消除阻塞的方法</strong></p><ol><li><p>产生DIVD指令操作数F6的指令(第一个LD)一旦执行完，DIVD指令对应保留站的Vk区域就保存这个结果，这样DIVD和ADDD之间就不再有冠以F6的限度后写相关，ADDD指令就可以执行下去</p></li><li><p>如果第一个LD指令还没有执行完毕，DIVD指令所在的MULT2保留站的Qk域将指向第一条LD指令的保留站LOAD1，从而允许ADDD指令执行并将结果存入结果寄存器而不影响DIVD的执行</p></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LD      F6,34(R2)</span><br><span class="line">LD      F2,45(R3)</span><br><span class="line">MULID   FO,F2,F4</span><br><span class="line">SUBD    F8,F6,F2</span><br><span class="line">DIVD    F10,FO,F6</span><br><span class="line">ADDD    F6,F8,F2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119193739.png"                      alt="image.png"                ></p><p><strong>Tomasulo 在每个阶段的动作</strong></p><p><strong>IS阶段</strong><br>对于浮点操作，进入条件： <em>有保留空间站r</em></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201115.png"                      alt="image.png"                ></p><p>经历的阶段是：</p><ol><li><p>如果没有就绪就执行换名操作然后进入等待</p></li><li><p>如果数据已经又笑了，就将数据传送给V寄存器，然后标识其有效</p></li><li><p>设置保留站繁忙且设置操作类型和目标寄存器</p></li></ol><p>对于存&#x2F;取操作，进入条件：<em>有空闲缓冲r</em></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201131.png"                      alt="image.png"                ></p><p>这一部分是统一测操作</p><p>取操作不同处:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201335.png"                      alt="image.png"                ></p><p>存操作不同处:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201358.png"                      alt="image.png"                ></p><hr><p><strong>EX阶段</strong></p><p>对于浮点操作，进入的条件是：</p><p><em>两个源操作数都就绪</em></p><p>取和存第一步的进入条件是</p><p><em>第一个操作数就绪并且r到达了缓冲队列的头部</em></p><hr><p><strong>基于Tomasulo算法的动态循环展开</strong></p><p><em>一旦有一条指令没有执行完，其后的指令不允许进入执行段</em></p><p>第一次取数LD，由于Cache miss需要8个时钟周期延迟，之后的取数LD，只需要1个时钟周期，<em>存数需要3个时钟周期</em></p><p><em>乘法需要4个时钟周期</em></p><p>现在假设连续两遍的循环的所有指令全部流出，但是所有的浮点存&#x2F;取和运算的操作全部没有完成。给出状态表的信息。</p><p><strong>优点</strong></p><ul><li>分布式件冲突检测。</li><li>利用寄存器换名，彻底消除WAW和WAR这两种名相关</li><li>如果多个保留站等待同一个操作数，当操作数在CDB上广播时，他们可以同时获得所害的数据</li><li>对于存储器访问，动态存储器地址判别技术可解决RAW冲突(取操作数时判断)、WAR和WAW冲突(存操作数的时候判断)</li><li>能够达到很高的性能</li></ul><h2 id="控制相关的动态解决技术"><a href="#控制相关的动态解决技术" class="headerlink" title="控制相关的动态解决技术"></a>控制相关的动态解决技术</h2><h3 id="分支预测缓冲"><a href="#分支预测缓冲" class="headerlink" title="分支预测缓冲"></a>分支预测缓冲</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[[CA-NotesView]]&lt;/p&gt;
&lt;p&gt;指令的&lt;strong&gt;静态和动态调度&lt;/strong&gt; 解决&lt;strong&gt;控制相关&lt;/strong&gt;技术和&lt;strong&gt;多指令流出&lt;/strong&gt;等内容&lt;/p&gt;
&lt;p&gt;指令的静态调度 包括循环级并行的处理，寄存器换名和指</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="计算机体系结构" scheme="https://molaters.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
