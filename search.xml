<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CN-随机访问MAC协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="多路访问控制-MAC-协议"><a href="#多路访问控制-MAC-协议" class="headerlink" title="多路访问控制(MAC)协议"></a>多路访问控制(MAC)协议</h2><p>两类的链路：</p><ul><li>点对点链路：<ol><li>拨号接入的PPP</li><li>以太网交换机和主机之间的点对点链路</li></ol></li><li>广播链路（共享介质）<ol><li>早期的总线以太网</li><li>HFC的上行链路</li><li>802.11无线局域网</li></ol></li></ul><p>单一共享广播信道</p><p>两个或者两个以上的结点同时传输：干扰(interface)</p><p><strong>冲突</strong></p><p>结点同时接收到两个或者多个信号 $\to$ 接收失败！</p><h3 id="多路访问控制协议"><a href="#多路访问控制协议" class="headerlink" title="多路访问控制协议"></a>多路访问控制协议</h3><p>采用分布式算法决定结点怎么共享信道，也就是决策结点什么时候可以传输数据</p><p>必须基于信道本身，通信信道共享协调信息！</p><h2 id="理想的MAC协议"><a href="#理想的MAC协议" class="headerlink" title="理想的MAC协议"></a>理想的MAC协议</h2><p><strong>给定</strong>：速率为Rbos的广播信道</p><p><strong>期望</strong>：</p><ol><li>如果只有一个结点：R</li><li>M个结点发送：R&#x2F;M</li><li>完全分散控制：<ol><li>不用特定协调</li><li>不用时钟，时隙同步</li></ol></li><li>简单</li></ol><h2 id="MAC协议的分类"><a href="#MAC协议的分类" class="headerlink" title="MAC协议的分类"></a>MAC协议的分类</h2><p>三大类：</p><h3 id="信道划分MAC协议"><a href="#信道划分MAC协议" class="headerlink" title="信道划分MAC协议"></a>信道划分MAC协议</h3><p>多路复用技术</p><p>TDMA、FDMA、CDMA、WDMA等</p><h3 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h3><p>信道不划分，允许冲突</p><p>冲突的恢复机制</p><h3 id="轮转协议"><a href="#轮转协议" class="headerlink" title="轮转协议"></a>轮转协议</h3><p>结点轮流使用信道</p><h2 id="信道划分MAC协议：TDMA、FDMA"><a href="#信道划分MAC协议：TDMA、FDMA" class="headerlink" title="信道划分MAC协议：TDMA、FDMA"></a>信道划分MAC协议：TDMA、FDMA</h2><p>time division multiple access</p><p>周期性的使用信道</p><p>每个站点在每个周期占用固定长度的时隙</p><p>未用的时隙空间</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101192728.png" alt="image.png"></p><p>同理：FDMA (frequency division multiple access)</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101192815.png" alt="image.png"></p><p>网络资源</p><h2 id="随机访问MAC协议-1"><a href="#随机访问MAC协议-1" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h2><p>当结点要发送分组的时候：</p><ul><li>利用信道全部数据速率R发送分组</li><li>没有实现的结点协调</li></ul><p>两个或者多个结点同时传输 ： 冲突</p><p><strong>随机访问MAC协议</strong>需要定义：</p><ul><li><p>如何检测冲突</p></li><li><p>如何从冲突中恢复（延迟重传）</p></li></ul><p>典型的随机访问MAC协议：</p><p>ALOHA CSMA&#x2F;CA 等</p><h2 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h2><p><strong>假定</strong>：</p><p>所有帧的大小相同<br>时间被划分为等长度的时隙<br>结点只能在时隙的开始时刻发送帧<br>结点之间时钟同步<br>如果两个或者两个以上的结点在同一个时隙发送帧，节点就检测到冲突</p><p><strong>运行</strong>：</p><p>当结点有新的帧的时候，在下一个时隙(slot)发送<br><u>如果冲突</u> 以概率p重传这个帧</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101193527.png" alt="image.png"></p><p><strong>优点</strong>:<br>单个结点活动时，可以连续以信道全部速率传输数据<br>高度分散化: 只需同步时隙<br>简单</p><p><strong>缺点</strong>:<br>冲突，浪费时隙<br>空闲时隙<br>结点也许能以远小于分组传输时间检测到冲突</p><p><strong>效率</strong>：成功发送帧的时隙占的比例</p><p>假设：N个结点有很多的帧需要传输，每个结点在每个时隙均以概率p发送数据</p><p><strong>效率</strong>：最大的效率为0.37</p><h3 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h3><p>更简单，不用时钟同步</p><p>当有新的数据帧构成的时候立刻发送数据帧</p><ul><li>立即发送</li></ul><p>冲突的可能性增大</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101194041.png" alt="image.png"></p><p>比时隙ALOHA协议更差，效率为0.18</p><h2 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h2><p>载波监听多路访问协议</p><p>发送帧之前，监听信道(载波)：</p><ul><li><p>信道空闲：发送完整帧</p></li><li><p>信道忙：推迟发送</p><ul><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>P-坚持CSMA</li></ul></li></ul><p><strong>冲突可能仍然发生</strong>：信号传播延迟</p><p>继续发送冲突帧：浪费信道资源</p><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h2><p>带有冲突检测的载波多路访问协议</p><p>短时间内内可以检测到冲突</p><p>冲突之后传输中止，减少信道的浪费</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101195328.png" alt="image.png"></p><p>冲突检测：</p><ul><li>有线局域网易于实现：测量信号强度，比较发送信号和接收信号</li><li>无线局域网很难实现：接收信号强度淹没在本地发射信号强度下</li></ul><p>“边发边听，不发不听”</p><h2 id="CSMA-CD协议-1"><a href="#CSMA-CD协议-1" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101200020.png" alt="image.png"></p><p>在一个采用CSMA&#x2F;CD协议的网络中，传输介质是一根完整的电缆，传输速率为1 Gbps，电缆中的信号传播速度是200 000 km&#x2F;s。若最小数据帧长度减少800比特，则最远的两个站点之间的距离至少需要减少</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101200343.png" alt="image.png"></p><p>$T_{prop} &#x3D; LAN中两个结点之间的最大传播延迟$</p><p>$t_{trans} &#x3D; 最长帧传输延迟$</p><p>$效率 &#x3D; \frac{1}{1+5 t_{prop}&#x2F;t_{trans}}$</p><p>远优于ALOHA并且简单分散</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-链路状态路由算法</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>链路状态路由算法</p><h2 id="网络抽象：图"><a href="#网络抽象：图" class="headerlink" title="网络抽象：图"></a>网络抽象：图</h2><p>图： G &#x3D; （N，E）</p><h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><p><em><strong>Dijstra算法</strong></em></p><p>所有节点（路由器）掌握网络拓扑和链路费用</p><p>要求每一个路由器都构造一个链路状态分组，并广播出去</p><ul><li>通过“链路状态广播”</li></ul><p>链路状态路由算法里面利用扩散或者泛洪的方法来进行发送</p><p>任何一个路由器都会收集全了所有路由器的链路状态分组</p><ul><li>所有节点拥有相同信息</li></ul><p>计算从一个节点（“源”）到达所有其他节点的最短路径</p><ul><li>获得该节点的传发表</li></ul><p>迭代：k次迭代之后，得到到达k个目的节点的最短路径</p><p><em><strong>符号</strong></em></p><p>c(x,y):结点x到结点y链路费用；如果x和y不直接相连，则为无穷大</p><p>D(v): 从源到目的v的当前路径费用值</p><p>p(v): 沿从源到v的当前路径，v的前序节点</p><p>N‘ ：已经找到费用最小路径的结点集合</p><p>Dijstra 算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化</span><br><span class="line">N’ = &#123;u&#125;</span><br><span class="line">for 所有结点</span><br><span class="line">if v和u相邻</span><br><span class="line">then D(v) = c(u,v)</span><br><span class="line">else D(v) = 无穷</span><br><span class="line"></span><br><span class="line">Loop </span><br><span class="line">找出不再N’中的w，满足D（w）最小</span><br><span class="line">将w加入N‘</span><br><span class="line">更新w的所有不在N’中的邻居v的D（v）:</span><br><span class="line">D(v) = min(D(v),D(w) + c(w,v))</span><br><span class="line">//已知的到达w的最短路径费用加上w到v的费用</span><br><span class="line">until 所有的结点都在N‘中了</span><br></pre></td></tr></table></figure><p>u 的最终最短路径树：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022143149.png" alt="image.png"></p><p>u 的最终转发表：</p><p>根据上面的内容进行计算最终转发表</p><h2 id="Dijstra-算法"><a href="#Dijstra-算法" class="headerlink" title="Dijstra 算法"></a>Dijstra 算法</h2><p>算法复杂性： O($n^2$)</p><p>每一次迭代：需要检测所有不在结合N’中的结点<br>n(n+1)&#x2F;2次的比较：O($n^2$)<br>更高效的实现：O(nlogn)</p><p>存在震荡的可能：<br>假设链路费用是该链路承载的通信量</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022143800.png" alt="image.png"></p><p>很有可能导致数据包在DCB之间反复震荡无法传送到A，最终会因为TTL被丢弃。</p><p>所以会使用一些机制来避免这样的情况</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-轮转访问MAC协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%BD%AE%E8%BD%AC%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%BD%AE%E8%BD%AC%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>信道划分MAC协议：</p><ul><li><p>网络负载重的时候，共享信道的效率高，而且公平</p></li><li><p>网络负载轻的时候，信道的效率低！</p></li></ul><p>随机访问MAC协议：</p><ul><li><p>网络负载重的时候产生冲突开销</p></li><li><p>网络负载轻的时候，产生冲突开销</p></li></ul><p>轮转访问MAC协议：</p><ul><li>综合两者的优点！</li></ul><h2 id="轮询-polling"><a href="#轮询-polling" class="headerlink" title="轮询(polling)"></a>轮询(polling)</h2><p>主节点轮流的“邀请”从属结点发送数据</p><p>典型应用：“哑”从属设备</p><p>问题：</p><ul><li>轮询开销</li><li>等待延迟</li><li>单点故障</li></ul><h2 id="令牌传递"><a href="#令牌传递" class="headerlink" title="令牌传递"></a>令牌传递</h2><p>控制令牌依次从一个结点传递到下一个结点</p><p>令牌：<strong>特殊帧</strong></p><p>令牌网络会构成环形网络</p><p>问题：</p><ul><li><p>令牌的开销</p></li><li><p>等待延迟</p></li><li><p>单点故障问题</p></li></ul><h2 id="MAC协议总结"><a href="#MAC协议总结" class="headerlink" title="MAC协议总结"></a>MAC协议总结</h2><p>信道划分MAC协议：TDMA、FDMA、CDMA<br>随机访问MAC协议：ALOHA,S-ALOHA，CSMA&#x2F;CD,CSMA&#x2F;CA<br>轮转访问MAC协议：<br>主结点轮询：令牌传递<br>蓝牙&#x2F;FDDI</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-路由器的工作原理</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>网络层的<strong>转发功能</strong></p><p>简要的转发问题：编址和&#x3D;&#x3D;最长前缀匹配问题&#x3D;&#x3D;</p><p>关键术语： 转发、交换</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231012120717.png" alt="image.png" style="zoom:67%;" />转发功能通常称为**路由器转发平面**<p>数据报流水线必须以N倍速率运行</p><p><strong>路由器控制平面</strong>通常用软件实现并在路由选择处理器上执行</p><p>最重要的路由器部件：入口路和入口站 $\to$ 输入端口</p><p>环形交叉路 $\to$ 交换结构</p><p>环状交叉路出口 $\to$ 输出端口</p><p>Q：</p><ol><li>车站服务人员很慢会发生什么情况？（查询速度慢）</li><li>服务人员必须要多快才能确保在入口路上没有车辆拥堵？（查询速度的最低值）</li><li>对于极快的服务人员，如果汽车在环状交叉路上开的很慢将会发生什么情况？（交换结构内数据传输慢）</li><li>如果大多数进入的汽车都要在相同的出口离开会发生什么情况？（拥塞控制）</li><li>如果要为不同的汽车分配优先权，或者阻挡某些汽车进入环状交叉路，应该怎么运行？（如何让数据报有控制的进行转发）</li></ol><h2 id="路由器的输入端口"><a href="#路由器的输入端口" class="headerlink" title="路由器的输入端口"></a>路由器的输入端口</h2><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231012123351.png" alt="image.png" style="zoom: 80%;" />查找 **根据转发表**<p>TCAM <strong>三态内容可寻址存储器</strong></p><p>确定了输出端口之后分组就能够发送进入交换结构。如果正在使用交换结构就会被阻塞。因此需要在输入端口的位置排队。</p><p>必须采取的动作：</p><ol><li>物理层和链路层处理</li><li>检查分组的版本号、检验和</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-路由和转发</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%92%8C%E8%BD%AC%E5%8F%91/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%92%8C%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h2><p>路由算法（协议）确定去往目的网络的最佳路径</p><p>转发表确定在本路由器如何转发分组</p><h2 id="网络抽象：图"><a href="#网络抽象：图" class="headerlink" title="网络抽象：图"></a>网络抽象：图</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022135040.png" alt="image.png"></p><p>图：G &#x3D; （N,E）<br>N &#x3D; 路由器集合 &#x3D; {u,v,w,x,y,z}<br>E &#x3D; 链路集合 &#x3D; {(u,v),(u,x)}</p><p>图的抽象在网络领域很广泛</p><p>N是peers集合，E是TCP的集合</p><h2 id="图抽象：费用（Costs）"><a href="#图抽象：费用（Costs）" class="headerlink" title="图抽象：费用（Costs）"></a>图抽象：费用（Costs）</h2><p>c(x,x’)链路(x,x’)的费用</p><p>e.g c(w,z) &#x3D; 5</p><p>每段链路的费用可以总是1，描述一个链路或者路径的大小的时候称为段数；或者是，带宽的倒数、拥塞程度等。</p><p>路径费用：(x1,x2,x3,,,xp) &#x3D; c(x1,x2) + c(x2,x3) + … + c(xp-1,xp)</p><blockquote><p>[!关键问题]<br>源到目的的最小费用的路径是什么？</p></blockquote><p><strong>路由算法</strong>：在网络的抽象图中寻找最小路径的算法</p><h2 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h2><h3 id="静态路由-vs-动态路由？"><a href="#静态路由-vs-动态路由？" class="headerlink" title="静态路由 vs 动态路由？"></a>静态路由 vs 动态路由？</h3><p>静态路由：</p><ul><li><p>手工配置</p></li><li><p>路由更新的速度慢</p></li><li><p>优先级高（<strong>在路由信息中同等条件下首选</strong>）</p></li></ul><p>动态路由：</p><ul><li><p>路由更新快</p><ul><li><p>定期更新</p></li><li><p>及时响应链路费用或者网络拓扑变化</p></li></ul></li></ul><h3 id="全局信息-vs-分散信息？"><a href="#全局信息-vs-分散信息？" class="headerlink" title="全局信息 vs 分散信息？"></a>全局信息 vs 分散信息？</h3><p>全局信息：所有路由器掌握完整的网络拓扑和链路费用信息</p><p>e.g. 链路状态(LS)路由算法</p><p>分散信息（decentralized）:</p><p>路由器只掌握物理项链的邻居以及链路费用</p><p>链路之间信息交换、运算的迭代过程</p><p>e.g. 距离向量9(DV)路由算法</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-距离向量路由算法</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="距离向量-Distance-Vector-路由算法"><a href="#距离向量-Distance-Vector-路由算法" class="headerlink" title="距离向量(Distance Vector)路由算法"></a>距离向量(Distance Vector)路由算法</h2><p>Bellman-Ford方程(动态规划)</p><p>令：dx(y):从x到y最短路径的费用(距离)</p><p>dx(y) &#x3D; min {c(x,y) + dv(y)}</p><p><code>c(x,y)</code> 代表的是x到邻居v的费用</p><p><code>dv(y)</code> 代表从邻居v到达目的y的费用（距离）</p><p>在x的所有邻居v中取最小值</p><h2 id="Bellman-Ford举例"><a href="#Bellman-Ford举例" class="headerlink" title="Bellman-Ford举例"></a>Bellman-Ford举例</h2><p><strong>重点</strong>结点获得最短路径的下一跳，该信息用于转发表中。</p><h2 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h2><p>$D_x(y)$ &#x3D; 从节点x到结点y的最小费用估计</p><ul><li>维护距离向量（DV) : $D_x &#x3D; [D_x(y): y \in N]$</li></ul><p>结点x：</p><ul><li>已知到达每个邻居的费用：c(x,y)</li><li>维护其所有邻居的距离向量: $D_v$ &#x3D; $D_v(y) : y \in N$</li></ul><p>核心思想：</p><ul><li>每个结点不定时的将其自身的DV估计发送给其邻居</li><li>x当收到另据的新的DV估计的时候，根据B-F方程来更新自身的距离向量估计</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022144901.png" alt="image.png"></p><p>将最终收敛于实际的最小费用</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h3><p>引发每次局部迭代的因素</p><ul><li>局部链路费用改变</li><li>来自邻居的DV更新</li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>每个结点只当DV变化的时候才通告给邻居</p><p>邻居在必要的时候（其DV更新后发生改变）</p><ul><li>邻居在必要的时候(其DV更新后发生改变)再通告它们的邻居</li></ul><h3 id="每个节点："><a href="#每个节点：" class="headerlink" title="每个节点："></a>每个节点：</h3><p><strong>等待</strong>本地局部链路费用变化或者收到邻居的DV的更新</p><p><strong>重新计算</strong>DV估计</p><p>如果DV中到达任一目的的距离发生改变，<strong>通告</strong>所有邻居</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022145726.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-距离向量链路算法2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%952/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%952/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>Bellman-Ford方程（动态规划）</p><p>令：</p><p>$d_x(y) &#x3D; min_distance(x \to y) &#x3D; min{c(x,v) + d_v(y)}$</p><p><code>c(x,v)</code> 代表的是x到v的费用</p><p><code>$dv(y)$</code> 从邻居v到目的y的费用</p><h2 id="Bellman-Ford举例"><a href="#Bellman-Ford举例" class="headerlink" title="Bellman-Ford举例"></a>Bellman-Ford举例</h2><p>显然：$d_v(z) &#x3D; 5,\ \ \ d_x &#x3D; 3,\ \ \ d_w(z)&#x3D;3$</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029203659.png" alt="image.png"></p><p>根据B-F方程：</p><p>$d_u(z) &#x3D; min {c(u,v) + d_v(z), \ \ c(u,x) + d_x(z), \ \ c(u,w) + d_w (z)} \ &#x3D; min{\ 2+5,\ 1+3,\ 5+3} &#x3D; 4$</p><p>重点: 结点获得最短路径的下一跳,该信息用于转发表中</p><h2 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h2><p>$D_x(y) &#x3D;$ 从结点x到结点y的最小费用估计</p><ul><li>x 维护距离向量(DV) ： $D_x &#x3D; [D_x(y): y \in N]$</li></ul><p>结点x:</p><ul><li>已知到达每个邻居的费用: c(x,y)</li><li>维护其所有邻居的距离向量：$D_v &#x3D; [D_v(y): y \in N]$</li></ul><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>每个结点不定时的把其自身的DV估计发送给其邻居</p><p>当接收到邻居的新的DV估计的时候，也就是根据B-F更新其自身的路由向量估计：</p><p>$D_x(y) \leftarrow min{c(x,y) \ + \ D_v(y)} \ for \ each \ node\  y \in N$</p><p>最后$D_x(y)$将会收敛到最小值。</p><h3 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h3><p>引发每次局部迭代的因素</p><ul><li>局部链路费用改变</li><li>来自邻居的DV更新</li></ul><h3 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h3><p>每个结点只有当DV变化的时候才通告邻居</p><ul><li>邻居在必要的时候再通告它们的邻居</li></ul><h3 id="每个节点的阶段："><a href="#每个节点的阶段：" class="headerlink" title="每个节点的阶段："></a>每个节点的阶段：</h3><p><strong>等待</strong>：每个路由器在没有发生变化的时候就保持这种状态（邻居DV没有发生更新）</p><p><strong>重新计算</strong> DV估计</p><p>如果DV中到达任一一个目的距离发生改变，<strong>通告</strong>所有的邻居</p><p>然后再次进入<strong>等待</strong>状态</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>初始的距离向量为：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029205246.png" alt="image.png"></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029205707.png" alt="image.png"></p><h2 id="距离向量DV：链路费用变化"><a href="#距离向量DV：链路费用变化" class="headerlink" title="距离向量DV：链路费用变化"></a>距离向量DV：链路费用变化</h2><p><strong>链路费用的变化</strong>：</p><ul><li><p>结点检测本地链路费用的变化</p></li><li><p>更新路由信息，重新计算距离向量</p></li><li><p>如果DV改变，通告所有的邻居</p></li></ul><p>$t_0$ : y检测到链路费用的改变，更新DV，通告其邻居</p><p>$t_1$ : z收到y的DV更新，更新其距离向量表，计算到达x的最新最小费用，更新其DV，并发送其所有的邻居。</p><p>$t_2$ ：y收到z的DV更新，更新其距离向量表，重新计算y的DV，未发生改变，不再像z发送DV</p><p>“<strong>好消息传播的快</strong>”</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029214707.png" alt="image.png"></p><p>但是可能出现无穷计数问题（如上所示）</p><h3 id="毒性逆转"><a href="#毒性逆转" class="headerlink" title="毒性逆转"></a>毒性逆转</h3><p>如果一个结点(e.g.z)到达某目的(e.g.X)的最小费用路径是通过某个邻居(e.g.Y)，则:</p><ul><li>通告给该邻居结点到达该目的的距离为无穷大</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/d94597c651cb7c7656f0260d56b858d.jpg" alt="d94597c651cb7c7656f0260d56b858d.jpg"></p><p>毒性逆转是不是能够彻底的消除无穷计数问题？</p><p>简单的环路是可以消除的，更复杂的环境其实未必可以满足。</p><p><strong>定义最大的一个距离度量值(maximum metric)</strong></p><p>定义一个最大的有效费用值，比如15跳步，16跳步标识无穷</p><p>如果一直不可达，就会在有效费用值耗尽的时候结束传输</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-计算机网络分层结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>在计算机网络体系结构的各个层次里面，每个报文都分为两个部分：一是数据部分，SDU； 二是控制信息部分，即PCI；它们共同构成<code>PDU</code></p><p>数据服务单元（SDU）：为完成用户所要求的功能二应该传送的数据<br>协议控制单元（PCI）：控制协议操作的信息，第n层的协议控制信息记为n-PCI<br>协议数据单元（PDU）：对等层次之间传送的数据单位就是PDU。</p><p>物理层的PDU是<em>比特</em>，数据链路层的PDU是<em>帧</em>，网络层的PDU称为<em>分组</em>，传输层的PDU称为<em>报文段</em></p><h3 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h3><p>为进行网络中的数据交换而建立的规则、标准或者约定就成为<em>网络协议</em></p><p>同一结点内相邻两层之间的交换信息的连接点叫做<em>接口</em></p><p>SAP（服务访问点）是一个逻辑接口而不是物理接口</p><p><em>服务</em>是指下层为紧邻的上层提供的功能调用，它是垂直的。</p><p>协议和服务的概念是不一样的，协议的实现保证了服务，上层通过调用下层的服务构造协议。</p><p>并非在一层内完成的全部功能都称为服务，只有那些看得见的功能才能叫做服务。</p><p>提供的服务可以分为三类：</p><ol><li>面向连接服务和无连接服务<ol><li><strong>面向连接服务</strong>：必须先建立连接，分配相应的资源，传输结束之后会释放连接和所占用的资源。</li><li><strong>无连接服务</strong>：不需要先建立连接，发送数据的时候可以直接发送。</li></ol></li><li>可靠服务和不可靠服务<ol><li><strong>可靠服务</strong>：指的是网络具有纠错、检错、应答机制，能够保证数据正确、可靠的传送到目的地</li><li><strong>不可靠服务</strong>：尽量准确的可靠的传输，但是不能保证数据正确，是一种尽力而为的服务。</li></ol></li><li>有应答服务和无应答服务<ol><li><strong>有应答服务</strong>：接收方在收到数据后向发送方给出的应答</li><li><strong>无应答服务</strong>：指的是接收方收到数据之后不自动给出应答，如果要应答就用高层实现。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-计算机网络传输层</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 计算机网络传输层<h2 id="传输层服务概述"><a href="#传输层服务概述" class="headerlink" title="传输层服务概述"></a>传输层服务概述</h2><h3 id="传输层服务和协议"><a href="#传输层服务和协议" class="headerlink" title="传输层服务和协议"></a>传输层服务和协议</h3><p>传输层协议为运行在不同的host上的进程提供了一种<strong>逻辑通信机制</strong></p><p>端系统运行传输层协议</p><ul><li><p><strong>发送方</strong>：将应用递交的消息分成一个或者多个的Segment,并向下传递给网络层</p></li><li><p><strong>接收方</strong>：将接收到的Segment组装成消息，并上交给应用层</p></li></ul><p>传输层可以为应用提供<em><strong>多种协议</strong></em></p><ul><li><p>Internet上的TCP</p></li><li><p>Internet上的UDP</p></li></ul><h3 id="传输层-vs-网络层"><a href="#传输层-vs-网络层" class="headerlink" title="传输层 vs 网络层"></a>传输层 vs 网络层</h3><p><strong>网络层</strong>： 提供主机之间的逻辑通信机制</p><p><strong>传输层</strong>：提供应用进程之间的逻辑通信机制</p><ul><li><p>位于网络层之上</p></li><li><p>依赖于网络服务</p></li><li><p>对网络层服务进行（可能的）增强</p></li></ul><p><u>家庭类比</u></p><ul><li>12个孩子给12个孩子写信</li><li>应用进程 &#x3D; 孩子</li><li>应用消息 &#x3D; 信封里面的信</li><li>主机 &#x3D; 房子</li><li>传输层协议 &#x3D; 李雷和韩梅梅</li><li>网络层协议 &#x3D; 邮政服务</li></ul><h3 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h3><ul><li><p><code>可靠</code>、<code>按序</code>的交付服务(TCP)</p><ul><li>拥塞控制</li><li>流量控制</li><li>连接建立</li></ul></li><li><p><code>不可靠的</code>交付服务(UDP)</p><ul><li>基于 <em>“尽力而为(Best-effort)”</em> 的网路，没有做可靠性方面的拓展</li></ul></li><li><p>两种服务均不保证</p><ul><li>延迟</li><li>带宽</li></ul></li></ul><hr><h2 id="多路复用和多路分用"><a href="#多路复用和多路分用" class="headerlink" title="多路复用和多路分用"></a>多路复用和多路分用</h2><p>Why? $\rightarrow$ 如果<strong>某层的一个协议对应直接上层的多个协议&#x2F;实体</strong>，那么就需要<code>复用/分用</code></p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694605856597.png" alt="1694605856597" style="zoom:67%;" /><p><u>接收端进行多路分用</u></p><p>传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程</p><p><u>发送端进行多路复用</u></p><p>从多个Socket接受数据，为每块数据封装上头部信息，交给网络层</p><h3 id="分用如何工作"><a href="#分用如何工作" class="headerlink" title="分用如何工作"></a>分用如何工作</h3><ul><li><p>主机接收到<code>IP数据报（datagram）</code></p><ul><li><p>每个数据报携带<code>源IP地址</code>、<code>目的IP地址</code></p></li><li><p>每个数据报携带一个<u>传输层的端</u>（Segment）</p></li><li><p>每个段携带<code>源端口号</code>和<code>目的端口号</code></p></li></ul></li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694607845406.png" alt="1694607845406" style="zoom:67%;" /></p><ul><li>主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket</li></ul><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694606950930.png" alt="1694606950930" style="zoom:67%;" /><h3 id="无连接分用"><a href="#无连接分用" class="headerlink" title="无连接分用"></a>无连接分用</h3><ul><li><input checked="" disabled="" type="checkbox"> 利用端口号创建Socket  [completion:: 2023-09-26]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket mySocket1 = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">99111</span>);</span><br><span class="line">DatagramSocket mySocket2 = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">99222</span>);</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> UDP的Socket用二元组标识<ul><li>UDP的Socket用二元组标识</li></ul></li></ul><p>主机收到UDP段之后</p><ul><li><p>检查段中的目的端口号</p></li><li><p>将UDP段导向绑定在该端口号的Socket</p></li></ul><p>来自不同源IP地址和&#x2F;或源端口号的IP数据包被导向同一个<code>Socket</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket serverSocket = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">6428</span>);</span><br></pre></td></tr></table></figure><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694607649470.png" alt="1694607649470" style="zoom:67%;" /><p><strong>SP</strong>提供<code>返回地址</code></p><h3 id="面向连接的分用"><a href="#面向连接的分用" class="headerlink" title="面向连接的分用"></a>面向连接的分用</h3><p> <code>TCP</code>的Socket用四元组标识<br>    - 源IP地址<br>    - 源端口号<br>    - 目的IP地址<br>    - 目的端口号</p><p> 接收端利用所有的四个值将Segment导向合适的Socket</p><p> 服务器可能同时支持多个TCPSocket<br>    - 每个人Socket用自己的四元组标识</p><p><strong>Web服务器</strong>为每个客户端开不同的<code>Socket</code></p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694609096055.png" alt="1694609096055" style="zoom:67%;" /><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694609108885.png" alt="1694609108885" style="zoom:67%;" /><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP-User-Datagram-Protocol-RFC-768"><a href="#UDP-User-Datagram-Protocol-RFC-768" class="headerlink" title="UDP :User Datagram Protocol [RFC 768]"></a>UDP :User Datagram Protocol [RFC 768]</h3><ul><li><p>基于Internet IP协议</p><ul><li><p>复用&#x2F;分用</p></li><li><p>简单的错误校验</p></li></ul></li><li><p>“Best effort”服务，UDP段可能</p><ul><li><p><strong>丢失</strong></p></li><li><p><strong>非按序到达</strong></p></li></ul></li><li><p><code>无连接</code></p><ul><li><p>UDP发送方和接收方之间不需要握手</p></li><li><p>每个UDP段的处理独立于其他段</p></li></ul></li><li><p>常用于<strong>流媒体应用</strong></p><ul><li><p>容忍丢失</p></li><li><p>速率敏感</p></li></ul></li><li><p>UDP还用于</p><ul><li><p>DNS</p></li><li><p>SNMP</p></li></ul></li><li><p>在UDP上实现<code>可靠数据传输</code></p><ul><li><p>在应用层增加可靠性机制</p></li><li><p>应用特定的错误恢复机制</p></li></ul></li></ul><h3 id="UDP检验和-Checksum"><a href="#UDP检验和-Checksum" class="headerlink" title="UDP检验和(Checksum)"></a>UDP检验和(Checksum)</h3><p>目的:<strong>检测UDP段是否发生错误,比如位翻转</strong></p><ul><li><p><strong>发送方</strong></p><ul><li><p>将段的内容视为16-bit整数</p></li><li><p><strong>检验和计算</strong>:计算所有整数的和,进位加在和的后面,将得到得知安慰囚犯,得到校验和</p></li><li><p>发送方将校验和放入校验和字段</p></li></ul></li><li><p><strong>接收方</strong></p><ul><li>计算所受到段的校验和</li><li>将其与校验和字段进行对比<ul><li>不相等:<strong>检测出错误</strong></li><li>相等:<strong>没有检测出错误</strong></li></ul></li></ul></li></ul><h3 id="校验和计算实例"><a href="#校验和计算实例" class="headerlink" title="校验和计算实例"></a>校验和计算实例</h3><p>注意: <strong>最高位必须被加进去</strong></p><p>示例:</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694611617018.png" alt="1694611617018" style="zoom:67%;" /><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>❓什么是可靠<br>    - 不错,不乱,不丢</p><p><strong>可靠数据传输协议</strong></p><ul><li>可靠数据传输对应用层&#x2F;传输层&#x2F;链路层都很重要</li><li>网络的Top10问题</li><li>信道的不可靠特性决定了可靠数据传输协议(rdt)的复杂性</li></ul><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612237418.png" alt="1694612237418" style="zoom: 80%;" /><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612260649.png" alt="1694612260649" style="zoom: 80%;" /><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612273475.png" alt="1694612273475" style="zoom:80%;" /><h3 id="可靠数据传输协议基本结构-接口"><a href="#可靠数据传输协议基本结构-接口" class="headerlink" title="可靠数据传输协议基本结构:接口"></a>可靠数据传输协议基本结构:接口</h3><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612283387.png" alt="1694612283387" style="zoom:80%;" /><h3 id="可靠数据传输协议"><a href="#可靠数据传输协议" class="headerlink" title="可靠数据传输协议"></a>可靠数据传输协议</h3><ul><li>渐进的设计可靠数据传输协议的<strong>发送方</strong>和<strong>接收方</strong></li><li>只考虑单项数据传输</li><li>但是控制信息双向流动</li><li>利用状态机(Fnite State Machine,FSM)刻画传输协议</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612449445.png" alt="1694612449445"></p><p>Rdt1.0:可靠信道上的可靠数据传输</p><p>底层信道<strong>完全可靠</strong></p><ul><li>不会发生错误(bit error)</li><li>不会丢弃分组<br>发送方和接收方的FSM独立</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612519572.png" alt="1694612519572"></p><h2 id="Rdt-2-0"><a href="#Rdt-2-0" class="headerlink" title="Rdt 2.0"></a>Rdt 2.0</h2><h4 id="Rdt-2-0-产生位错误的信道"><a href="#Rdt-2-0-产生位错误的信道" class="headerlink" title="Rdt 2.0: 产生位错误的信道"></a>Rdt 2.0: 产生位错误的信道</h4><p>底层信道可能反转分组中的位</p><ul><li>利用<strong>校验</strong>和检测为错误</li></ul><p>如何从错误中回复？</p><ul><li><p>**确认机制(Acknowledgements,ACK):**接收方<code>显式的</code>告知发送方分组已经正确接收</p></li><li><p>NAK：接收方<code>显式的</code>告知发送方的分组有错误</p></li><li><p>发送方收到NAK之后，<code>重发</code>分组</p></li></ul><p>基于这种重传机制的rdt协议称为<em>ARQ(Automatic Repeat reQuest)</em> 协议</p><p>Rdt 2.0中引入的新机制</p><ul><li><p>差错检测(校验和的方式)</p></li><li><p>接收方反馈控制信息：<strong>ACK&#x2F;NAK</strong></p></li><li><p>重传</p></li></ul><p>Rdt 2.0:<code>FSM规约</code></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694736520687.png" alt="1694736520687"></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694736529915.png" alt="1694736529915"></p><h2 id="Rdt-2-1-和-2-2"><a href="#Rdt-2-1-和-2-2" class="headerlink" title="Rdt 2.1 和 2.2"></a>Rdt 2.1 和 2.2</h2><p>对Rst 2.0的改进，先要知道Rdt 2.0有什么缺陷？</p><p><strong>如果ACK和NAK消息发生错误了怎么办</strong>？</p><p><code>Solution 1</code>:为NAK和NCK增加校验和，检错并纠错</p><p><code>Solution 2</code>:发送方收到被破坏的ACK&#x2F;NAK的时候不知道接收方发生了什么，添加额外的<code>控制消息</code> </p><p><code>Solution 3</code>:如果ACK&#x2F;NAK坏掉，就重传。但是不能简单的重传，因为会产生重复分组。</p><p><strong>怎么解决重复分组问题</strong>？</p><p><strong>序列号(Sequance number)</strong>:发送方给每个分组增加序列号</p><p>接收方丢弃重复分组</p><p><strong>stop and wait</strong>:<br>  Sender sends one packet, then waits for reciever response.</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694764764860.png" alt="1694764764860"></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694764776396.png" alt="1694764776396"></p><h3 id="Rdt-2-1-vs-Rdt-2-0"><a href="#Rdt-2-1-vs-Rdt-2-0" class="headerlink" title="Rdt 2.1 vs Rdt 2.0"></a>Rdt 2.1 vs Rdt 2.0</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>为每个分组增加了序列号</p><p>两个序号（0，1）就够用，为什么？</p><p>需要检验ACK&#x2F;NAK消息是否发生错误</p><p>状态数量翻倍<br>  状态必须<strong>记住</strong>当前的分组序列号</p><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p>需要判断分组<code>是不是重复</code><br>  当前所处的状态提供了<u><em>期望收到分组的序列号</em></u></p><p>注意：接收方无法知道ACK&#x2F;NAK是否被正确接收到</p><h4 id="Rdt-2-2-无NAK消息协议"><a href="#Rdt-2-2-无NAK消息协议" class="headerlink" title="Rdt 2.2: 无NAK消息协议"></a>Rdt 2.2: 无NAK消息协议</h4><p>我们真的需要两种确认消息(<code>ACK</code>+<code>NAK</code>)?</p><p>和rdt2.1 的功能相同，但是只使用NAK</p><p>🧐怎么实现？</p><ul><li><p>接收方通过ACK告知最后一个被正确接收的分组</p></li><li><p>在<strong>ACK</strong>消息中<strong>显式的加入被确认分组的序列号</strong></p></li></ul><p>发送方收到重复的ACK之后，采取与收到NAK消息相同的动作</p><ul><li>重传当前的分组</li></ul><h3 id="Rdt-2-2-FSM片段"><a href="#Rdt-2-2-FSM片段" class="headerlink" title="Rdt 2.2 FSM片段"></a>Rdt 2.2 FSM片段</h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694765185191.png" alt="1694765185191"></p><h2 id="Rdt-3-0"><a href="#Rdt-3-0" class="headerlink" title="Rdt 3.0"></a>Rdt 3.0</h2><p>如果信道极可能发生错误，也可能丢失分组，怎么办</p><p>“校验和+序列号+ACK+重传”<strong>够用吗</strong>？</p><p>方法：发送方等待”<code>合理</code>“时间</p><p>如果timeout，有没有收到ACK就可以采取动作了 $\rightarrow$ <strong>重传</strong></p><p>☹但是时间是很难设定的，如果只是延迟了，就会引起重复的问题</p><ul><li>但是序列号能够处理</li><li>接收方需要在ACK中显式的告知所确认的分组</li><li>需要<strong>定时器</strong></li></ul><h3 id="Rdt-3-0-发送方FSM"><a href="#Rdt-3-0-发送方FSM" class="headerlink" title="Rdt 3.0 发送方FSM"></a>Rdt 3.0 <strong>发送方FSM</strong></h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766165886.png" alt="1694766165886"></p><h3 id="Rdt-3-0-运行实例"><a href="#Rdt-3-0-运行实例" class="headerlink" title="Rdt 3.0 运行实例"></a>Rdt 3.0 运行实例</h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766219749.png" alt="1694766219749"></p><p>⬆ 发送方和接收方在传输过程中没有丢包的存在</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766226555.png" alt="1694766226555"></p><p>⬆ 在发送过程当中发生丢失的情况，执行停-等协议，造成超时，所以重新传输分组</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766471113.png" alt="1694766471113"></p><p>⬆ 标识收到了两个分组（相同序列号），那就丢掉一个然后进行传输ACK</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766548272.png" alt="1694766548272"></p><p>⬆ 标识两次都发送了，表明第一次正确接收了，但是返回ACK的过程当中触发执行停等协议然后重新发送了一次。收到了ACK1之后会传换成发送pkt0，第二次发的ACK1到达的时候正好有了ACK0。<br>称之为<code>计时器时间过短</code>、<code>timeout早熟</code></p><h3 id="Rdt-3-0-性能分析"><a href="#Rdt-3-0-性能分析" class="headerlink" title="Rdt 3.0 性能分析"></a>Rdt 3.0 性能分析</h3><p>Rdt 3.0能够正常工作，但是性能很差</p><p>示例：1Gbps链路，15ms端到端传输延迟，1kB分组</p><p>$T_{transmit}&#x3D;\frac{L(packet \ length \ in \ bits)}{R(transmission \  rate, \ bps)}&#x3D;\frac{8kb&#x2F;pkt}{10^9b&#x2F;sec}&#x3D;8 ms$</p><p>发送方的利用率：发送方发送时间百分比</p><p>$U_{sender}&#x3D;\frac{L&#x2F;R}{RTT+L&#x2F;R}&#x3D;0.008&#x2F;30.008&#x3D;0.00027$</p><p>在1Gbps链路上每30毫秒才能发送一个分组 $\Rightarrow$ 33KB&#x2F;s</p><p><strong>网络协议限制了物理资源的利用</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694767041067.png" alt="1694767041067"></p><p>$U_{sender}&#x3D;\frac{L&#x2F;R}{RTT+L&#x2F;R}&#x3D;0.008&#x2F;30.008&#x3D;0.00027$</p><h2 id="流水线的机制和滑动窗口协议"><a href="#流水线的机制和滑动窗口协议" class="headerlink" title="流水线的机制和滑动窗口协议"></a>流水线的机制和滑动窗口协议</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768215316.png" alt="1694768215316"></p><p>回顾最初的Rdt 3.0操作</p><p>可以更改为同时发多个分组，这样就能有更好的性能</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768312234.png" alt="1694768312234"></p><p>$U_{sender}&#x3D;\frac{3*L&#x2F;R}{RTT+L&#x2F;R}&#x3D;\frac{0.024}{30.008}&#x3D; 0.0008$</p><p>允许发送方在收到ACK之前连续发送多个分组</p><ul><li><p>更大的序列号范围</p></li><li><p>发送方和&#x2F;或接收方需要更大的存储空间以<strong>缓存分组</strong></p></li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768451060.png" alt="1694768451060"></p><p>很明显可以看出效率有明显提高</p><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p><strong>滑动窗口协议</strong>：Sliding-window protocol</p><ul><li><p>窗口</p><ul><li>允许使用的序列号范围      </li><li>窗口尺寸为N：最多有N个等待确认的消息</li></ul></li><li><p><strong>滑动窗口</strong></p><ul><li>随着协议的运行，窗口在序列号空间内向前滑动</li></ul></li></ul><p><strong>滑动窗口协议</strong>：GBN，SR</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768609208.png" alt="1694768609208"></p><h2 id="GBN-Go-Back-N"><a href="#GBN-Go-Back-N" class="headerlink" title="GBN(Go-Back-N)"></a>GBN(Go-Back-N)</h2><h3 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h3><ul><li>分组头部包含k-bit序列号</li><li>窗口尺寸为<strong>N</strong>，最多允许<strong>N</strong>个分组未确认</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768789786.png" alt="1694768789786"></p><ul><li><p>ACK(n):确认到序列号n(包含n)的分组<code>均已经被正确接收</code></p><ul><li>可能收到重复的ACK</li></ul></li><li><p>为空中的分组设置计时器</p></li><li><p>超时<strong>Timeout</strong>事件：重传序列号<strong>大于等于n</strong>，还没有收到ACK的所有分组</p></li></ul><h3 id="GBN：发送方扩展FSM"><a href="#GBN：发送方扩展FSM" class="headerlink" title="GBN：发送方扩展FSM"></a>GBN：发送方扩展FSM</h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694769021950.png" alt="1694769021950"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nextseqnum &lt; base + N)&#123; <span class="comment">//意味着还有可用的seqnum意味着还可以接着发送分组</span></span><br><span class="line">  sndpkt[nextseqnum]=<span class="built_in">make_pkt</span>(nextseqnum.data.chksum);</span><br><span class="line">  <span class="built_in">udt_send</span>(sndpkt[nextseqnum]);</span><br><span class="line">  <span class="keyword">if</span> (base == nextseqnum)&#123;<span class="comment">//如果base和nextseqnum相等的话，就启动定时器</span></span><br><span class="line">    <span class="built_in">start_timer</span>();</span><br><span class="line">    nextseqnum++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">refuse_data</span>(data);<span class="comment">//如果窗口里面的序列号已经用光了，就可以refuse掉当前的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Timeout事件出现的操作"><a href="#Timeout事件出现的操作" class="headerlink" title="Timeout事件出现的操作"></a>Timeout事件出现的操作</h4><p>Timeout $\rightarrow$ start_timer()<br>udt_send(sndpkt[base])<br>……<br>udt_send(sndpkt[nextseqsum-1])</p><h3 id="GBN：接收方扩展FSM"><a href="#GBN：接收方扩展FSM" class="headerlink" title="GBN：接收方扩展FSM"></a>GBN：接收方扩展FSM</h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694769484914.png" alt="1694769484914"></p><ul><li>ACK机制：发送拥有最高序列号的、已经被正确的接收的分组的ACK<ul><li>可能产生重复的ACK</li><li>只需要记住唯一的expectedseqnum</li></ul></li><li>乱序到达的分组：<ul><li>直接丢弃 $\rightarrow$ 接收方<code>没有缓存</code></li><li>重新确认<code>序列号最大</code>的<code>按照序列到达</code>的分组</li></ul></li></ul><h3 id="GBN的实例"><a href="#GBN的实例" class="headerlink" title="GBN的实例"></a>GBN的实例</h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694769749622.png" alt="1694769749622"></p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>数据量链路层采用后退N帧的协议，发送方已经发送了编号为0~7的帧，当计时器超市的时候，如果发送方只收到了0，2，3号帧的确认，那么发送方需要重发的帧数是多少，分别是哪几个帧？</p><blockquote><p>根据GBN的工作原理，GBN协议的确认是累计确认，所以此时发送端需要重发的帧数是4个，依次次分别是4、5、6、7</p></blockquote><h2 id="SR协议"><a href="#SR协议" class="headerlink" title="SR协议"></a>SR协议</h2><h3 id="Select-Repeat协议"><a href="#Select-Repeat协议" class="headerlink" title="Select Repeat协议"></a>Select Repeat协议</h3><p>GBN有什么缺陷？</p><ul><li>不使用累积确认机制，接收方对每个分组单独进行确认<ul><li><strong>设置缓存机制</strong>，缓存乱序到达的分组</li></ul></li><li>发送方只用重传哪些没收到ACK的分组<ul><li>为每个分组设置计时器</li></ul></li><li><strong>发送方窗口</strong><ul><li>N个连续的序列号</li><li>限制已经发送且未发送的分组</li></ul></li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694770256143.png" alt="1694770256143"></p><p><strong>分布式系统的网络</strong></p><h4 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h4><ul><li><strong>data from above</strong>:<ul><li>if next available seq # in window, send pkt</li></ul></li><li><strong>timeout (n)</strong>:<ul><li>resend pkt n, restart timer</li></ul></li><li><strong>ACK(n) in [sendbase,sendBase+N]</strong>:<ul><li>mark pkt n as recieved</li><li>if n smallest unACKed pkt, advanced window base to next unACKed seq #</li></ul></li></ul><h4 id="recevier"><a href="#recevier" class="headerlink" title="recevier"></a>recevier</h4><ul><li><strong>pkt n in [revbase, revbase+N-1]</strong><ul><li>send ACK(n)</li><li>out-of-order:buffer</li><li>in-order:deliver(also deliver buffered, in-order pkts), advance window to next not-yet-recieved pkt</li></ul></li><li><strong>pkt n in [rcvbase-N,rcvbase-1]</strong><ul><li>ACK(n)</li></ul></li><li><strong>otherwise:</strong><ul><li>ignore</li></ul></li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694770984071.png" alt="1694770984071"></p><h3 id="SR协议：困境"><a href="#SR协议：困境" class="headerlink" title="SR协议：困境"></a>SR协议：困境</h3><ul><li>序列号：0，1，2，3</li><li>窗口尺寸：3</li><li>接收方能够区分开两种不同的场景吗？<ul><li>(a)中发送方重发<br><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694771172608.png" alt="1694771172608"></li><li>(b)中发送了第五个分组<br><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694771259880.png" alt="1694771259880"></li></ul></li></ul><h4 id="问题：序列号空间大小和窗口尺寸需要满足什么关系？"><a href="#问题：序列号空间大小和窗口尺寸需要满足什么关系？" class="headerlink" title="问题：序列号空间大小和窗口尺寸需要满足什么关系？"></a>问题：序列号空间大小和窗口尺寸需要满足什么关系？</h4><blockquote><p>$N_S+N_R \leq 2^k$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-虚电路网络</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E7%94%B5%E8%B7%AF%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E7%94%B5%E8%B7%AF%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="连接服务和无连接服务"><a href="#连接服务和无连接服务" class="headerlink" title="连接服务和无连接服务"></a>连接服务和无连接服务</h2><p>数据报网络和虚电路网络是典型两类 <strong>分组交换网络</strong></p><p>数据报网络提供网络层无连接服务</p><p>虚电路网络日工网络层的连接服务</p><p>类似于传输层的无连接服务(<code>UDP</code>)和面向连接服务(<code>TCP</code>)，但是网络层服务：</p><ol><li>主机到主机服务(而前者是端到端的连接)</li><li>网络核心实现</li></ol><h2 id="虚电路-Virtual-circuits-VC"><a href="#虚电路-Virtual-circuits-VC" class="headerlink" title="虚电路(Virtual circuits) VC"></a>虚电路(Virtual circuits) VC</h2><p><strong>虚电路</strong>：一条从源主机到目的主机， <em>类似于电路</em>的路径(逻辑链接)</p><ul><li><p>分组交换 （和电路交换的建立的电路网络不相同）</p></li><li><p>每个分组的传输利用链路的全部带宽</p></li><li><p>源到目的路径经过的网络层设备共同完成虚电路的功能</p></li></ul><p><strong>通信过程：</strong></p><ul><li>呼叫建立（call setup） $\to$ 数据传输 $\to$ 拆除呼叫</li></ul><p><code>VCID</code> 每个分组携带虚电路标识<code>VCID</code>, 而不是目的主机地址</p><p>虚电路经过的每个网络设备(如路由器)，维护 <strong>每条</strong> 经过它的虚电路连接状态</p><p>链路、网络设备资源（如带宽、缓存等）可以面向VC进行预分配</p><ul><li>预分配资源 &#x3D; 可预期服务性能</li><li>如ATM 的电路仿真</li></ul><h2 id="VC的具体实现"><a href="#VC的具体实现" class="headerlink" title="VC的具体实现"></a>VC的具体实现</h2><h3 id="每条虚电路包括"><a href="#每条虚电路包括" class="headerlink" title="每条虚电路包括"></a>每条虚电路包括</h3><ol><li>源主机到目的主机的<strong>一条路径</strong></li><li>虚电路号（VCID），沿路每段链路的一个编号，有多少的链路就表现出网络的性能</li><li>沿路每个网络层设备（路由器等），<strong>利用转发表记录经过的每条虚电路</strong></li></ol><p><strong>沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址</strong></p><p>同一条VC，在每段链路上的VCID通常不同</p><ul><li>路由器转发分组的时候根据转发表改写&#x2F;替换虚电路号</li></ul><h2 id="VC转发表"><a href="#VC转发表" class="headerlink" title="VC转发表"></a>VC转发表</h2><p>每一个网络设备都要参与记录转发表</p><p>路由器R1的VC转发表</p><table><thead><tr><th>输入接口</th><th>输入VC #</th><th>输出接口</th><th>输出VC #</th></tr></thead><tbody><tr><td>1</td><td>12</td><td>3</td><td>22</td></tr><tr><td>2</td><td>63</td><td>1</td><td>18</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><p><strong>VC路径上每个路由器都需要维护VC连接的状态信息</strong></p><h2 id="虚电路信令协议（signal-protocols）"><a href="#虚电路信令协议（signal-protocols）" class="headerlink" title="虚电路信令协议（signal protocols）"></a>虚电路信令协议（signal protocols）</h2><p>用于VC的建立维护和拆除</p><ul><li>路径选择</li></ul><p>应用于虚电路网络</p><ul><li>如ATM、帧中继网络等</li></ul><p><strong>目前的Internet不再采用</strong></p><ol><li>初始呼叫(通过路由)</li><li>呼叫到达</li></ol><p><strong>虚电路俩连接之后，就开始下一段的行动，进行连接的建立和数据的传输</strong></p><ol start="3"><li><p>接收呼叫</p></li><li><p>呼叫建立</p></li><li><p>数据流开始</p></li><li><p>接收数据</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-计算机网络传输层-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>可靠数据传输原理 -&gt; TCP</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP是面向连接的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，两个进程必须先相互握手。</p><p>连接的双方都将初始化和TCP连接相关的许多TCP状态变量</p><p><strong>全双工服务（full-duplex service）</strong></p><p><strong>点对点(point-to-point)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络应用进程通信</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]# 网络应用进程通信<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong><code>进程</code></strong></h2><ul><li>主机上运行的程序</li></ul><h2 id="同一主机上运行的进程之间如何进行通信"><a href="#同一主机上运行的进程之间如何进行通信" class="headerlink" title="同一主机上运行的进程之间如何进行通信"></a>同一主机上运行的进程之间如何进行通信</h2><ul><li>进程间的<code>**通讯机制**</code></li><li>操作系统来提供</li></ul><h2 id="不同主机上运行的进程之间如何通信"><a href="#不同主机上运行的进程之间如何通信" class="headerlink" title="不同主机上运行的进程之间如何通信"></a>不同主机上运行的进程之间如何通信</h2><ul><li><strong><code>消息交换</code></strong></li></ul><p><strong>客户机进程：发起通信的进程</strong></p><p><strong>服务器进程：等待通信请求的进程</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png" alt="Untitled"></p><h2 id="套接字：Socket"><a href="#套接字：Socket" class="headerlink" title="套接字：Socket"></a>套接字：<em>Socket</em></h2><p>进程之间通信利用Socket发送和接受消息实现</p><h3 id="类似于寄信"><a href="#类似于寄信" class="headerlink" title="类似于寄信"></a>类似于寄信</h3><ul><li><strong>发送方</strong>将消息送到<strong>门外的邮箱</strong></li><li><strong>发送方</strong>以来（门外的）传输基础设施将消息传输到<strong>接收方所在的主机</strong>，并且送到<strong>接受方的门外</strong></li><li><strong>接收方从门外获取消息</strong></li></ul><h3 id="传输基础设施向进程提供API"><a href="#传输基础设施向进程提供API" class="headerlink" title="传输基础设施向进程提供API"></a>传输基础设施向进程提供API</h3><ul><li>传输协议的选择</li><li>参数的设置</li></ul><p>很自然的问题，底层的设施怎么就能正确无误的接收到传输到的进程呢？</p><h2 id="如何寻址进程"><a href="#如何寻址进程" class="headerlink" title="如何寻址进程"></a>如何寻址进程</h2><h3 id="不同主机上的进程之间通信，那么每个进程都必须拥有标识符"><a href="#不同主机上的进程之间通信，那么每个进程都必须拥有标识符" class="headerlink" title="不同主机上的进程之间通信，那么每个进程都必须拥有标识符"></a>不同主机上的进程之间通信，那么每个进程都必须拥有标识符</h3><h3 id="如何寻址主机？——IP地址"><a href="#如何寻址主机？——IP地址" class="headerlink" title="如何寻址主机？——IP地址"></a>如何寻址主机？——IP地址</h3><ul><li>Q：主机有了IP地址之后，是否<code>**足以</code> 定位进程？**</li><li>A：不是，同一个主机可能同时有多个进程需要通信</li></ul><p><strong>端口号&#x2F;<em>Port Number</em></strong></p><ul><li>是主机上每个需要通信的进程都分配一个端口号</li><li>HTTP Server：80</li><li>Mail Server：25</li></ul><h3 id="进程的标识符"><a href="#进程的标识符" class="headerlink" title="进程的标识符"></a>进程的标识符</h3><ul><li>IP地址+端口号</li></ul><h2 id="应用层的协议"><a href="#应用层的协议" class="headerlink" title="应用层的协议"></a>应用层的协议</h2><h3 id="网络应用都应该需要遵循应用层协议"><a href="#网络应用都应该需要遵循应用层协议" class="headerlink" title="网络应用都应该需要遵循应用层协议"></a>网络应用都应该需要遵循应用层协议</h3><h3 id="公开协议"><a href="#公开协议" class="headerlink" title="公开协议"></a>公开协议</h3><ul><li>由RFC（<em><strong>Request For Comments</strong></em>）定义</li><li>允许互相操作</li><li>HTTP，SMTP，……</li></ul><h3 id="私有协议"><a href="#私有协议" class="headerlink" title="私有协议"></a>私有协议</h3><ul><li>多数P2P文件共享应用</li></ul><h2 id="应用层协议的内容"><a href="#应用层协议的内容" class="headerlink" title="应用层协议的内容"></a>应用层协议的内容</h2><h3 id="消息的类型（type）"><a href="#消息的类型（type）" class="headerlink" title="消息的类型（type）"></a>消息的类型（type）</h3><ul><li>请求消息</li><li>响应消息</li></ul><h3 id="消息的语法（syntax）格式"><a href="#消息的语法（syntax）格式" class="headerlink" title="消息的语法（syntax）格式"></a>消息的语法（syntax）格式</h3><ul><li>消息中由哪些字段</li><li>每个字段如何描述</li></ul><h3 id="字段的语义（semantics）"><a href="#字段的语义（semantics）" class="headerlink" title="字段的语义（semantics）"></a>字段的语义（semantics）</h3><ul><li>字段中信息的含义</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>进程应该何时、如何发送消息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-虚拟局域网</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="VLANs：动机"><a href="#VLANs：动机" class="headerlink" title="VLANs：动机"></a>VLANs：动机</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101220617.png" alt="image.png"></p><p>考虑一下情形:CS用户迁移到EE，但是希望连接至CS交换机，怎么办?</p><p>单一广播域:</p><p>所有第2层广播流量(ARPDHCP,未知目的MAC地址位置)必须穿越整个LAN</p><p>安全&#x2F;隐私，效率问题</p><h3 id="虚拟局域网-VirtualLocal-Area-Network"><a href="#虚拟局域网-VirtualLocal-Area-Network" class="headerlink" title="虚拟局域网(VirtualLocal Area Network)"></a>虚拟局域网(VirtualLocal Area Network)</h3><p>支持VLAN划分的交换机，可以在一个物理LAN架构上配置定义多个VLAN</p><p>基于端口的VLAN: 分组交换机端口(通过交换机管理软件)，于是，单一的物理交换机 …..</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101220735.png" alt="image.png"></p><p><strong>流量隔离(traffic isolation)</strong>:去往&#x2F;来自端口1-8的倾只到达端口1-8</p><ul><li>也可以基于MAC地址定义VLAN,而不是交换端口</li></ul><p><strong>动态成员</strong>: 端口可以动态分配给不同VLAN</p><p><strong>在VLAN间转发: 通过路由(就像在独立的交换机之间)</strong></p><p>实践中，厂家会将交换机与路由器集成在一起</p><h2 id="跨越多交换机的VLAN"><a href="#跨越多交换机的VLAN" class="headerlink" title="跨越多交换机的VLAN"></a>跨越多交换机的VLAN</h2><p><strong>多线缆连接</strong></p><ul><li>每个线缆连接一个VLAN</li></ul><p><strong>中继端口(trunk port)</strong>: 在跨越多个物理交换机定义的VLAN承载帧</p><ul><li><p>为多VLAN转发802.1顿容易产生歧义(必须携带VLAN ID信息)</p></li><li><p>802.1q协议为经过中继端口转发的顿增加&#x2F;去除额外的首部域</p></li></ul><h2 id="802-1Q-VLAN帧格式"><a href="#802-1Q-VLAN帧格式" class="headerlink" title="802.1Q VLAN帧格式"></a>802.1Q VLAN帧格式</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101221243.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络应用的体系结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 网络应用的体系结构<h1 id="你使用过哪些网络应用？"><a href="#你使用过哪些网络应用？" class="headerlink" title="你使用过哪些网络应用？"></a>你使用过哪些网络应用？</h1><p>百度 QQ alipay weixin ……</p><h1 id="网络应用有哪些特点呢？"><a href="#网络应用有哪些特点呢？" class="headerlink" title="网络应用有哪些特点呢？"></a>网络应用有哪些特点呢？</h1><p><strong>🤔和单机应用有什么不同？</strong></p><p><strong>🤔网络应用应该有什么样的结构呢？</strong></p><h1 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h1><p><code>**客户机、服务器**</code>结构（Client-Server,C）</p><p><code>**点对点**</code>结构（Peer-to-peer,P2P）</p><p><code>**混合**</code>结构</p><h2 id="客户机-服务器结构"><a href="#客户机-服务器结构" class="headerlink" title="客户机&#x2F;服务器结构"></a>客户机&#x2F;服务器结构</h2><p><strong><strong><strong>客户机：</strong></strong></strong></p><ul><li>和服务器通信</li><li><strong>间歇性</strong>接入网络</li><li>可能有<strong>动态的IP地址</strong></li><li>不会和其他的客户机通信</li></ul><p><strong>服务器：</strong></p><ul><li>需要不断提供服务</li><li><code>永久性</code>的访问地址</li><li>利用<strong>大量服务器</strong>实现可扩展性</li></ul><p><strong>例子</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png" alt="Untitled"></p><h2 id="纯P2P结构"><a href="#纯P2P结构" class="headerlink" title="纯P2P结构"></a>纯P2P结构</h2><p>基本上看不出来明显的服务器和客户机的差别了</p><aside>🪶 **特点**<p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.png" alt="Untitled"></p><ul><li>没有永远在线的服务器</li><li>任意端或者节点之间都可以直接通讯</li><li>节点间歇性的接入网络</li><li>节点可能改变IP地址</li></ul><p><strong>优点</strong></p><p><strong>高度可伸缩的</strong></p><p><strong>缺点</strong></p><p><strong>难以管理</strong></p></aside><h2 id="混合结构"><a href="#混合结构" class="headerlink" title="混合结构"></a>混合结构</h2><p>🤔<strong>能否将两种结构混合在一起呢？并能够结合两者的优点？</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png" alt="可以避免服务器的资源过度使用"></p><p>可以避免服务器的资源过度使用</p><ul><li><em><strong>Napster应用</strong></em><ul><li><strong>文件传输</strong>使用P2P结构</li><li><strong>文件的搜索</strong>采用C&#x2F;S结构——<code>**集中式**</code><ul><li>每个节点<em>向中央服务器登记自己的内容</em></li><li>每个节点向中央服务器<em>提交查询要求</em>，查找感兴趣的内容</li></ul></li></ul></li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p><strong>每种网络体系结构找出5种以上的网络应用</strong></p><p><strong>从多个方面&#x2F;角度对比三种体系结构的优缺点</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络应用层概述</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 网络应用层概述<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><h2 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h2><ul><li>客户机和服务器</li><li>P2P</li><li>混合结构</li></ul><table><thead><tr><th>application</th></tr></thead><tbody><tr><td>transport</td></tr><tr><td>network</td></tr><tr><td>link</td></tr><tr><td>physical</td></tr></tbody></table><h2 id="网络应用的服务需求"><a href="#网络应用的服务需求" class="headerlink" title="网络应用的服务需求"></a>网络应用的服务需求</h2><ul><li>可靠性</li><li>带宽</li><li>时延</li></ul><h2 id="Internet传输层服务模型"><a href="#Internet传输层服务模型" class="headerlink" title="Internet传输层服务模型"></a>Internet传输层服务模型</h2><ul><li>TCP</li><li>UDP</li></ul><h2 id="特定协议网络模型"><a href="#特定协议网络模型" class="headerlink" title="特定协议网络模型"></a>特定协议网络模型</h2><ul><li>HTTP</li><li>SMTP POP IMAP</li><li>DNS</li><li>P2P应用</li></ul><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><ul><li>TCP</li><li>UDP</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络层服务</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>从发送主机像接受主机传送数据段</p><p><strong>发送主机</strong>： 将数据段封装到数据报中</p><p><strong>接收主机</strong>：向传输层交付数据段</p><p><em><strong>每个</strong></em>主机和路由器都运行网络层协议</p><p>路由器检验所有穿越它的IP数据报的头部域</p><h2 id="网络层的核心功能-——-转发和路由"><a href="#网络层的核心功能-——-转发和路由" class="headerlink" title="网络层的核心功能 —— 转发和路由"></a>网络层的核心功能 —— 转发和路由</h2><p>路由器怎么把数据包转发到数据端口上最终送到目的地？</p><blockquote><p>[!转发（forwarding）]<br>将分组从路由器的输入端口转移到合适的输出端口</p></blockquote><p>转发表： 转发表确定在本路由器如何转发分组</p><p>每一个地址来对应一个输出链路，通过转发表来进行寻找路线。</p><p>必须事先建立起转发表，才能进行传输数据。</p><blockquote><p>[!路由(routing)]<br>确定分组从源到目的经过的路径</p></blockquote><p><strong>路由算法</strong> （routing algorithms）</p><ul><li><em>确定通过网络的端到端路径</em></li></ul><h2 id="网络层核心功能-——-连接建立"><a href="#网络层核心功能-——-连接建立" class="headerlink" title="网络层核心功能 —— 连接建立"></a>网络层核心功能 —— 连接建立</h2><p>某些网络的重要功能：</p><ul><li>ATM 帧中继 X.25</li></ul><p>数据分组传输之前两端主机需要<strong>首先</strong>建立虚拟&#x2F;逻辑连接</p><ul><li>网络设备（如路由器）参与连接的建立</li></ul><p>网络层连接和传输层连接的<strong>对比</strong></p><ul><li>网络层连接：两个主机之间（<em>路径上的路由器等网络设备参与其中</em>）</li><li>传输层连接：两个应用进程之间（<em>对中间网络设备透明</em>）</li></ul><h2 id="网络层服务模型"><a href="#网络层服务模型" class="headerlink" title="网络层服务模型"></a>网络层服务模型</h2><p>Q： 网络层为发送端到接收端的数据包传送通道( channel )提供什么样的服务模型(service model)？</p><p>Internet 网络层中提供的模型 Best effort model <code>尽力服务</code></p><p>作为网络层，不需要进行拥塞控制或者拥塞信息的处理</p><p><em>通过是否发生数据丢失来确定是否发生了数据的拥塞</em></p><p>ATM 网络 :</p><ul><li>CBR  constant rate 固定比特率 所以带宽是保障的，不会出现拥塞。</li><li>VBR  guaranteed rate 再拥塞的时候只能提供最低的传输数据带宽</li><li>ABR</li></ul><h3 id="无连接服务-connection-less-service"><a href="#无连接服务-connection-less-service" class="headerlink" title="无连接服务 (connection-less service)"></a>无连接服务 (connection-less service)</h3><ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径（根据网络状况来动态的选择）</li><li>不同的分组可能传输路径不相同<ul><li>所以发到的数据顺序可能是不一样的</li></ul></li><li><strong>数据报网络(datagram network)</strong></li></ul><h3 id="连接服务-connection-service"><a href="#连接服务-connection-service" class="headerlink" title="连接服务(connection service)"></a>连接服务(connection service)</h3><ul><li>首先 为系列分组传输确定从源到目的的经过的路径(建立连接)</li><li>然后沿该路径(连接)传输系列分组</li><li>系列分组传输路径相同</li><li>传输结束之后拆除连接</li><li><strong>虚电路网络(virtual-sircuit network)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络层例题讲解</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>某网络拓扑如下图所示，路由器R1通过接口E1、E2分别连接局域网1、局域网2，通过接口LO连接路由器R2，并通过路由器R2连接域名服务器与互联网。R1的LO接口的IP地址是202.118.2.1;R2的LO接口的IP地址是202.118.2.2，L1接口的IP地址是130.11.120.1，EO接口的IP地址是202.118.3.1;域名服务器的IP地址是202.118.3.2。</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030134252.png" alt="image.png"></p><p>R1和R2的路由表结构为：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030134326.png" alt="image.png"></p><p>(1)将IP地址空间202.118.1.0&#x2F;24划分为2个子网，分别分配给局域网1、局域网2，每个局域网需分配的IP地址数不少于120个。请给出子网划分结果，说明理由或给出必要的计算过程</p><blockquote><p>可以看出是标准的C网，202.118.1.0 ~ 202.118.1.254<br>划分结果为：<br>子网1：202.118.1.0，子网掩码为255.255.255.128<br>（202.118.1.0&#x2F;25）<br>子网2：202.118.1.128，子网掩码为255.255.255.128<br>（202.118.1.128&#x2F;25）</p></blockquote><p>(2)请给出R1的路由表，使其明确包括到局域网1的路由、局域网2的路由、域名服务器的主机路由和互联网的路由。</p><table><thead><tr><th align="center">目的网络IP地址</th><th align="center">子网掩码</th><th align="center">下一跳IP地址</th><th align="center">接口</th></tr></thead><tbody><tr><td align="center">202.118.1.0</td><td align="center">255.255.255.128</td><td align="center">-</td><td align="center">E1</td></tr><tr><td align="center">202.118.1.128</td><td align="center">255.255.255.128</td><td align="center">-</td><td align="center">E2</td></tr><tr><td align="center"><div>202.118.3.2</div></td><td align="center"><div>255.255.255.255</div></td><td align="center">202.118.2.2</td><td align="center">L0</td></tr><tr><td align="center">0.0.0.0</td><td align="center">0.0.0.0</td><td align="center">202.118.2.2</td><td align="center">L0</td></tr></tbody></table><p>(3)请采用路由聚合技术，给出R2到局域网1和局域网2的路由。</p><table><thead><tr><th align="center">目的IP地址</th><th align="center">子网掩码</th><th align="center">下一跳IP地址</th><th align="center">L0</th></tr></thead><tbody><tr><td align="center">202.118.1.0</td><td align="center">255.255.255.0</td><td align="center">202.118.2.1</td><td align="center">L0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-有类IP地址</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%9C%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%9C%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>IP子网 [[CourseNotes&#x2F;计算机体系结构&#x2F;CN-IP编址|CN-IP编址]]</p><h2 id="IP地址（Addresses"><a href="#IP地址（Addresses" class="headerlink" title="IP地址（Addresses)"></a>IP地址（Addresses)</h2><p>“有类”编址</p><p><strong>A类地址</strong>：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015202955.png" alt="image.png"></p><p>0.0.0.0 ~ 127.255.255.255</p><p><strong>B类地址</strong>：<br><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015203137.png" alt="image.png"><br>128.0.0.0 ~ 191.255.255.255.255</p><p><strong>C类地址</strong>：<br><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015203302.png" alt="image.png"><br>192.0.0.0 ~ 233.255.255.255</p><p>定义C类地址前八位用于网络号，后面八位用于主机号</p><p>对于剩余的八分之一的地址空间进行最后一次的二分，D类地址不再确认网络号和主机号，用于特殊的目的：</p><p>用于标识一组主机，理论上可以在互联网中的所有地方。称为<strong>多播地址</strong>。</p><p>E类地址保留作为研究使用</p><h2 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h2><table><thead><tr><th align="center">NetID</th><th align="center">HostID</th><th align="center">作为IP分组源地址</th><th align="center">作为IP分组目的地址</th><th>用途</th></tr></thead><tbody><tr><td align="center">全0</td><td align="center">全0</td><td align="center">可以</td><td align="center">不可以</td><td>在本网范围内表示本机; 在路由表中用于表示默认路由相当于表示整个Internet网络</td></tr><tr><td align="center">全0</td><td align="center">特定值</td><td align="center">不可以</td><td align="center">可以</td><td>标识本网内某个特定的主机</td></tr><tr><td align="center">全1</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td>本网的广播地址（路由器不转发）  <strong>受限网络地址</strong></td></tr><tr><td align="center">特定值</td><td align="center">全0</td><td align="center">不可以</td><td align="center">可以</td><td>网络地址，表示一个网络</td></tr><tr><td align="center">特定值</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td>直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td align="center">127</td><td align="center">非全0或者非全1的任何数</td><td align="center">可以</td><td align="center">可以</td><td>用于本地软件环回测试</td></tr></tbody></table><h2 id="私有（pivate）IP地址"><a href="#私有（pivate）IP地址" class="headerlink" title="私有（pivate）IP地址"></a>私有（pivate）IP地址</h2><p>只用于私有网络，在公共网络上这种地址是无效的</p><table><thead><tr><th align="center">Class</th><th align="center">NetIDs</th><th align="center">Blocks</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">10</td><td align="center">1</td></tr><tr><td align="center">B</td><td align="center">172.16 to 172.31</td><td align="center">16</td></tr><tr><td align="center">C</td><td align="center">192.168.0 to 192.168.255</td><td align="center">256</td></tr></tbody></table><p>这部分的私有地址使得IPv4的网络还能正常运行</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-数据链路层服务</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>术语：</p><ul><li><p>主机和路由器：结点（nodes）</p></li><li><p>连接相邻结点的通信信道：链路(links)</p><ul><li>有线链路(wired links)</li><li>无线链路(wireless links)</li><li>局域网(LANs)</li></ul></li><li><p>链路层(第2层)数据分组：帧(frame),封装网络层数据报</p></li></ul><blockquote><p><strong>数据链路层</strong>负责实现通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传输数据报</p></blockquote><h2 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h2><p>组帧(framing)</p><ul><li><p>封装数据报文构成数据帧，加上首部和尾部</p></li><li><p>帧同步</p></li></ul><p>在数据帧的首位加上特殊的字符</p><p>链路接入(link access)</p><p>如果是共享介质，需要解决信道接入(channel access)</p><p>帧首部中的”MAC”地址，用于标识帧的源和目的</p><ul><li>不同于IP地址！</li></ul><p>相邻结点之间可靠交付</p><p>无线链路: 误码率高，需要可靠交付</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-应用层学习笔记</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 应用层 [[计算机网络]]<h2 id="章节分段"><a href="#章节分段" class="headerlink" title="章节分段"></a>章节分段</h2><ol><li><p>C&#x2F;S模式，P2P模式</p></li><li><p>讨论客户-服务器模式的概念以及这个模式是如何为英特网用户提供服务的</p></li><li><p>讨论客户-服务器模式的预定义和标准应用。（万维网、文件传输、电子邮件）</p></li><li><p>对等模式中的概念以及协议。以及协议的流行应用</p></li><li><p>给出在客户-服务器模式下怎么通过C语言编写两个程序创建一个新的应用</p></li></ol><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可以把应用层的功能看作是两个应用层之间假设存在一个<code>假想的直接连接</code>，通过这个链接可以发送和接收报文。</p><p>因特网为全世界用户提供服务。<code>层次结构</code>使得因特网比其他网络更加灵活，在一层增加协议的时候要观察是不是使用了底层提供的服务；在一层删去协议的时候要关注上层是不是使用了该协议，并改写上一层的协议。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-数据报网络</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><p>数据报网络和虚电路网络的最大区别就是有连接和无连接</p><p>网络层无连接</p><p>每个分组携带目的地址</p><h3 id="路由器根据分组的目的地址转发分组"><a href="#路由器根据分组的目的地址转发分组" class="headerlink" title="路由器根据分组的目的地址转发分组"></a><strong>路由器根据分组的目的地址转发分组</strong></h3><ul><li>基于路由协议&#x2F;算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路<ol><li>发送数据报</li><li>接收数据报</li></ol></li></ul><h2 id="数据报转发表"><a href="#数据报转发表" class="headerlink" title="数据报转发表"></a>数据报转发表</h2><p>路由算法（协议）<strong>确定通过网络的端到端路径</strong></p><p>转发表确定在本路由器如何转发分组</p><p>:question: 但是有一个问题:question:</p><p>IP地址是一个32位的2进制的数，所以可能的IP地址有40多亿</p><p><strong>针对地址范围</strong></p><p>意味着之在一个地址范围内的数据报在一个输出链路上进行展示，将列表的地址进行了聚合</p><p>不同的IP地址通过不同的范围来确定不同的链路接口</p><p><strong>在实际的网络中地址的划分其实并不完美</strong></p><h2 id="最长前缀匹配优先"><a href="#最长前缀匹配优先" class="headerlink" title="最长前缀匹配优先"></a>最长前缀匹配优先</h2><p>例如</p><table><thead><tr><th align="center">目的地址范围</th><th align="center">链路接口</th></tr></thead><tbody><tr><td align="center">11001000 00010111 00010### #########</td><td align="center">0</td></tr><tr><td align="center">11001000 00010111 00011000 #########</td><td align="center">1</td></tr><tr><td align="center">11001000 00010111 00011### #########</td><td align="center">2</td></tr><tr><td align="center">其他</td><td align="center">3</td></tr></tbody></table><p>DA： 11001000 00010111 00010&#x3D;&#x3D;110 10100001&#x3D;&#x3D; <strong>从哪个接口转发？</strong>&#x3D;&#x3D;A : 0&#x3D;&#x3D;</p><p>只有所有的入口都匹配不成功的时候才会进入默认路径  </p><p>DA:   11001000 00010111 00011&#x3D;&#x3D;000 10101010&#x3D;&#x3D; <strong>从哪个接口转发？</strong> &#x3D;&#x3D;A ：1&#x3D;&#x3D;</p><p>匹配前面的前缀越多，越长，描述的范围就越小，网络就越小；匹配前面的前缀越短，网络就越大。所以我们应该将数据报送到更具体的端口上。<strong>所以就应该选择1号接口进行转发</strong>。</p><p>称之为： <strong>最长前缀匹配优先原则</strong></p><blockquote><p>[!最长前缀匹配优先原则]</p><p>在检索转发表的时候，优先选择和分组目的地址匹配前缀最长的入口(entry)</p></blockquote><h2 id="数据报网络-or-VC网络"><a href="#数据报网络-or-VC网络" class="headerlink" title="数据报网络 or VC网络"></a>数据报网络 or VC网络</h2><h3 id="Internet-数据报网络"><a href="#Internet-数据报网络" class="headerlink" title="Internet 数据报网络"></a>Internet 数据报网络</h3><h4 id="简化网络-复杂“边缘”"><a href="#简化网络-复杂“边缘”" class="headerlink" title="简化网络 复杂“边缘”"></a>简化网络 复杂“边缘”</h4><p><strong>计算机之间的数据交换</strong></p><p>“弹性”服务，没有严格的时间需求</p><p>链路类型众多</p><ul><li><p>特点性能各异</p></li><li><p>统一服务比较困难</p></li></ul><p></p><hr><h3 id="ATM-VC网络"><a href="#ATM-VC网络" class="headerlink" title="ATM VC网络"></a>ATM VC网络</h3><h4 id="简化“边缘”，复杂网络"><a href="#简化“边缘”，复杂网络" class="headerlink" title="简化“边缘”，复杂网络"></a>简化“边缘”，复杂网络</h4><p><strong>电话网络演变而来</strong></p><p>核心业务是实时对话：</p><ul><li>严格的时间、可靠性需求</li><li>需要有保障的服务</li></ul><p>“哑（dumb）”端系统（非智能）</p><ul><li>电话机</li><li>传真机</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-差错编码</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B7%AE%E9%94%99%E7%BC%96%E7%A0%81/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B7%AE%E9%94%99%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="差错检测：差错编码"><a href="#差错检测：差错编码" class="headerlink" title="差错检测：差错编码"></a>差错检测：差错编码</h2><p>差错编码基本原理：</p><p>$D \to DR$ 其中R为差错检测和纠正bit（冗余bit）</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030135954.png" alt="image.png"></p><p>如果是没有出错的就直接还原就好</p><p>但是即便判断出当前的R一致，也不能保证一定可靠</p><h3 id="差错编码的检错能力"><a href="#差错编码的检错能力" class="headerlink" title="差错编码的检错能力"></a>差错编码的检错能力</h3><p>差错编码可以分为检错码和纠错码</p><p>对于检错码，如果编码集的汉明距离$d_s &#x3D; r+1$ 那么差错编码可以检测r位的差错。</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030141008.png" alt="image.png"></p><p>例如，编码集{0000,0101,1010,1111}的汉明距离$d_s$&#x3D;2，可以100%检测1比特差错</p><p>对于纠错码，如果编码集的汉明距离$d_s$&#x3D;2r+1，则该差错编码可以纠正r位的差错</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030141157.png" alt="image.png"><br>例如，编码集{000000,010101,101010,111111} 的汉明距离$d_s$&#x3D;3可以纠正1比特差错，如100010纠正为101010。</p><h2 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h2><p>1bit校验位：</p><ul><li>检测奇数位差错</li></ul><p>编码的效率很高</p><p>二维奇偶校验</p><p>检测奇数位的差错：部分偶数位的差错</p><p>纠正同一行&#x2F;列的奇数位错误</p><h2 id="Internet校验和"><a href="#Internet校验和" class="headerlink" title="Internet校验和"></a>Internet校验和</h2><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端:"></a>发送端:</h3><p>将数据（校验内容）划分为16位的二进制整数序列</p><p>求和</p><p>校验和</p><p>放入分组</p><h3 id="接收端："><a href="#接收端：" class="headerlink" title="接收端："></a>接收端：</h3><p>和发送端相同的算法进行计算</p><p>计算得到checksum</p><h2 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h2><p>检错能力更强大的校验编码</p><p>将数据bit，D，视为一个二进制数</p><p>选择一个r+1位的比特模式（生成bit模式）</p><p>目标：选择r位的CRCbit，R，满足</p><ul><li><p>&lt;D,R&gt; 刚好可以被G整除</p></li><li><p>接收端检错：利用G除&lt;D,R&gt;,余式全为0，无错；否则，有错！</p></li><li><p>可以检测所有突发长度小于r+1位差错</p></li></ul><h3 id="广泛应用于实际网络-以太网，802-11-WIFI，ATM"><a href="#广泛应用于实际网络-以太网，802-11-WIFI，ATM" class="headerlink" title="广泛应用于实际网络(以太网，802.11 WIFI，ATM)"></a>广泛应用于实际网络(以太网，802.11 WIFI，ATM)</h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030142849.png" alt="image.png"></p><p>期望：</p><p>$D \cdot 2^r \ XOR &#x3D; \ nG$</p><p>相当于如果利用G去去除$D \cdot 2^r$，则余式即为R：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030143054.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-层次化路由</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B1%82%E6%AC%A1%E5%8C%96%E8%B7%AF%E7%94%B1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B1%82%E6%AC%A1%E5%8C%96%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>将任意规模的网络抽象为一个图计算路由-过于理想化</p><ul><li><p>表示所有的路由器</p></li><li><p>“扁平”网络</p></li></ul><p>——在实际的网络中不可行！</p><p>网络规模：考虑6个亿的结点的网络</p><p>路由表几乎无法存储</p><p>路由计算过程的信息</p><p>链路状态分组，交换量巨大，会淹没链路</p><p><strong>管理自治</strong>：每个网络的管理可能都期望自主控制其网内的路由。</p><p>互联网（internet）&#x3D; 网络之网络</p><h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>聚合路由器为每一个区域：自治系统AS(autonomous systems)</p><p>同一AS内的路由器运行相同的路由算法</p><p><strong>自治系统内部路由协议</strong></p><p>不同的额自治系统内的路由器可以运行不同的AS内部路由协议</p><h3 id="网关路由器"><a href="#网关路由器" class="headerlink" title="网关路由器"></a>网关路由器</h3><p>位于AS边缘</p><p>通过链路连接其他AS网关路由器 可以和其他的网关路由器之间交换信息</p><h3 id="互联的AS"><a href="#互联的AS" class="headerlink" title="互联的AS"></a>互联的AS</h3><p>一方面要通过自治系统来决定AS间的路由算法来共同配置</p><ul><li>AS内部的路由算法设置AS内部目的网络路由入口(entries) </li><li>AS内部路由算法和AS间的路由算法共同设置AS外部网络路由入口</li></ul><h2 id="自治系统内的路由任务"><a href="#自治系统内的路由任务" class="headerlink" title="自治系统内的路由任务"></a>自治系统内的路由任务</h2><p>假设AS1内部的某个路由器收到一个目的地址在AS1之外的数据报：</p><ul><li>路由器应该将该数据包转发给哪个网关路由器呢？</li></ul><h3 id="AS1（其中一个自治系统）必须："><a href="#AS1（其中一个自治系统）必须：" class="headerlink" title="AS1（其中一个自治系统）必须："></a>AS1（其中一个自治系统）必须：</h3><ol><li><p>学习到哪些目的网络可以通过AS2到达，哪些可以通过AS3到达</p></li><li><p>将这些网络可达性信息传播给AS1内部路由器</p></li><li><p>自治系统间的路由任务！</p></li></ol><p>路由器1d的转发表设置</p><p>假设AS1学习到(通过AS间的路由协议)：子网X可以通过AS3（网关1C）到达，但是不呢个通过AS2到达</p><ul><li>AS间路由协议向所有内部路由器传播可达性信息</li></ul><p>路由器1d：利用AS内部路由信息，确定其到达1c的最小费用路径接口</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029222810.png" alt="image.png"></p><h2 id="在多个AS之间选择"><a href="#在多个AS之间选择" class="headerlink" title="在多个AS之间选择"></a>在多个AS之间选择</h2><p>假设AS1通过AS间的路由协议学习到：子网X通过AS3和AS2均可以到达</p><p>为了配置转发表，路由器1d必须确定应该将去往子网X的数据包转发给哪个网关？</p><ul><li>这个任务也是由AS之间的路由协议完成！</li></ul><p><strong>热土豆路由</strong>：将分组发送给最近的网关路由器</p><blockquote><p>[!过程]</p><ol><li>通过AS间的路由协议学习到：子网X可以通过多个网关到达</li><li>利用通过AS内路由协议获得的路悠悠喜喜确定到达每个网关的最小费用的费用</li><li>热土豆路由：选择最小费用路径的费用最小的网关</li><li>通过转发表，确定去往最小费用网关的接口&#x2F;.在转发表中增加入口：（x,l）</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-分组交换网络中的时延、丢包和吞吐量</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>分组交换网络的时延最重要的是 <strong>节点处理时延</strong>，<strong>排队时延</strong>，<strong>传输时延</strong>，<strong>传播时延</strong></p><p>这些时延加起来的总和就是 <strong>节点总时延</strong></p><h2 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h2><p>检查分组首部和决定该分组到向何处所需要的时间是处理时延的一部分。<br>也包括其他因素，比如检查 <strong>比特级别的差错</strong><br>高速路由器的处理时延通常是微秒或者更低的数量级。</p><h2 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h2><p>在队列中，分组在链路上等待传输的时候，它经受排队时延。</p><p>一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量</p><p>到达分组期待发现的返祖数量是到达该队列的流量的强度和性质的函数。实际的排队时延可以是毫秒到微妙量级</p><h2 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h2><p>假定分组以先到先服务的方式传输——这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输之后，才能传输刚到到达的分组。</p><h2 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h2><p>传播时延是信号通过的路程的长度，为$d&#x2F;s$</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-传输层学习笔记</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>传输层位于应用层和网络层之间。在两个<code>应用层之间</code>提供进程到进程服务，一个进程在<strong>本地主机</strong>，另一个在<strong>远程主机</strong>，使用逻辑链接提供通信。</p><h3 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h3><p><strong>传输层负责向应用层提供服务</strong></p><h4 id="进程到进程通信"><a href="#进程到进程通信" class="headerlink" title="进程到进程通信"></a>进程到进程通信</h4><p><strong>首要任务</strong>：进程到进程通信（process-to-process communicaiton）</p><p><strong>进程</strong>：使用传输层服务的应用层实体（运行的程序）</p><p><strong>主机到主机 vs 进程到进程</strong>：</p><ul><li><code>网络层</code>可以负责主机到主机的通信。网络层协议只把报文传递给目的计算机，但是这不是完整的传输。</li><li>报文要递交给正确的进程  $\rightarrow$ <em><u>传输层接管的部分</u></em></li></ul><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694499016606.png" alt="1694499016606" style="zoom:67%;" /><h4 id="寻址：端口号"><a href="#寻址：端口号" class="headerlink" title="寻址：端口号"></a>寻址：端口号</h4><p>最常用的方式实现进程到进程通信：<strong>客户-服务器模式</strong></p><p>两个进程有相同的名字: </p><p>ex. (client)Daytime $\iff$ (remote)Daytime </p><p>远程计算机可以<code>运行多个服务器程序</code>，就像许多本地计算机可以在同一时间运行一个或者多个客户应用程序一样。</p><p>通信：需要 <strong>本地主机</strong>、<strong>本地进程</strong>、<strong>远程主机</strong>、<strong>远程进程</strong></p><p><em>Chapter 4 mention</em>: 用<code>IP地址</code>来定义本地主机和远程主机</p><p>服务器进程必须用一个<code>端口号</code>定义自己。端口号 &#x3D; 0~65535之间的16位整数</p><p>客户程序用端口号来定义自己，称为<strong>临时端口号</strong>。临时是因为客户的生命周期通常很短。临时端口号大于1023。</p><p><strong>熟知端口号</strong>：全局端口号</p><p>每一个客户进程都知道相应服务器进程的数值端口号。</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694500506986.png" alt="1694500506986"></p><h4 id="ICANN范围"><a href="#ICANN范围" class="headerlink" title="ICANN范围"></a>ICANN范围</h4><p>把端口号划分成为三种范围：熟知的、注册的、动态的（或者私有的）</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694502306396.png" alt="1694502306396"></p><p><strong>熟知端口</strong>：端口号范围是1~1023，<strong>由ICANN分配和控制</strong>，这些事熟知的端口号</p><p><strong>注册端口</strong>：端口号的范围是1024~49151。<strong>ICANN不分配也不控制</strong>，它们可以在ICANN注册以免重复。</p><p><strong>动态端口</strong>：可以由任何进程使用，是临时或者私有端口号。</p><p><em>套接字地址</em></p><p>TCP协议簇中的传输层协议需要IP地址和端口号，它们各在一端建立一条连接。一个IP地址和一个端口号结合起来就称为<strong>套接字地址</strong>（socket address），<strong>客户套接字地址</strong><code>唯一</code>定义了<code>客户的进程</code>，而<strong>服务器套接字地址</strong>唯一的定义了<code>服务器进程</code>。</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694502647464.png" alt="1694502647464"></p><p><strong>一对套接字地址</strong>：客户套接字地址和服务器套接字地址。这四条信息是网络层分组头部和传输层分组头部的组成部分。</p><p>这四条信息是网络层分组头部和传输层分组头部的组成部分。第一个头部包含IP地址，第二个头部包含端口号。</p><h3 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h3><p>将报文从一个进程发送到另一个进程，传输层协议负责封装报文。</p><p>传输层的分组称为<code>用户数据报</code>、<code>段</code>、<code>分组</code></p><p>在一般讨论中，将传输层有效载荷称为分组。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-以太网</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>”统治地位“的有线LAN技术</p><p>造价低廉</p><p>应用最广泛的LAN技术</p><p>比令牌局域网和ATM等更简单、便宜</p><p>满足网络速率需求：10Mbps ~ 10Gbps</p><h2 id="以太网：物理拓扑"><a href="#以太网：物理拓扑" class="headerlink" title="以太网：物理拓扑"></a>以太网：物理拓扑</h2><h3 id="总线（bus）"><a href="#总线（bus）" class="headerlink" title="总线（bus）"></a>总线（bus）</h3><p>总线：上世纪90奶奶带中期之前流行</p><p>所有节点在同一个冲突域内（可能产生冲突）</p><h3 id="星型（star）"><a href="#星型（star）" class="headerlink" title="星型（star）"></a>星型（star）</h3><p>中心交换机</p><p>每个节点一个单独的冲突域（结点之间彼此不冲突）</p><h2 id="以太网：不可靠无连接服务"><a href="#以太网：不可靠无连接服务" class="headerlink" title="以太网：不可靠无连接服务"></a>以太网：不可靠无连接服务</h2><p><strong>无连接</strong>：发送帧的网课和接收帧的网卡之间没有”握手“过程</p><p><strong>不可靠</strong>：接收网课不向发送网卡进行确认</p><ul><li>差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议（TCP），否则，发生数据丢失</li></ul><p>以太网的MAC协议：采用二进制指数退避算法的CSMA&#x2F;CD</p><h2 id="以太网的CSMA-CD算法"><a href="#以太网的CSMA-CD算法" class="headerlink" title="以太网的CSMA&#x2F;CD算法"></a>以太网的CSMA&#x2F;CD算法</h2><ol><li>NIC从网络层接收数据报，创建数据帧；</li><li>监听信道：<br>如果NIC监听到信道空闲，就开始发送数据帧</li><li>NIC发送完整个帧，而没有检测到其他结点的数据发送，则NIC确认帧发送成功</li><li>如果NIC检测到其他结点传输数据，则中止发送并发送堵塞信号 (jamsignal)</li><li>中止发送后，NIC进入二进制指数退避:<ul><li>第m次连续冲突之后：<ul><li>n &#x3D; Max(m,10)</li><li>NIC 从{}0，1，2，……，$2^n$-1}中随机的选择一个数K</li><li>NIC等待K·512比特的传输延迟时间，再返回第2步</li></ul></li><li>连续冲突次数越多，平均等待时间越长。</li></ul></li></ol><p>发送端</p><h2 id="以太网的帧结构"><a href="#以太网的帧结构" class="headerlink" title="以太网的帧结构"></a>以太网的帧结构</h2><p>发送端网卡将IP数据报(或其他网络层协议分组)封装到以太网帧中：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101213538.png" alt="image.png"></p><h3 id="前导码-Preamble-8B"><a href="#前导码-Preamble-8B" class="headerlink" title="前导码(Preamble)(8B)"></a>前导码(Preamble)(8B)</h3><p>7个字节的10101010，第8字节为10101011<br>用于发送端与接收端的时钟同步</p><h3 id="目的MAC地址、源MAC地址-各6B"><a href="#目的MAC地址、源MAC地址-各6B" class="headerlink" title="目的MAC地址、源MAC地址(各6B)"></a>目的MAC地址、源MAC地址(各6B)</h3><p>如果网卡的MAC地址与收到的倾的目的MAC地址匹配，或者顿的目的MAC地址为广播地址(FF-FF-FF-FF-FF-FF)，则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议。</p><h3 id="类型-Type-2B"><a href="#类型-Type-2B" class="headerlink" title="类型(Type)(2B)"></a>类型(Type)(2B)</h3><p>指示中封装的是哪种高层协议的分组(如，IP数据报、Novell IPX数据报、AppleTalk数据报等)</p><h3 id="数据-Data-46-1500B-指上层协议载荷"><a href="#数据-Data-46-1500B-指上层协议载荷" class="headerlink" title="数据(Data)(46-1500B): 指上层协议载荷"></a>数据(Data)(46-1500B): 指上层协议载荷</h3><p>R&#x3D;10Mbps，RTTmax&#x3D;512$\mu s$，Lmin &#x2F; R &#x3D; RTTmax<br>in&#x3D;512bits&#x3D;64B，Datamin&#x3D;Lmin-18&#x3D;46B</p><h3 id="CRC-4B-循环余校验码"><a href="#CRC-4B-循环余校验码" class="headerlink" title="CRC(4B): 循环余校验码"></a>CRC(4B): 循环余校验码</h3><p>丢弃差错帧</p><h2 id="802-3以太网标准：链路和物理层"><a href="#802-3以太网标准：链路和物理层" class="headerlink" title="802.3以太网标准：链路和物理层"></a>802.3以太网标准：链路和物理层</h2><p>许多不同的以太网标准</p><ul><li>相同的MAC协议和帧格式</li><li>不同速率: 2 Mbps,10 Mbps,100 Mbps，1 Gbps, 10 Gbps</li><li>不同物理介质: 光纤,线缆</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-交换机</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BA%A4%E6%8D%A2%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>链路层设备</p><ul><li>存储-转发以太网帧</li><li>检验到达帧的目的MAC地址，选择性(selectively) 向一个或多个输出链路转发帧</li><li>利用CSMA&#x2F;CD访问链路，发送帧</li></ul><p>透明(transparent)</p><ul><li>主机感知不到交换机的存在</li></ul><p>即插即用(plug-and-play)</p><p>自学习(self-learning)</p><ul><li>交换机无需配置</li></ul><h2 id="交换机：多端口之间同时传输"><a href="#交换机：多端口之间同时传输" class="headerlink" title="交换机：多端口之间同时传输"></a>交换机：多端口之间同时传输</h2><p>主机利用独享(dedicated)链路直接连接交换机</p><p>交换机缓存帧</p><p>交换机在每段链路上利用CSMA&#x2F;CD收发帧，但无冲突，且可以全双工</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101214415.png" alt="image.png"></p><p><strong>交换(switching)</strong>:A-A’与B-B’的传输可以同时进行，没有冲突</p><h2 id="交换机转发表：交换表"><a href="#交换机转发表：交换表" class="headerlink" title="交换机转发表：交换表"></a>交换机转发表：交换表</h2><p>Q: 交换机怎么知道A’可以通过接口4到达，而B’可以通过接口5到达?</p><p>A: 每个交换机有一个交换表(switch table), 每个入口(entry):</p><ol><li>(主机的MAC地址，到达主机的接口,时间戳)</li><li>看起来很像路由表!</li></ol><p>Q: 交换表入口信息如何创建和维护的?类似于路由协议?</p><h2 id="交换机：自学习"><a href="#交换机：自学习" class="headerlink" title="交换机：自学习"></a>交换机：自学习</h2><p>交换机通过自学习，获知到达主机的接口信息</p><ul><li><p>当收到顿时，交换机“学习”到发送顿的主机(通过顿的源MAC地址)，位于收到该顿的接口所连接的LAN网段</p></li><li><p>将发送主机MAC地址&#x2F;接口信息记录到交换表中</p></li></ul><h2 id="交换机：帧过滤-转发"><a href="#交换机：帧过滤-转发" class="headerlink" title="交换机：帧过滤&#x2F;转发"></a>交换机：帧过滤&#x2F;转发</h2><p>当交换机收到帧:</p><ol><li><p>记录帧的源MAC地址与输入链路接口</p></li><li><p>利用目的MAC地址检索交换表</p></li><li><p>if 在交换表中检索到与目的MAC地址匹配的入口(entry)<br>then {<br>if 目的主机位于收到帧的网段<br>then 丢弃帧<br>else 将帧转发到该入口指向的接口<br>}<br> else 泛洪(flood)</p></li></ol><h2 id="自学习和转发过程举例"><a href="#自学习和转发过程举例" class="headerlink" title="自学习和转发过程举例"></a>自学习和转发过程举例</h2><p>假设交换表初始的时候为空。</p><p>目的MAC地址A’，位置未知:泛洪</p><p>目的MAC地址A，位置已知:选择性转发</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101215158.png" alt="image.png"></p><h2 id="交换机互联"><a href="#交换机互联" class="headerlink" title="交换机互联"></a>交换机互联</h2><p>交换机可以互联</p><p>层级结构</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101215252.png" alt="image.png"></p><p>交换机可以互联</p><p>Q: 当A向G发送帧时，S1怎么知道通过S4转发?S4又怎么知道通过S3,转发?</p><p>A：自学习!(工作过程与单一交换机情形相同!)</p><p>Q: 请给出S,S,S,S的交换表，并说明帧的转发过程?</p><h2 id="组织机构-Institutional-网络"><a href="#组织机构-Institutional-网络" class="headerlink" title="组织机构(Institutional)网络"></a>组织机构(Institutional)网络</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101215459.png" alt="image.png"></p><p>称这个IP子网为广播域</p><h2 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h2><p>两者均为存储-转发设备：<br>路由器: 网络层设备(检测网络层分组首部)<br>交换机: 链路层设备(检测链路层帧的首部)</p><p>二者均使用转发表:<br>路由器: 利用路由算法(路由协议)计算(设置), 依据IP地址<br>交换机: 利用自学习、泛洪构建转发表，依据MAC地址</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101220011.png" alt="image.png"></p><h2 id="网络设备对比"><a href="#网络设备对比" class="headerlink" title="网络设备对比"></a>网络设备对比</h2><table><thead><tr><th align="left"></th><th align="left">集线器</th><th align="left">交换机</th><th align="left">网桥</th><th align="left">路由器</th></tr></thead><tbody><tr><td align="left">层次</td><td align="left">1</td><td align="left">2</td><td align="left">3</td><td align="left">4</td></tr><tr><td align="left">流量</td><td align="left">no</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">广播域隔离</td><td align="left">no</td><td align="left">no</td><td align="left">no</td><td align="left">yes</td></tr><tr><td align="left">即插即用</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">优化路由</td><td align="left">no</td><td align="left">no</td><td align="left">no</td><td align="left">yes</td></tr><tr><td align="left">直通传输</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">no</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week8-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week8-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week8-Class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p><strong>通过DHCP动态分配IP地址过程中需要交换哪些DHCP报文？这些报文直接封装到哪个协议的数据包中？封装这些报文的IP数据包的目的IP是什么？为什么？</strong> </p><p>在DHCP动态分配IP地址过程中，需要交换以下几种DHCP报文：</p><ol><li>DHCP发现报文（DHCP Discover）：客户端发送此报文以发现可用的DHCP服务器。</li><li>DHCP提供报文（DHCP Offer）：DHCP服务器在收到DHCP发现报文后，向客户端发送此报文，提供可用的IP地址租约。</li><li>DHCP请求报文（DHCP Request）：客户端在收到DHCP提供报文后，向选定的DHCP服务器发送此报文，请求分配给自己的IP地址。</li><li>DHCP确认报文（DHCP Acknowledgement）：DHCP服务器在收到DHCP请求报文后，向客户端发送此报文，确认分配给客户端的IP地址租约。<br>这些DHCP报文被封装在IP数据包中，使用的是UDP协议。UDP协议位于IP协议之上，为DHCP报文提供可靠的数据传输。<br>封装这些DHCP报文的IP数据包的目的IP是广播地址（255.255.255.255），因为客户端在初始化阶段没有分配的IP地址，所以只能使用广播地址发送DHCP报文，以便DHCP服务器能够接收并回复。通过使用广播地址，确保DHCP服务器能够接收到相应的报文，进而进行IP地址的分配和交换。</li></ol><p><strong>一个路由器在转发IP分组的时候IP分组的哪些字段会发生修改？如何修改？</strong> </p><p>在转发IP分组时，路由器会根据目标IP地址和路由表进行转发决策，并且可能会修改IP分组的一些字段。被修改的字段包括：</p><ol><li>TTL字段：TTL（Time to Live）字段表示IP分组在网络中能够经过的最大跳数，每经过一个路由器，TTL字段的值会减一。路由器在转发IP分组时，会将TTL减一，并重新计算校验和。</li><li>源IP地址字段：通常情况下，路由器不会修改源IP地址字段，它会保留原始的源IP地址。</li><li>目标IP地址字段：路由器会根据目标IP地址进行转发决策，并将目标IP地址字段更新为下一跳路由器的IP地址。</li><li>校验和字段：路由器在转发IP分组时，会重新计算校验和字段，以保证数据完整性。<br>以上是常见的修改字段的情况，实际上，路由器在转发IP分组时可能还会修改其他字段，具体修改方式取决于路由器的配置和网络环境。</li></ol><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231019110039.png" alt="image.png" style="zoom:50%;" /><p><strong>如果两个均使用私有IP地址的主机需要进行P2P通信？可能会遇到什么问题？怎么解决？</strong> </p><p>如果两个均使用私有IP地址的主机需要进行P2P通信，可能会遇到以下问题：</p><ol><li>NAT（网络地址转换）阻止了直接的通信：私有IP地址不能在Internet上直接路由。当两个主机试图通过NAT网关进行通信时，通常会被NAT阻止。</li><li>防火墙阻塞了P2P连接：防火墙可能会屏蔽P2P连接，以保护网络的安全性。</li></ol><p>为了解决这些问题，可以采取以下方法：</p><ol><li>使用UPnP（通用即插即用）：通过启用UPnP功能，可以自动配置NAT设备，允许P2P通信。</li><li>使用端口映射：将P2P应用程序使用的端口映射到NAT设备上。这样，P2P通信的数据包就可以正确地路由到私有IP地址的主机。</li><li>使用中继服务器：如果两个主机无法直接通信，可以借助第三方中继服务器来中转通信。中继服务器将两个主机之间的数据包进行转发，使得通信得以建立。</li><li>穿越防火墙：使用一些特殊技术和协议，如STUN、TURN和ICE等，可以在防火墙后建立P2P连接，使得私有IP地址的主机能够直接通信。</li></ol><p>请注意，每种方法的适用性和实施方式可能因网络环境和设备配置而异。具体的实施需要根据实际情况进行调整。</p><h2 id="NAT穿透问题"><a href="#NAT穿透问题" class="headerlink" title="NAT穿透问题"></a>NAT穿透问题</h2><p>一定会有在外面有公网地址，在支持NAT的另一端，这时候需要转换。但是这是一个一对多的问题，因为私网IP是可以重复的，所以需要端口来辅助完成区别。静态配置：端口映射。</p><p>某校园网有两个局域网，通过路由器R1&#x2F;R2&#x2F;R3互联之后接入Internet,S1和S2为以太网交换机，局域网采用静态IP地址配置。</p><ol><li>为了让H2和H3能够访问Web服务器，R2需要进行什么配置？</li></ol><p><strong>可以利用ICMP协议实现哪些网络监测功能？怎么实现？</strong> </p><p>ICMP协议可以实现以下网络监测功能：</p><ol><li><p><strong>Ping（网络连通性测试）</strong>：使用ICMP Echo请求消息来检测目标主机是否在线。Ping命令发送ICMP Echo请求消息到目标主机，目标主机接收到请求后返回ICMP Echo应答消息。</p></li><li><p><strong>Traceroute（路径追踪）</strong>：通过使用ICMP的Time-to-Live（TTL）字段，从源主机向目标主机发送一系列的UDP数据包。每个数据包在传输过程中的路由器都会将TTL减少，直到它达到0并被丢弃。源主机通过检测收到的ICMP TTL超时消息来确定数据包传输路径。</p></li><li><p><strong>ICMP Jitter（延迟测量）</strong>：利用ICMP消息的传输延迟来测量网络性能。通过发送ICMP Echo请求消息并记录请求发送和接收之间的时间差来获取延迟信息。</p></li></ol><p>实现上述功能的方法如下：</p><ul><li><p>Ping：使用ping命令或编写程序发送ICMP Echo请求消息，并接收目标主机的ICMP Echo应答消息。</p></li><li><p>Traceroute：使用traceroute命令或编写程序发送一系列的UDP数据包，并监听接收到的ICMP TTL超时消息，记录路由路径。</p></li><li><p>ICMP Jitter：通过编写程序发送ICMP Echo请求消息，并记录请求发送和接收之间的时间差，计算延迟值。</p></li></ul><p>参考来源：</p><ul><li><p><a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html">ICMP协议简介</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/369623317">ICMP协议的应用</a></p></li></ul><p>距离向量路由算法可能产生什么问题，怎么会发生这样的问题？怎么消除这个问题？  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week9-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week9-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week9-Class/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>以太网中采用二进制指数后推算法处理冲突问题。</p><p>链路层能够提供的可能服务有哪些？其中可靠传输服务，在传输层也同样提供，那么链路层的可靠传输服务是不是必要？传输层的可靠传输理论以及方法是否适用于链路层？ </p><p>链路层能够提供的可能服务包括以下几个方面：</p><ol><li><p>提供透明可靠的数据传输服务：链路层向网络层提供了透明可靠的数据传输服务，确保数据能够从发送方传输到接收方。</p></li><li><p>差错检测和纠正：链路层通过使用差错检测和纠正方法，对传输过程中可能出现的错误进行检测和纠正，从而保证数据传输的可靠性。</p></li><li><p>帧同步和流量控制：链路层在数据传输过程中能够进行帧同步和流量控制，确保数据的顺序和速率统一。</p></li></ol><p>传输层也可以提供可靠传输服务，但链路层的可靠传输服务并不是必要的。传输层的可靠传输服务更加高级和复杂，可以处理端到端的可靠传输问题。</p><p>传输层的可靠传输理论和方法并不一定适用于链路层。链路层的可靠传输服务更加专注于在链路层中处理数据传输的可靠性，与传输层的可靠传输服务有所不同。链路层使用的纠错方法和协议可能与传输层不同，具体取决于传输介质和网络需求。</p><p>为什么同时使用MAC地址和IP地址？为什么不止使用MAC地址或者只使用IP地址？</p><p>如何实现差错控制(差错纠正策略)？可以采用哪些协议？ </p><p>差错控制是为了处理在数据传输过程中可能发生的差错，包括差错检测和差错纠正。可以采用以下策略实现差错控制：</p><ol><li><p>差错检测：通过添加冗余信息来判断数据是否遭到损坏。</p><ul><li><p>校验和：将数据划分为多个块，并计算每个块的和，将和值附加到数据中。</p></li><li><p>循环冗余检验 (CRC)：使用多项式除法来计算校验码，并将其附加到数据中。</p></li></ul></li><li><p>差错纠正：不仅能检测出差错，还能进行纠正。</p><ul><li><p>汉明码：通过在数据中添加冗余位来纠正错误，并检测出多位错误。</p></li><li><p>奇偶校验：通过添加一个奇偶位来检测和纠正单个比特错误。</p></li></ul></li></ol><p>差错控制可以应用于不同的协议和通信网络中，包括：</p><ul><li><p>TCP (传输控制协议)：在数据通信过程中通过使用序列号、确认应答和重传机制来实现差错控制。</p></li><li><p>UDP (用户数据报协议)：提供差错检测功能，但不支持差错纠正。</p></li><li><p>ARQ (自动重传请求)：一种协议，通过请求重传错误的数据包来实现差错控制。</p></li></ul><p>来源：</p><ul><li><p><a href="https://baike.baidu.com/item/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/16382947">TCP、UDP与ARQ错误控制</a></p></li><li><p><a href="https://blog.csdn.net/abbcdc/article/details/108737703#pn%EF%BC%81M">差错控制的方法与技术</a></p></li></ul><p>随机访问MAC怎么检测冲突？ </p><p>要检测随机访问MAC的冲突，可以采取以下方法：</p><ol><li><p>使用MAC地址检测工具：可以使用专门的MAC地址检测工具来检测MAC冲突。这些工具可以扫描局域网上的设备，并检查是否有重复的MAC地址。一旦发现重复的MAC地址，就可以确定发生了冲突。</p></li><li><p>查看网络设备日志：路由器或交换机上的日志记录可能会显示有关MAC地址冲突的信息。通过查看日志，可以了解到是否发生了冲突以及冲突的具体信息。</p></li><li><p>使用网络分析工具：可以使用网络分析工具来监测网络流量和活动。这些工具可以检测到连续的MAC冲突，通过分析网络流量，可以确定冲突的设备和触发冲突的原因。</p></li></ol><p>以上是一些常见的检测随机访问MAC冲突的方法，可以根据具体的需求和网络环境选择合适的方法进行检测。</p><p>总结两个轮转访问MAC协议，轮询和令牌传递的共同点和不同点，并设计一个轮转访问的MAC协议？ </p><p>轮询和令牌传递是两种常见的轮转访问MAC协议。它们的共同点是都采用了轮流访问的方式来协调多个设备之间的数据传输。然而，它们在实现细节和工作原理上有一些区别。</p><p>共同点：</p><ol><li><p>轮询和令牌传递都是使用轮流访问的方式，按照特定的顺序依次控制设备的访问，使每个设备都能有机会传输数据。</p></li><li><p>两种协议都能避免设备之间的冲突和碰撞，提高网络的效率。</p></li></ol><p>不同点：</p><ol><li><p>轮询协议是由一个中心设备（通常是主机或主控器）负责控制访问顺序，按照预定的顺序对每个设备进行轮询。而令牌传递协议则是通过传递令牌的方式来控制设备的访问顺序，只有拥有令牌的设备才能传输数据。</p></li><li><p>在轮询协议中，当一个设备完成数据传输后，控制权会立即转移到下一个设备。而在令牌传递协议中，只有拥有令牌的设备才能传输数据，其他设备需要等待令牌传递到自己才能进行传输。</p></li><li><p>轮询协议可以更灵活地控制设备的访问顺序，可以根据设备的优先级或其他因素来调整轮询顺序。而令牌传递协议的访问顺序是固定的，由令牌的传递顺序决定。</p></li></ol><p>设计一个轮转访问的MAC协议：</p><p>以下是一个简单的轮转访问的MAC协议设计示例：</p><ol><li><p>定义一个主控设备，负责控制轮询顺序。</p></li><li><p>所有参与传输的设备按照预定顺序排列，每个设备分配一个唯一的标识符。</p></li><li><p>主控设备按照设备的顺序轮询，依次给每个设备分配传输时间窗口。</p></li><li><p>在每个时间窗口内，设备可以传输数据或请求传输数据。</p></li><li><p>设备根据自己的需求在分配的时间窗口内进行数据传输。</p></li><li><p>主控设备根据轮询顺序不断循环，确保每个设备都有机会传输数据。</p></li><li><p>如果有新设备接入或有设备离开，主控设备需要更新轮询顺序。</p></li></ol><p>这个设计示例基于轮询的方式，通过主控设备控</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week7-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week7-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week7-Class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>Q1: 虚电路的VCID如何取值？在每段物理链路上都相同吗？为什么？ </p><p>VCID的取值方式是由ATM网络设备或协议规范来定义的。通常，VCID的取值范围是0到65535，但具体取值范围可以根据设备和网络配置而有所不同。在同一段物理链路上，不同虚电路的VCID通常是不同的。这是因为VCID的主要作用是用来区分不同的虚电路，如果在同一物理链路上有多个虚电路，它们需要具有不同的VCID，以便网络设备能够正确地路由和交换数据。</p><p>Q2: IP分片在哪里重组？为什么？ </p><p>IP分片是在网络层（第三层）上实现的。当一个IP数据报的大小超过了网络的最大传输单元（MTU）时，它会被分割成更小的片段，以适应网络的限制。每个分片都会被独立地发送到目标主机。IP分片是为了解决不同网络链路上的最大传输单元（MTU）不一致的问题。如果一个IP数据报的大小超过了链路上的MTU，它将被分割成更小的片段进行传输。这样可以确保数据能够通过链路传输，并且在目标主机上进行重组，还原为原始的数据报。</p><p>Q3: 请将192.168.1.0&#x2F;24剩余IP地址分配给局域网1<del>3，其中局域网1需要IP地址数不少于60个，局域网2、3需要IP地址不少于30个。说明局域网1</del>3的子网地址、广播地址、子网掩码、可分配的IP地址数和范围。</p><p>Q4：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231012111929.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week5-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week5-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week5-Class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<blockquote><p>[!QUEATION]<br>TCP如何进行流量控制，可能存在什么问题？</p><ul><li><strong>糊涂窗口综合症</strong>（ <em>Sillly Window Syndrome</em> ）<ul><li>是发送方引起的</li><li>telnet 远程登陆，执行一种远程的终端，过程当中计算机只是作为终端来给远程的服务器交换数据。</li><li>Nagle算法：报文段一定长度之后再发送</li></ul></li></ul></blockquote><p><strong>TCP协议为什么要用三次握手建立连接？四次挥手断开连接？连接建立和断开的过程的序号怎么变化？</strong> </p><p>TCP协议使用三次握手建立连接的主要原因是为了确保双方能够正常通信并同步序号和确认号。三次握手的过程包括：</p><ol><li><p>客户端发送一个SYN包到服务器，其中包含一个初始化的序号（ISN）。</p></li><li><p>服务器收到SYN包后，回复一个SYN-ACK包给客户端，确认连接请求，并为自己建立连接。</p></li><li><p>客户端收到SYN-ACK包后，再发送一个ACK包给服务器，确认收到服务器的确认，并建立连接。</p></li></ol><p>四次挥手用于断开连接时，是因为在客户端请求断开时，服务器可能还有数据未发完，所以需要分开操作：</p><ol><li><p>客户端发送一个FIN包到服务器，请求关闭连接。</p></li><li><p>服务器收到FIN包后，回复一个ACK包给客户端，表示同意对方关闭连接，但服务器可能还有数据需要发送。</p></li><li><p>服务器发送完未发送的数据后，发送一个FIN包给客户端，表示自己也请求关闭连接。</p></li><li><p>客户端收到FIN包后，回复一个ACK包给服务器，确认关闭连接。</p></li></ol><p>在连接建立和断开的过程中，序号的变化如下：</p><ul><li><p>连接建立时，客户端和服务器分别使用随机的初始序号（ISN）作为起始序号。</p></li><li><p>在数据传输过程中，序号根据发送和接收的数据包数量以及数据包的长度进行递增。</p></li><li><p>在连接断开时，通过发送和确认FIN包，最后一个的确认号（ACK）将成为下一个会话的初始序号。</p></li></ul><p>来源：<a href="https://zhuanlan.zhihu.com/p/108504297">TCP三次握手，四次挥手的原理及过程</a></p><p><strong>网络拥塞控制可以有哪些策略？</strong> </p><p>网络拥塞控制可以采用以下策略：</p><ol><li><p>慢开始：慢开始算法的思路是当主机开始发送数据时，先试探一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。<a href="https://blog.csdn.net/qq_27198345/article/details/107848405#:~:text=1%20%E6%85%A2%E5%BC%80%E5%A7%8B%20%EF%BC%9A%E6%85%A2%E5%BC%80%E5%A7%8B%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF%E6%98%AF%E5%BD%93%E4%B8%BB%E6%9C%BA%E5%BC%80%E5%A7%8B%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AB%8B%E5%8D%B3%E6%8A%8A%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%88%B0%E7%BD%91%E7%BB%9C%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BC%95%E8%B5%B7%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%8E%B0%E5%9C%A8%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%E3%80%82%E7%BB%8F%E9%AA%8C%E8%A1%A8%E6%98%8E%EF%BC%8C%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%85%88%E8%AF%95%E6%8E%A2%E7%B4%A2%EF%BC%8C%E5%8D%B3%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E9%80%90%E6%AC%A1%E5%A2%9E%E5%A4%A7%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%E6%95%B0%E5%80%BC%E3%80%82">来源</a></p></li><li><p>拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。<a href="https://zhuanlan.zhihu.com/p/97709686">来源</a></p></li><li><p>快重传与快恢复：快重传（Fast Retransmit）是一种拥塞控制算法，能够快速恢复丢失的数据包。快恢复（Fast Recovery）算法用于在拥塞控制时快速恢复拥塞窗口的值。<a href="https://blog.csdn.net/qq_27198345/article/details/107848405#:~:text=4%20%E5%BF%AB%E5%8E%9F%E5%A4%8D%E5%8E%9F%EF%BC%88Fast%20Recovery%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%8C%E5%AE%83%E8%83%BD%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E3%80%82">来源</a></p></li><li><p>拥塞检测与拥塞通知：拥塞检测与拥塞通知算法用于检测网络中的拥塞和通知相关主机降低数据发送速率。这可以通过网络设备或协议来实现。<a href="https://zhuanlan.zhihu.com/p/28593966">来源</a></p></li></ol><p>请注意，以上策略不是所有的拥塞控制算法都会使用，具体的具体拥塞控制算法有不同的实现方式和策略。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Web缓存</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Web%E7%BC%93%E5%AD%98/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Web%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## Web缓存/代理服务器技术<p>功能<br>    - 能够在不访问服务器的前提下满足客户端的HTTP请求</p><p><strong>为什么要发明这种技术</strong></p><p><span style="color:#61ac85">缩短客户请求的响应时间</span><br><span style="color:#61ac85">减少机构&#x2F;组织的流量</span><br><span style="color:#61ac85">在大范围内(Internet)实现有效的内容分发</span></p><p>Web缓存&#x2F;代理服务器**</p><ul><li>用户设定浏览器通过缓存进行Web访问</li><li>浏览器向缓存&#x2F;代理服务器发送所有的HTTP请求<ul><li>如果锁清秋的对象在缓存中给，缓存返回对象</li><li>否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象<br>缓存既充当客户端，也充当服务器<br>一般由ISP(Internet服务提供商架设)</li></ul></li></ul><h2 id="Web缓存示例"><a href="#Web缓存示例" class="headerlink" title="Web缓存示例"></a><strong>Web缓存示例</strong></h2><p><em>假定：</em></p><ul><li>对象的平均大小是1000，000 bit</li><li>机构网络中的浏览器平均每秒有15个到原始服务器的请求</li><li>从机构路由器到原始服务器的往返延迟&#x3D;2s</li></ul><p><em>网络性能分析</em>：<br>局域网（LAN）的利用率&#x3D; (15个请求&#x2F;s) * (1Mb&#x2F;请求) &#x2F; (100Mbps) &#x3D; 15%<br>然而接入链路上的流量强度为 1<br>接入互联网的链路的利用率 &#x3D; 100%<br>总的延迟 &#x3D; 互联网上的延迟 + 访问延迟 +局域网延迟</p><p><strong>$延迟&#x3D; 2s + n \ min+ m \ ms$</strong></p><p>由于局域网上的强度为0.15的通信量最多导致数毫秒的实验，<strong>我们可以忽略局域网的时延</strong>。</p><p>[[CourseNotes&#x2F;计算机网络&#x2F;CN-分组交换网络中的时延、丢包和吞吐量]]</p><p>由于链路上的时延因为利用率的原因会趋于无穷大，所系选哟改进事件响应特性</p><h3 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h3><p>将链路的速率提高，从15Mbps增加到100Mbps。这样可以将介入链路上的流量强度减少到0.15</p><p><strong>缺点</strong>：代价很高</p><h3 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h3><p>安装Web缓存</p><p>假定缓存命中率是0.4</p><h4 id="网络性能分析"><a href="#网络性能分析" class="headerlink" title="网络性能分析"></a>网络性能分析</h4><p>有40%的请求立即得到满足<br>剩下的60%通过原始服务器满足</p><p>接入互联网的链路的利用率下降到 **60%**，从而其延迟可以忽略不计，例如10微秒</p><p><strong>总的平均延迟</strong>：$互联网上的延迟+访问延迟+局域网延迟 &#x3D; 0.6 \times 2.01s +0.4 \times n \ ms &lt;1.4 s$</p><p><strong>内容分发网络</strong>（Content Distribution Network,CDN）</p><h2 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h2><p>景观高速缓存能够减少用户感受到的响应时间，但是也引入了一个新的问题</p><p><strong>数据一致性问题</strong></p><p>HTTP协议有一种机制，允许缓存器确定它的对象是最新的。</p><h3 id="条件Get方法（Conditional-GET）"><a href="#条件Get方法（Conditional-GET）" class="headerlink" title="条件Get方法（Conditional GET）"></a>条件Get方法（Conditional GET）</h3><p>如果：</p><ol><li>请求报文使用的是GET方法</li><li>请求报文中包含一个<code>if-Modified-Since</code>的首部行</li></ol><p>那么这个HTTP报文就是一个条件GET报文</p><h3 id="条件GET方法的操作方式"><a href="#条件GET方法的操作方式" class="headerlink" title="条件GET方法的操作方式"></a>条件GET方法的操作方式</h3><p>一个代理缓存我器代表一个请求浏览器</p><p>向某Web服务器发送一个请求报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTP/1.1</span><br><span class="line">Bost: www.exotiquecuisine.com</span><br></pre></td></tr></table></figure><p>其次，改web服务器像缓存器发送具有被请求对象的响应报文</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 CR</span><br><span class="line">DATA: Sat,8 Oct 2011 15:39:29</span><br><span class="line">Server : Apache/1.3.0 (Unix)</span><br><span class="line">Last-Modified :Wed, 7 Sep 2011 09:23:24</span><br><span class="line">Content-Type: image/gif</span><br><span class="line"></span><br><span class="line">(data ……)</span><br></pre></td></tr></table></figure><p>该缓存器在将该对象转发到请求的浏览器的同时，也在本地缓存了这个对象。<br><strong>更重要的是</strong>缓存器在存储这个对象的时候也存储了最后的修改日期</p><hr><p>一星期之后，另一个用户经过该缓存器上请求同一个对象</p><p>该对象仍然在这个缓存器里面，由于可能被修改，所以缓存器会发送一个条件GET执行最新检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTP/1.1</span><br><span class="line">Bost: www.exotiquecuisine.com</span><br><span class="line">If-Midified-Since: Wed, 7 Sep 2011 09:23:24</span><br></pre></td></tr></table></figure><p>值得注意的是<code>If-Modified-Since</code>刚好等于上个星期的<code>Last-Modified</code>值<br>假设没有被修改，那么Web服务器向该缓存器发送一个响应报文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">DATA: Sat, 15 Oct 2011 15:39:29</span><br><span class="line">Server : Apache/1.3.0 (Unix)</span><br><span class="line"></span><br><span class="line">(EMPTY ENTITY BODY)</span><br></pre></td></tr></table></figure><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917163130.png" alt="Pasted image 20230917163130"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week3-class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week3-class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week3-class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>RDT数据是可能出错的，如何判断出错，所以需要校验机制；使用校验和机制。</p><p>RDT实际上是一种停等协议</p><p>GBN 出错全部重传</p><p>SR 选择重传</p><p>**** 如何理解传输层复用和分用？复用和分用只在传输层进行嘛？可能通过其他方式实现复用和分用嘛？  </p><blockquote><p>传输层的复用和分用是指在传输层中将多个应用程序的数据流进行合并和拆分的过程。复用是指将多个应用程序的数据流合并在一起，使用传输层提供的协议或端口标识符将这些数据流区分开。分用是指将传输层接收到的数据流拆分成多个应用程序的数据流，并将其传递给相应的应用程序。</p><p>传输层复用和分用并不仅限于传输层，还可以通过其他方式实现复用和分用。例如，在应用层中可以使用多路复用技术将多个应用程序的数据流合并在一起，并在传输层使用单个传输层连接进行传输。同样，分用也可以在应用层或其他网络层进行，以将接收到的数据流分发给相应的应用程序或网络节点。</p><p>总结起来，传输层是最常见的实现复用和分用的层次，但复用和分用也可以在其他层次进行实现，以实现合并和拆分数据流的目的。</p></blockquote><h2 id="复用和分用"><a href="#复用和分用" class="headerlink" title="复用和分用"></a>复用和分用</h2><p>FDM 收音机 </p><p><strong>如何理解滑动窗口协议？都会有哪些因素会影响窗口大小的确定？</strong> </p><blockquote><p>滑动窗口协议是一种用于在通信中进行流量控制和可靠数据传输的机制。它通过在发送方和接收方之间维护一个固定大小的窗口来实现流量控制。发送方将数据分割成适当大小的数据块，并通过网络发送给接收方。接收方使用确认应答来告知发送方已经成功接收数据。同时，接收方也会告知发送方当前可接收新数据的窗口大小。</p><p>影响窗口大小确定的因素包括：</p><ol><li><p>网络的带宽和延迟：如果网络带宽较大或延迟较小，窗口大小可以设置得较大，以更高效地利用网络资源。</p></li><li><p>接收方的处理能力：如果接收方处理能力有限，窗口大小应适当减小以防止数据堆积。</p></li><li><p>发送方与接收方之间的网络状况：如果网络不稳定或丢包较多，窗口大小可能需要减小以降低丢包率并提高可靠性。</p></li><li><p>应用程序需求：根据应用程序的特点和需求，可能需要调整窗口大小来达到更好的性能和吞吐量。</p></li></ol></blockquote><p><strong>因素</strong></p><p>缓存</p><p>流量控制</p><p>拥塞控制</p><p><strong>GBN发送窗口</strong></p><ul><li>时延带宽积</li></ul><p><strong>滑动窗口协议大小和序列号比特位数有什么关系？为什么？</strong> </p><p>滑动窗口协议的窗口大小应该小于序列号比特位数的幂，这是为了避免发生溢出情况，确保序列号可以正确的循环使用。如果窗口大小大于序列号比特位数的幂，可能会导致序列号的重叠和混淆，从而引发错误。</p><p>来源：<a href="https://zhuanlan.zhihu.com/p/361966436">https://zhuanlan.zhihu.com/p/361966436</a></p><p>$W_s+W_r \leq 2^n$</p><p>$W_s$和$W_r$分别代表的是发送窗口和接收窗口，n代表的是传输位数。</p><p>对于GBN协议 $W_s \leq 2^n-1$</p><p><strong>如何极端停等协议的信道利用率？如何计算滑动窗口协议的信道利用率？怎么理解信道利用率？请给出表达式</strong> </p><p>极端停等协议的信道利用率可以通过以下表达式计算：</p><p>信道利用率 &#x3D; 数据传输时间 &#x2F; (数据传输时间 + 2 * 往返时间)</p><p>滑动窗口协议的信道利用率可以通过以下表达式计算：</p><p>信道利用率 &#x3D; 数据传输时间 &#x2F; (数据传输时间 + 窗口大小 * 往返时间)</p><p>信道利用率是指在一定时间内，实际传输的数据占总传输时间的比例。它是衡量通信系统中信道利用程度的指标。信道利用率越高，表示信道被更有效地利用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-ReadingComplement</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>TCP发送方必须处理的第三个主要事件：接受方确认的报文段的到达</p><p>当时间发生的时候将ACK y的值和变量SendBase相比较，如果y大于SendBase,也就是说ACK在确认先前没有被确认的报文段，所以更新SendBase为y。</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926144429.png" alt="image.png" style="zoom:50%;" /><p>A向B发送了序号为92的8字节数据，主机B向A返回ACK&#x3D;100但是在过程中丢失，在超时之后将会进行重传，N再重新传回ACK&#x3D;100</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926144754.png" alt="image.png" style="zoom:50%;" /><p>可以看出第一次超时两个ACK都没有收到，之后第二次超时重新发送了Seq&#x3D;92,在第二个超时时间内收到ACK&#x3D;120，这样第二个报文段就不会被重传</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926145021.png" alt="image.png" style="zoom:50%;" /><p>这就和第二种情况中一样，但是ACK在第一次的超时间隔内就就收到了，虽然ACK 100没有正确接收，但是ACK 120正确接收了，说明119之前的所有数据都正确接收了，也就不用重新传输第一段报文</p><p><strong>超时间隔加倍</strong></p><p>每当超时时间发生，重传具有序号最小的还没有被确认的报文段</p><p><code>将超时时间间隔设为先前值的两倍</code></p><p>超时间隔在每次重传之后会呈现指数型增长</p><p>提供了<code>形式受限的拥塞控制</code></p><p><strong>定时器过期很可能是由网络拥塞引起的</strong></p><blockquote><p>[!TIP] 太多的分组到达源和目的地之间路径上的一台（或者多台）路由器的队列中，造成分组丢失或者长时间的排队时延</p></blockquote><p>拥塞的时候，如果源持续重传分组，会让拥塞 <strong>更加严重</strong></p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a><em><strong>快速重传</strong></em></h2><p>超时周期因为每次的指数形式增长会让超市周期可能相对较长</p><p><strong>增加了端到端的时延</strong></p><p>注意到<strong>冗余ACK</strong>来检测丢包情况</p><blockquote><p>[!TIP] <strong>冗余ACK</strong>代表的是在其确认某个报文段的ACK</p></blockquote><p>当接受方检测到了数据流中的一个间隔，这样就是报文段的丢失。</p><p>TCP不使用否定确认，所以接收方不能向发送方发送一个显示的否定确认（NAK），所以TCP对接收到的最后一个按序字符进行<strong>重复确认</strong></p><p>如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的冗余ACK，可以当作一种指示，这个已经被确认过3次的报文段之后的报文段已经丢失。</p><p>一旦收到3个冗余ACK，TCP就执行<strong>快速重传</strong></p><blockquote><p>[! TIP] 在这个报文段的定时器过期之前重传丢失的报文段  </p></blockquote><p>代表ACK的收到的事件的伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">event : ACK RECEIVED, with ACK field value of y</span><br><span class="line">if(y &gt; SendBase)&#123;</span><br><span class="line">SendBase = y</span><br><span class="line">if( ther are currently any not yet acknowledged segments)</span><br><span class="line">start timer</span><br><span class="line">&#125;</span><br><span class="line">else &#123; </span><br><span class="line">// 一个对确认过的重复的ACK进行发送了三次</span><br><span class="line">increment number of duplicate ACKs received for y=3</span><br><span class="line">// TCP fast retrasment</span><br><span class="line">resend segment with sequence number y</span><br><span class="line">&#125;</span><br><span class="line">break</span><br></pre></td></tr></table></figure><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926184721.png" alt="image.png" style="zoom:50%;" /><h2 id="是回退N步还是选择重传"><a href="#是回退N步还是选择重传" class="headerlink" title="是回退N步还是选择重传"></a><em><strong>是回退N步还是选择重传</strong></em></h2><p>TCP Sender 只维护 SendBase 和NextSeqNum，所以TCP看起来像是一个GBN风格的协议</p><p><strong>但是和GBN有着显著的区别</strong></p><blockquote><p>[!TIP] TCP实现会将正确接收但是失序的报文段缓存起来。</p></blockquote><p>发送报文段 1，2，3，…… N</p><p>假设分组n &lt; N确认报文丢失，但是其余的确认报文都分别在超时之前到达发送端。</p><p>如果是GBN，就会重传n+1，…… N的所有分组</p><p>但是TCP只会重传分组n，而且如果对报文段n+1的确认报文在报文段n超时之前到达，TCP都不重传报文n</p><p><em><strong>选择确认</strong></em></p><p>允许TCP的接收方有选择的确认失去顺序的报文段</p><p>所以当这个机制和选择重传机制结合起来使用的时候（也就是跳过那些已经被接受方确认过的报文段），TCP看起来就像是SR协议</p><blockquote><p>[!INFO] 所以TCP的差错恢复机制就最好被分类为GBN协议和SR协议的混合体</p></blockquote><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h2><p>流量控制因此是一个速度匹配服务，也就是发送方的发送速率和接收方的应用程序的读取速率相匹配。</p><p>Previous : TCP发送方也可能因为IP网络的拥塞而被遏制。</p><p>要区分流量控制和拥塞控制</p><h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><p>发送方维护接收窗口的变量来提供流量控制。</p><p>TCP是全双工通信，所以两端都要维护接收窗口</p><p>LastByteRead: 主机B上的应用进程从缓存读出的数据流的最后一个字节的编号</p><p>LastByteRcvd: 从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号</p><p>所以接收的数据的大小是前编号减去最后一个编号也就是 Data &#x3D; LastByteRcvd - LastByteRead</p><p>所以接收窗口大小就等于rwnd &#x3D; RcvBuffer - Data</p><p>接收窗口大小是动态的，开机的时候rwnd &#x3D; RcvBuffer</p><p>A主机跟踪两个变量：LastByteSent &amp; LastByteAcked</p><p>两者之差就是A发送到连接中但是没有被确认的数据量。</p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927110938.png" alt="image.png"></p><p>就只用研究这一张图</p><p>发起TCP连接，发送SYN信号，接收到SYN 和ACK信号就建立连接</p><p>关闭TCP连接，发送FIN信号，进入FIN等待，接收到ACK确认信号，不发送，再等待FIN，再发送最后一次ACK，等待三十秒然后断开连接。</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927111152.png" alt="image.png"></p><p>监听套接字Socket，进入监听状态；得到SYN信号就发送SYN和ACK，进入下一状态，接收到ACK之后不发送，建立好了连接</p><p>关闭连接的时候，接收到FIN之后就发送ACK，进入等待状态，再次发送FIN，接收到了ACK便不发送，关闭连接。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><strong>拥塞原因和代价</strong></p><p>Situation 1 :</p><p><strong>两个发送方和一台无穷大缓存的路由器</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927111847.png" alt="image.png"></p><p>没有执行差错恢复，不用流量控制和拥塞控制</p><p>吞吐率的上线就是R&#x2F;2，因为这是两条连接之间的共享链路容量造成的。</p><p>而且当发送的速率接近R&#x2F;2的时候，平均排队分组的数量就会无限增长</p><blockquote><p>[!拥塞网络的一种代价]<br>分组的到达速率接近链路容量的时候，分组就会经历巨大的排队时延</p></blockquote><p>Situation 2:</p><p><strong>两个发送方和一台具有有限缓存的路由器</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927112045.png" alt="image.png"></p><p>假如主机还是用$\lambda_{in}$的速率发送数据，运输层向网络中发送报文段（含有初始数据或者重传数据）的速率用$\lambda^{‘}_{in}$表示，这就被称为<strong>供给载荷</strong></p><p>实现性能完全取决于重传的方式。</p><blockquote><p>[!Graph a)]</p></blockquote><p>Assumption: A能够确定路由器是否空闲，空闲的时候才会发送分组，这样就不会丢包 $\Rightarrow \lambda_{in} &#x3D; \lambda^{‘}_{in}$</p><blockquote><p>这个时候的性能是理想的，也就是说每个分组都能够接收到，但是传输速率吧还是不能超过R&#x2F;2。</p></blockquote><blockquote><p>[!Graph b)]</p><p>More Real : 发送方仅在确定了一个分组已经丢失的时候才重传。</p><p>当供给载荷达到了R&#x2F;2的时候，数据被交付的速率为R&#x2F;3，所以说在0.5R的单位传输中，0.333R字节是初始数据，0.166R字节是重传数据</p></blockquote><blockquote><p>[!INFO]<br><strong>网络拥塞的另一种代价</strong></p><p>发送方必须执行重传来步长因为缓存溢出而丢失的分组</p></blockquote><blockquote><p>[!Graph c)]</p><p>发送方会提前发生超时并重传已经被推迟还没有丢失的分组，也就是初始数据分组和重传分组都可能到达接收方。重传分组将被丢弃。</p><p>假定每个分组被转发两次，当供给载荷接近R&#x2F;2的时候，吞吐量就渐进R&#x2F;4</p></blockquote><blockquote><p>[!INFO]<br><strong>网络拥塞的另一种代价</strong></p><p>发送方在遇到大时延的时候所进行的不必要的重传会引起路由器利用其链路带宽来转发不必要的分组副本。</p></blockquote><p>Situation 3:</p><p><strong>四台主机发送分组，通过交叠的两跳路径传输</strong></p><p>采用超时重传机制实现可靠数据传输</p><p>所有路由器链路容量都是R字节&#x2F;s</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927113951.png" alt="image.png"></p><p>A $\to$ C的连接： Router R1&amp;R2</p><p>A-C &amp; D-B and A-C &amp; B-D 连接共享路由器R1，R2 </p><p>如果吞吐量很小，路由器缓存的溢出很少见，所以较小的$\lambda_{in}$会导致$\lambda_{out}$的增大</p><p><strong>当$\lambda_{in}$很大的情况 Consider R2</strong></p><p>到达路由器R2的最大速率就只能是R，当$\lambda^{‘}_{in}$无穷大的时候，此时的A-C链路会因为B-D链路的供给载荷升高而导致吞吐量逐渐减少 $\to 0$</p><p>当有一个分组在第二条路由器上被丢弃的时候，第一条路由器所做的努力都白费了，也就是”劳而无功”</p><blockquote><p>[!INFO]<br><strong>拥塞的另一种代价</strong></p><p>当一个分组沿一条路径被丢弃的时候，每个上游路由器用于转发该分组到丢弃该分组而是用的传输容量最终被浪费掉了。</p></blockquote><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p><strong>端到端的拥塞控制</strong></p><p>网络层没有为运输层拥塞控制提供显式支持</p><p>TCP报文段的丢失可以看作是网络拥塞的迹象，TCP会相应减少窗口长度</p><p>使用增加的往返时延值作为网络拥塞程度增加的指示</p><p><strong>网络辅助的拥塞控制</strong></p><p>网络层构件向发送方提供关于网络中拥塞状态的显式反馈信息。</p><p>ATM ABR拥塞控制形式，允许路由器显式的通知发送方，告知路由器能在输出链路上支持的传输速率。</p><p>XCP协议对每个源提供路由器计算的反馈，这个反馈携带在分组首部中</p><p><strong>直接反馈信息</strong></p><p>由网络路由器发给发送方</p><p><em>阻塞分组的形式</em>  mainly “我拥塞了”</p><p><strong>路由器标记字段</strong></p><p>至少要经过一个完整的往返时间</p><h3 id="ATM-ABR-拥塞控制"><a href="#ATM-ABR-拥塞控制" class="headerlink" title="ATM ABR 拥塞控制"></a>ATM ABR 拥塞控制</h3><p>一种采用网络辅助方法解决拥塞控制的协议</p><p><strong>Goal</strong> : 说明该协议为拥塞控制所采用的方法明显不同于英特网TCP协议的方法</p><p>需要理解的几个方面：</p><ul><li><em><strong>ATM基本上采用一种面向虚电路（VC）的方法来处理分组交换</strong></em></li></ul><p>允许交换机跟踪各个发送方的行为（ex. 平均传输速率）</p><p>采取特定源的拥塞控制动作(交换机变得拥塞的时候，向发送方显式的发送信令减少速率)</p><p>这样的状态（逐VC）非常适合执行网络辅助拥塞控制</p><ul><li><em><strong>设计成一种弹性数据传输服务，该服务方式使人联想起TCP</strong></em></li></ul><p>轻载的时候会充分利用空闲的可用带宽；拥塞的时候会将传输速率抑制为min</p><p><strong>资源管理信源</strong>（aka. 分组，RM）</p><p>主机和交换机之间传递和拥塞相关的信息。</p><p>RM到达目的地之后，会调转方向想发送方传送（Probably 已经被 Destination 修改）</p><p>交换机也能发送RM，并直接发送给源。</p><ul><li><em><strong>基于速率的方法。也就是发送方明确的计算处能发送的最大速率，并据此进行相应的调整。</strong></em></li></ul><blockquote><p>[! EFCI bit]</p><p><strong>显示转发拥塞指示比特</strong></p><p>交换机把EFCI bit set为1，表示网络拥塞</p><p>Destination 检查收到的EFCIIbit是否有1，大多数为1 $\to$ set RM &#x3D; 1</p><p>将RM信源发送回给发送方</p><p>用EFCI &amp; RM中的CIbit，发送方就能在网络交换机拥塞的时候得到通知</p></blockquote><blockquote><p>[!CI &amp; NI bit]</p><p>拥塞指示比特（CI）&amp; 无增长比特（NI）</p><p><strong>每32个数据单元有一个RM信元</strong></p><p>交换机在轻微拥塞的时候将经过的RM中的NI set 1，严重的时候将CI set 1.</p><p>目的主机收到RM信元的时候将RM发回发送方，保持CI,NI不变</p></blockquote><blockquote><p>[!ER]<br>每一个RM信元都会包含两个字节的显式速率（ER）</p><p>一个拥塞的交换机会降低经过的RM信元中ER字段中包含的值</p><p>以这样的方式就可以将ER字段设置为在源到目的地路径上所有交换机的最小可支持速率</p></blockquote><p>一个ATM ABR 以返回的RM信元中的CI、NI和ER值为函数，来调整发送信元的速率。进行速率调整的规划非常复杂而且繁琐。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-ReadingComplement-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><strong>三个问题：</strong></p><ul><li>TCP怎么知道发生了拥塞</li><li>TCP怎么能够实现端到端的限流</li><li>TCP在知道拥塞之后实现什么样的算法来控制拥塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-3</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-3/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p><strong>网络前十大问题之一：拥塞控制原理</strong></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote><p>[!拥塞]<br><strong>非正式的定义</strong>：“太多的发送主机发送了太多的数据或者发送速度过快以至于网络无法处理”</p></blockquote><p><strong>表现</strong>：</p><ul><li>分组丢失（因为路由器的缓存溢出）</li><li>分组延迟过大（在路由器缓存中排队）</li></ul><p><strong>拥塞控制</strong> vs. <strong>流量控制</strong></p><p>A top-10 problem</p><h3 id="拥塞控制的成因和代价"><a href="#拥塞控制的成因和代价" class="headerlink" title="拥塞控制的成因和代价"></a>拥塞控制的成因和代价</h3><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><p>两个senders： 两个recievers</p><p>一个路由器，无限缓存</p><blockquote><p>[!无限缓存]<br>说明不管主机发送的有多快，有多少数据，都可以从路由器传输到对应的位置，不会造成分组丢失</p></blockquote><p>没有丢失的好处：<strong>没有重传</strong></p><p>链路的带宽是C</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926200532.png" alt="image.png"></p><p>所以可以看到左边这个图：</p><blockquote><p>[!吞吐率]<br> 左边的图是关于吞吐率的<br>达到C&#x2F;2的时候就不会再增长了</p></blockquote><blockquote><p>[!时延]<br>当$\lambda_{in}$靠近C&#x2F;2的时候，是时延爆炸式的增长</p></blockquote><h4 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h4><ul><li>一个路由器，有限的buffers</li><li>Sender重传分组</li></ul><p><strong>情况a</strong>:</p><p>Sender 能够通过某种机制直到路由器的buffer信息，有空闲才会发 $\lambda_{in} &#x3D; \lambda_{out}$</p><p><strong>情况b</strong>:</p><p>丢失了之后才会重发： $\lambda^{‘}<em>{in} \ge \lambda</em>{out}$</p><p><strong>情况c</strong>:</p><p>分组丢失和定时器超时之后都重发，$\lambda^{‘}_{in}$会变得更大</p><blockquote><p>[!拥塞的代价]<br>对给定的goodput，要做更多的工作（重传）<br>造成资源的浪费</p></blockquote><h4 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h4><p>四个发送方 多跳 超时&#x2F;重传</p><p><strong>拥塞的另一个代价</strong>：当分组被丢失的时候，任何用于该分组的“上游”传输能力全都被浪费掉</p><h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><p><strong>端到端拥塞控制</strong></p><ul><li>网络层不需要显式的提供支持</li><li>端系统通过观察loss，delay等网络行为判断是否发生拥塞</li><li>TCP采取这种方法</li></ul><p><strong>网络辅助的拥塞控制</strong></p><ul><li>路由器向发送方显式的反馈网络拥塞信息</li><li>简单的拥塞只是(1bit):SNA,DECbit,TCP&#x2F;IP ECN, ATM</li><li>指示发送方应该采取何种速率</li></ul><h4 id="ATM-ABR-拥塞控制"><a href="#ATM-ABR-拥塞控制" class="headerlink" title="ATM ABR 拥塞控制"></a>ATM ABR 拥塞控制</h4><p><strong>ABR</strong> </p><ul><li>“弹性服务”</li><li>如果发送路径underloaded 🗯️ 使用可用的带宽</li><li>如果发送方路径拥塞  速率降到最低保障速率</li></ul><p><strong>RM</strong></p><ul><li>发送方发送</li><li>交换机设置RM cell位（网络辅助）<ul><li>NI bit : rate不许增长</li><li>CI bit : 拥塞指示</li></ul></li><li>RM cell由接收方返回给发送方</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926203323.png"></p><blockquote><p>[!RM cell]<br>显式的速率字段（SR）字段：两个字节</p><ul><li>拥塞的交换机可以将ER设置位最低的值</li><li>发送方获知路径能支持的最小速率</li></ul></blockquote><blockquote><p>[!Data cell]<br>EFCI位：拥塞的交换机将其设置为1</p><ul><li>如果RM cell前面的data cell的EFCI位被设置为1，那么发送方再返回的RM cell中设置CI位</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h1 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h1><h2 id="TCP-概述"><a href="#TCP-概述" class="headerlink" title="TCP 概述"></a>TCP 概述</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>一个发送方一个接收方</p><h3 id="可靠的、按照顺序的字节流"><a href="#可靠的、按照顺序的字节流" class="headerlink" title="可靠的、按照顺序的字节流"></a>可靠的、按照顺序的字节流</h3><h3 id="流水线机制"><a href="#流水线机制" class="headerlink" title="流水线机制"></a>流水线机制</h3><ul><li>TCP拥塞控制和流量控制机制设置窗口尺寸。</li></ul><h3 id="发送方-接收方缓存0"><a href="#发送方-接收方缓存0" class="headerlink" title="发送方&#x2F;接收方缓存0"></a>发送方&#x2F;接收方缓存0</h3><h3 id="全双工（full-duplex）"><a href="#全双工（full-duplex）" class="headerlink" title="全双工（full-duplex）"></a>全双工（full-duplex）</h3><p>同一链接中能够传输双向数据流</p><h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>通信双方在发送数据之前必须建立连接</p><p>连接状态只在链接的两端中维护，在沿途节点中并不维护状态</p><p>TCP连接包括 <em>两台主机上的缓存</em>、<em>连接状态变量</em>、<em>socket</em>等</p><h3 id="流量控制机制"><a href="#流量控制机制" class="headerlink" title="流量控制机制"></a>流量控制机制</h3><h2 id="TCP段的结构"><a href="#TCP段的结构" class="headerlink" title="TCP段的结构"></a>TCP段的结构</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922213232.png" alt="image.png"></p><p>第一行：源端口号，目的端口号</p><p>段序列号和ACK的数据</p><p>U：URGENT 代表紧急数据<br>A：ACK 代表是否有效<br>P：PUSH DATA NOW 没有用处<br>R：RST<br>S：SYN<br>F：FIN<br>checksum：代表校验和</p><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><ul><li>序列号是segment中第一个字节的编号，而不是segment的编号</li><li>建立TCP的时候，双方随机选择序列号</li></ul><h3 id="ACKs"><a href="#ACKs" class="headerlink" title="ACKs:"></a>ACKs:</h3><ul><li>希望接收到的下一个字节的序列号</li><li>累计确认，该序列号之前的所有字节都已经被正确收到</li></ul><h4 id="Q：接收方是怎么处理乱序到达的Segment"><a href="#Q：接收方是怎么处理乱序到达的Segment" class="headerlink" title="Q：接收方是怎么处理乱序到达的Segment?"></a>Q：接收方是怎么处理乱序到达的Segment?</h4><blockquote><p><strong>A: TCP 规范中没有规定，由TCP的实现者做出决策</strong></p></blockquote><p>有两台主机，两个之间进行远程登陆的功能 telnet </p><p>〽️ 之前已经建立了连接</p><ul><li>当主机A用户输入一个C之后，会产生一个序列号的段。(Seq&#x3D;42,ACK&#x3D;79（期望收到的）,data&#x3D;’C’)</li><li>返回来的段中的内容是Seq&#x3D;79,ACK&#x3D;43,data&#x3D;’C’</li><li>主机会再发送一个确认，Seq&#x3D;43,ACK&#x3D;80.</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922214115.png" alt="image.png"></p><h1 id="TCP的可靠数据传输"><a href="#TCP的可靠数据传输" class="headerlink" title="TCP的可靠数据传输"></a>TCP的可靠数据传输</h1><p>TCP在IP层里面提供的服务的不可靠服务基础上实现可靠数据传输服务</p><p>流水线机制</p><p>累计确认</p><p>TCP使用单一重传定时器</p><p>触发重传的时间 </p><ul><li>超时</li><li>收到重复的ACK</li></ul><h2 id="TCP-RTT和超时"><a href="#TCP-RTT和超时" class="headerlink" title="TCP RTT和超时"></a>TCP RTT和超时</h2><p><strong>问题</strong>：<em>怎么设置定时器的超时时间？</em></p><p>可以使用RTT来作为一个标尺来定下TCP的超时时间</p><p>过短就会产生不必要的重传</p><p>如果过长就会对段丢失的时间反应比较慢</p><p><strong>问题</strong>：<em>怎么估计RTT？</em> </p><p><code>SampleRTT</code>：测量从段发出去到收到ACK 的时间</p><ul><li>忽略重传</li></ul><p><code>SampleRTT</code>变化</p><ul><li>测量<strong>多个</strong><code>SampleRTT</code>，求平均值，形成RTT的估计值</li></ul><p>使用指数加权移动平均的方法：</p><p>EstimatedRTT &#x3D; (1 - $\alpha$) * EstimatedRTT  + $\alpha$ * SampleRTT</p><p><strong>典型值就是0.125</strong></p><p><u>定时器超时时间的设置</u></p><ul><li>EstimatedRTT +”安全边界”</li><li>EstimatedRTT变化大 $\rightarrow$ 较大的边界</li></ul><p><u>测量RTT值的变化：SampleRTT和EstimatedRTT的差值</u></p><p>DevRTT &#x3D; (1-$\beta$) * DevRTT + $\beta$ * | SampRTT-EstimatedRTT |</p><p><strong>Typically, $\beta$ &#x3D; 0,25</strong></p><p><u>定时器超时时间的设置</u></p><p>TimeoutInterval &#x3D; EstimatedRTT + 4 * DevRTT</p><h2 id="TCP发送方的事件"><a href="#TCP发送方的事件" class="headerlink" title="TCP发送方的事件"></a>TCP发送方的事件</h2><p>从应用层收到数据</p><ul><li>创建Segment</li><li>序列号是Segment第一个字节的编号</li><li>开启计时器</li><li>设置超时时间：TimOutInterval</li></ul><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><ul><li>重传引起超时的Segment</li><li>重启定时器</li></ul><h3 id="收到ACK"><a href="#收到ACK" class="headerlink" title="收到ACK"></a>收到ACK</h3><p>如果确认此前未确认的Segment</p><ul><li>更新SendBase</li><li>如果窗口中还有没有被确认的分组，重新启动定时器</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922215744.png" alt="image.png"></p><p>TCP重传示例如上：此时返回的时候ACK发生丢失，主机发生Timeout事件，此时重新接受，同样会使用ACK100来进行回复</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922215855.png" alt="image.png"></p><p>两个数据相近的发出，这个Timeout间隔设置的短了，所以就会发生重传，<strong>注意，此时重新传回来的数据应该是ACK120</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922220107.png" alt="image.png"></p><p>如果没有收到100，但是收到了ACK120，同样是把SendBase来设置为120.</p><h2 id="TCP-ACK的生成-：-RFC-1122-RFC-2581"><a href="#TCP-ACK的生成-：-RFC-1122-RFC-2581" class="headerlink" title="TCP ACK的生成 ： RFC 1122,RFC 2581"></a>TCP ACK的生成 ： RFC 1122,RFC 2581</h2><table><thead><tr><th>Event at Receiver</th><th>TCP Receiver action</th></tr></thead><tbody><tr><td>Arrival of in-order segment with expected seq # All data up to expected seq # already ACKed</td><td>Delayed ACK.Wait up to 500ms for next segment. If no next segment send ACK</td></tr><tr><td>Arrival of in-order segment with expected seq # One other segment has ACK pending</td><td>Immediately send single cumulative ACK. ACKing both inorder segments</td></tr><tr><td>Arrival of out-of-order segment higher-the expect seq # Gap detected</td><td>Immediately send <em>duplicate ACK</em>,indicating seq # of next expected byte</td></tr><tr><td>Arrival of segment that partitially of completely fills gap</td><td>Immediately send ACK,provided that segment startset lower end of gap</td></tr></tbody></table><h2 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h2><p>TCP的实现中，如果发生超时，超时的事件间隔将重新设置，即将超时时间间隔加倍，导致很大。</p><ul><li>重发丢失的分组之前要等待很长时间</li></ul><p>通过重复ACK检测分组丢失</p><ul><li>Sender 会背靠背的发送多个分组</li><li>如果某个分组丢失，可能会引起多个重复的ACK</li></ul><p>入宫Sender收到对同一个数据的3个ACK，那么久假定数据之后的段已经丢失</p><p><strong>快速重传</strong>：在定时器超时之前就进行重传！<strong>利用多个重复的ACK</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922221329.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>接收方为TCP连接分配buffer</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230924210206.png"></p><p>蓝色表示空出来的可以接受数据的</p><p>上层应用可能处理buffer中数据的速度较慢就会导致buffer溢出，淹没接收方。</p><p><strong>所以这就是buffer control</strong></p><p><strong>所以怎么做流量控制？</strong></p><p>Buffer中的可用空间(spare room)</p><p>&#x3D; RcvWindow</p><p>&#x3D; RcvBuffer - (LastByteRcvd - LastByteRead)</p><p>Reciever通过在Segment头部字段将RcvWindow告诉Sender</p><p>Sender限制自己已经发送的但是还没有收到ACK的数据不超过接收方的空闲RcvWindow尺寸</p><p>Receiver告知Sender RcvWindow &#x3D; 0 , 会出现什么情况？</p><blockquote><p>[!TIP]<br>会增加一个额外的处理，即使是Window &#x3D; 0 ，仍然可以有很小一部分的数据可以进行传输</p></blockquote><h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a>TCP的连接管理</h2><p>面向连接的连接协议</p><p>TCP sender &amp; reciever 会建立连接</p><p><em><strong>初始化TCP变量</strong></em></p><p>Seq  #<br>Buffer 和流量控制信息</p><p>Client : 连接的发起者</p><blockquote><p>创建一个套接字Socket，将Socket设置主机名和端口号</p></blockquote><p>Server : 等待客户连接请求</p><blockquote><p>接受客户机发起的请求并建立连接</p></blockquote><p>“<em><strong>三次握手机制</strong></em>”</p><blockquote><p>[!Step1]<br>Client host send TCP SYN (标志段) segment to server</p><ul><li>specifies initial seq #（选择自己的序列号并告诉服务器）</li><li>no data （不携带任何数据）</li></ul></blockquote><blockquote><p>[!Step2]<br>Server host recieves SYN , replies with SYN &amp; ACK segment<br>服务器接收到服务器的标志段，用标志段确认段来作为回复</p><ul><li>server allocates buffers (为连接建立缓存)</li><li>specifies server initial seq #(选择自己的初始的序列号并告知客户端)</li></ul></blockquote><blockquote><p>[!Step3]<br>client receives SYNACK, replies with ACK segment, which may contain data.接收到标志段确认段，客户机发送ACK报文段同意连接</p></blockquote><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926193703.png" alt="image.png"></p><blockquote><p>[!INFO]<br>如果在三次握手的第二步服务器分配资源，最后一次握手如果没有发过来，服务端会保留连接，一段时间没有收到ACK才会关闭连接</p></blockquote><p><em><strong>关闭连接</strong></em></p><p>Closing a connection:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client closes socket</span></span><br><span class="line">clientSocket.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><blockquote><p>[!Step1]<br>client向server发送TCP发送TCP FIN控制segment</p></blockquote><blockquote><p>[!Step2]<br>server收到FIN，回复ACK，关闭连接，发送FIN</p></blockquote><blockquote><p>[!Step3]<br>client收到FIN，回复ACK。</p><ul><li>进入<strong>等待</strong> —— 如果收到FIN，就会重新发送ACK</li></ul></blockquote><blockquote><p>[!Step4]<br>server收到ACK，连接关闭</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[&quot;Closed&quot;]--&gt;|client application initiates a TCP connection| B[&quot;SYN_SENT&quot;]</span><br><span class="line">B--&gt;|recieve SYN &amp; ACK send ACK| C[&quot;ESTABLISHED&quot;]</span><br><span class="line">C--&gt;|client application initiates close connection \n Send FIN|D[&quot;FIN_WAIT_1&quot;]--&gt;|receive ACK send nothing|E[&quot;FIN_WAIT_2&quot;]--&gt;|recieve FIN send ACK| F[&quot;TIME_WAIT&quot;]--&gt;|30s|A</span><br></pre></td></tr></table></figure><p><em><strong>同理可以给出服务端的生命周期图</strong></em></p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926195559.png" alt="image.png" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-RIP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-RIP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-RIP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>Internet采用层次化路由</p><p>AS内部路由协议也成为内部网络协议：interior gateway protocols(IGP)</p><p>最常见的AS内部路由协议：</p><ul><li>路由信息协议 routing information protocol  <code>RIP</code></li><li>开放最短路径优先 open shortest path first <code>OSPF</code></li><li>内部网关路由协议 interior gateway routing protocol <code> IGRP</code></li></ul><h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><p>早于1982年随BSD-UNIX操作系统发布</p><p>距离向量路由算法</p><ul><li><p>距离度量：跳步数(max &#x3D; 15 hops)，每条链路一个跳步</p></li><li><p>每30s，邻居之间交换一次DV，成为通告(advertisement)</p></li><li><p>每次通告：最多25目的子网(IP形式)</p></li></ul><h3 id="链路失效，恢复"><a href="#链路失效，恢复" class="headerlink" title="链路失效，恢复"></a>链路失效，恢复</h3><p>如果180s没有收到通告 $\to$ 邻居&#x2F;链路失效</p><p>经过这个邻居的路由都不可用了</p><p>重新计算路由</p><p>向邻居发送新的通告</p><p>邻居再一次向外发送通告(如果转发表改变)</p><p>链路是小信息能不能快速传播到全网？</p><ul><li>可能发生无穷计数问题</li></ul><p><strong>毒性逆转计数</strong>用于ping pong环路（无穷大距离为16hops）</p><h3 id="RIP路由表的处理"><a href="#RIP路由表的处理" class="headerlink" title="RIP路由表的处理"></a>RIP路由表的处理</h3><p>RIP路由表是利用一个称作rout-d的应用等进程进行管理</p><ul><li>应用进程实现</li></ul><p>通告报文周期性的通过UDP数据报发送</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029225226.png" alt="image.png"></p><p>层次划分是通过功能来划分的，无论是什么样的形式来完成</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-PUT</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PUT/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PUT/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]<p>将消息体中的文件上传到URL字段所指定的路径</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 知识卡片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-PPP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PPP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PPP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="点对点数据链路控制"><a href="#点对点数据链路控制" class="headerlink" title="点对点数据链路控制"></a>点对点数据链路控制</h2><p>一个发送端，一个接收端，一条链路: 比广播链路容易</p><ul><li><p>无需介质访问控制(Media Access Control)</p></li><li><p>无需明确的MAC寻址</p></li><li><p>e.g., 拨号链路,ISDN链路</p></li></ul><p>HDLC： High Level Data Link Control</p><p>PPP: (Point-to-Point Protocol)</p><h2 id="PPP设计需求"><a href="#PPP设计需求" class="headerlink" title="PPP设计需求"></a>PPP设计需求</h2><p>组: 将网络层数据报封装到数据链路层帧中可以同时承载任何网络层协议分组(不仅IP数据报)可以向上层实现分用 (多路分解)</p><p>比特透明传输:数据域必须支持承载任何比特模式</p><p>差错检测:(无纠正)</p><p>网络层地址协商: 端结点可以学习&#x2F;配置彼此网络地址</p><h2 id="PPP无需支持的功能"><a href="#PPP无需支持的功能" class="headerlink" title="PPP无需支持的功能"></a>PPP无需支持的功能</h2><p>无需差错纠正&#x2F;恢复无需流量控制不存在乱序交付无需支持多点链路</p><p>差错恢复、流量控制等由高层协议处理!</p><h2 id="PPP数据帧"><a href="#PPP数据帧" class="headerlink" title="PPP数据帧"></a>PPP数据帧</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101222057.png" alt="image.png"></p><p>标志(Flag): 定界符(delimiter)</p><p>地址(Address): 无效(仅仅是一个选项)</p><p>控制(Control): 无效; 未来可能的多种控制域</p><p>协议(Protocol): 上层协议 (eg, PPP-LCP,IP,IPCP, tc)</p><p>信息(info): 上层协议分组数据</p><p>校验(check): CRC校验，用于差错检测</p><h2 id="字节填充-Byte-Stuffing"><a href="#字节填充-Byte-Stuffing" class="headerlink" title="字节填充(Byte Stuffing)"></a>字节填充(Byte Stuffing)</h2><p>”数据透明传输“ 需求：数据域必须包含标志模式&lt;011110&gt;</p><p>Q:如何判断该作为数据接收，还是作为标志处理？</p><p>发送端: 在数据中的&lt;01111110&gt;和&lt;01111101&gt;字节前添加额外的字节&lt;01111101&gt;(“填充(stuffs)”)</p><p>接收端:<br>单个字节&lt;01111101&gt;表示一个填充字节:<br>连续两个字节&lt;01111101&gt;: 丢弃第1个，第2个作为数据接收</p><h2 id="PPP数据控制协议"><a href="#PPP数据控制协议" class="headerlink" title="PPP数据控制协议"></a>PPP数据控制协议</h2><p>在交换网络层数据之前，PPP数据链路两端必须:</p><ol><li><p>配置PPP链路</p><ol><li>最大帧长度</li><li>身份认证</li></ol></li><li><p>学习&#x2F;配置网络层信息</p><ul><li>对于IP协议: 通过交换IPCP协议(IP Control Protocol )报文(IP分组首部的“上层协议”字段取值: 8021)，完成IP地址等相关信息配置</li></ul></li></ol><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101222711.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-OSPF协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-OSPF%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-OSPF%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p>“开放”：公众可用</p><p>采用链路状态路由算法</p><ul><li>LS分组扩散（通告）</li><li>每个路由器构造完整的网络拓扑图</li></ul><p>链路状态数据库</p><p>每个入口对应一个邻居</p><p>OSPF通告在整个AS范围内进行泛洪</p><p>OSPF报文直接封装到IP数据报中</p><p>和OSPF及其相似的一个路由协议：IS-IS路由协议</p><h2 id="RIO不具备的优点"><a href="#RIO不具备的优点" class="headerlink" title="RIO不具备的优点"></a>RIO不具备的优点</h2><ol><li><p><strong>安全</strong>：所有OSPF报文可以被认证（恶意入侵）</p></li><li><p>允许使用<strong>多条</strong>相同费用的<strong>路径</strong>（RIP只能选一条）</p></li><li><p>对于每一条链路，可以针对不同的TOS设置多个不同费用度量</p></li><li><p>继承单播路由和多播路由：</p></li></ol><ul><li>多播OSPF协议和OSPF利用相同的网络拓扑数据</li></ul><p>OSPF支持对大规模AS分层</p><h2 id="分层的OSPF"><a href="#分层的OSPF" class="headerlink" title="分层的OSPF"></a>分层的OSPF</h2><p><strong>两级分层</strong></p><p>局部区和主干区</p><p>链路状态通告只限于区内</p><p>每个路由器掌握所在区的详细拓扑</p><p><strong>区边界路由器</strong>：汇总到达所在区的网络的距离，通告给其他区边界路由器</p><p><strong>主干路由器</strong>：在主干区内运行</p><p><strong>AS边界路由器</strong>：连接其他AS</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.4 计算机网络性能</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.4%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.4%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 速率<p>速率指的是数据率或者称为比特率</p><ul><li>单位时间传输信息量</li><li>计算机网络中最重要的一个性能指标</li><li>单位：b&#x2F;s(或bps)、kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s<ul><li>$k&#x3D;10^3、M&#x3D;10^6、G&#x3D;10^9$</li></ul></li><li>速率指的是<strong>额定速率</strong>或者<strong>标称速率</strong></li></ul><h1 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h1><p><strong>带宽</strong> 指的是信号具有的额频带宽度，也就是最高频率和最低频率之差，单位是Hz。</p><p>网络的“带宽”指的是信道能传输的“最高数据率”，单位 b&#x2F;s （bps）</p><p>常用的带宽单位：</p><ul><li>kb&#x2F;s </li><li>Mb&#x2F;s</li><li>Gb&#x2F;s</li><li>Tb&#x2F;s</li></ul><h1 id="延迟-时延（delay）"><a href="#延迟-时延（delay）" class="headerlink" title="延迟&#x2F;时延（delay）"></a>延迟&#x2F;时延（delay）</h1><p>分组交换为什么会繁盛丢包和时延？</p><img src=".\assets\image-20230807152535076.png" alt="$image-20230807152535076$" style="zoom:67%;" /><h2 id="d-proc-：节点处理延迟"><a href="#d-proc-：节点处理延迟" class="headerlink" title="$d_{proc}$：节点处理延迟"></a>$d_{proc}$：节点处理延迟</h2><p>（nodal processing delay）</p><ul><li>差错检测</li><li>确定输出链路</li><li>通常 &lt; m sec</li></ul><h2 id="d-queue-：排队延迟"><a href="#d-queue-：排队延迟" class="headerlink" title="$d_{queue}$：排队延迟"></a>$d_{queue}$：排队延迟</h2><p>（queuing delay）</p><ul><li>等待输出链路可用</li><li>取决于路由器拥塞程度</li></ul><h2 id="d-trans-：传输延迟"><a href="#d-trans-：传输延迟" class="headerlink" title="$d_{trans}$：传输延迟"></a>$d_{trans}$：传输延迟</h2><img src="D:\MarkdownNotes\计算机网络\assets\image-20230807153108762.png" alt="image-20230807153108762" style="zoom: 67%;" /><ul><li><p>L ： 分组宽度</p></li><li><p>R：链路带宽</p></li><li><p>$d_{trans}$ &#x3D; L&#x2F;R</p></li></ul><h2 id="d-prop-：传播延迟"><a href="#d-prop-：传播延迟" class="headerlink" title="$d_{prop}$：传播延迟"></a>$d_{prop}$：传播延迟</h2><ul><li>d ： 物理信号链路长度</li><li>s ：信号传播速度</li><li>$d_{prop}$ &#x3D; d&#x2F;s</li></ul><p><img src="D:\MarkdownNotes\计算机网络\assets\image-20230807153426289.png" alt="image-20230807153426289"></p><blockquote><p>车速为100 km&#x2F;hr~ 信号传播速度</p><p>收费站放行一台车用时12 秒 ~ 比特传输时间</p><p><code>车 ~ 比特</code>;<code>车队 ~ 分组</code></p><p><strong>车队通过收费站时间 ~ 传输延迟 (120秒)</strong></p><p><strong>每台车从第一个收费站跑到第二个收费站用时~ 传播延迟 (1小时)</strong></p></blockquote><h2 id="排队延迟"><a href="#排队延迟" class="headerlink" title="排队延迟"></a>排队延迟</h2><p>特殊的点在于<em>不确定</em></p><p>R：链路带宽（bps）</p><p>L：分组长度（bits）</p><p>a：平均分组到达速率</p><p>流量强度（traffic intensity &#x3D; $L \ a &#x2F; R$）</p><ul><li>~0  平均排队延迟很小</li><li>→ 1 平均排队延迟很大</li><li>$\gt$ 1 无限大</li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>（<strong>带宽时延积</strong>）</p><p><strong>时延带宽积 &#x3D; 传播时延 $\times$ 带宽</strong></p><p><strong>时延带宽积 &#x3D; $d_{drop} \times R \ (bits)$.</strong></p><p><strong>链路的时延带宽积又称为以比特为单位的链路长度</strong></p><h2 id="分组丢失（丢包）"><a href="#分组丢失（丢包）" class="headerlink" title="分组丢失（丢包）"></a>分组丢失（丢包）</h2><ul><li>队列缓存容量有限</li><li>分组到达已满队列将被丢弃</li><li>丢弃分组可能有前序结点或者源重发（也可能不重发）</li></ul><p>$丢包率 &#x3D; \frac{丢包数}{已发分组总数}$.</p><h2 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h2><p>吞吐量： 表示在发送端与接收端之间传送数据速率（b&#x2F;s）</p><ul><li>即时吞吐量：给定时刻的速率。</li><li>平均吞吐量：一段时间的平均速率。</li></ul><p>端到端的吞吐量决定于传播的各阶段吞吐量的最小值。</p><p>若$R_s &lt; R_c$ 吞吐量就是 $R_s$.</p><p>若$R_s &gt;R_c$ 吞吐量就是$R_c$.</p><p> 🥈 瓶颈链路（<strong>bottleneck link</strong>）</p><p>端到端路径上，限制端到端吞吐量的链路。</p><p>考虑10条“连接”共享主干网瓶颈链路R bits&#x2F;sec</p><p>每条连接的端到端的吞吐量： min($R_c,R_s,R&#x2F;10$)</p><p>实际网络：$R_c$或$R_s$通常是瓶颈</p><hr><p>上一页： [[CourseNotes&#x2F;计算机网络&#x2F;CN-No.3 网络核心]]</p><p>下一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.5 计算机网络的体系结构]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.5 计算机网络的体系结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 计算机网络的体系结构<h2 id="计算机网络是一个非常复杂的系统"><a href="#计算机网络是一个非常复杂的系统" class="headerlink" title="计算机网络是一个非常复杂的系统"></a>计算机网络是一个非常复杂的系统</h2><ul><li>主机</li><li>路由器</li><li>各种链路</li><li>应用</li><li>协议</li><li>硬件、软件</li></ul><p>……</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>是否存在一种系统结构有效描述网络？<br>利用什么样的结构？</p><p>……</p><p>至少用于讨论网络？</p><p>A：分层结构</p><h2 id="复杂系统的分层结构"><a href="#复杂系统的分层结构" class="headerlink" title="复杂系统的分层结构"></a>复杂系统的分层结构</h2><p>类比：航空旅行</p><p><img src="D:\MarkdownNotes\计算机网络\assets\Untitled-1692438417405-38.png" alt="Untitled"></p><ul><li>每层完成一种（类）特定服务&#x2F;功能</li></ul><h2 id="计算积网络的体系结构"><a href="#计算积网络的体系结构" class="headerlink" title="计算积网络的体系结构"></a>计算积网络的体系结构</h2><p>网络体系结构是从功能上描述计算机网络结构</p><p>计算机网络体系结构简称网络体系结构（network architecture）是分层结构</p><p>每层遵勖某个 &#x2F; 某些网络协议完成本层功能</p><p><strong>计算机网络体系结构是计算机网络的各层及其协议的集合</strong></p><p>体系结构是一个网络功能层次及其关系的<code>定义</code></p><p>体系结构是<strong>抽象的</strong></p><h2 id="为什么采用分层结构？"><a href="#为什么采用分层结构？" class="headerlink" title="为什么采用分层结构？"></a>为什么采用分层结构？</h2><h3 id="结构清晰-有利于识别复杂系统不见及其关系"><a href="#结构清晰-有利于识别复杂系统不见及其关系" class="headerlink" title="结构清晰 有利于识别复杂系统不见及其关系"></a><code>结构清晰</code> 有利于识别复杂系统不见及其关系</h3><ul><li>分层的参考模型(reference model)</li></ul><h3 id="模块化的分成易于系统更新维护"><a href="#模块化的分成易于系统更新维护" class="headerlink" title="模块化的分成易于系统更新维护"></a>模块化的分成易于系统更新维护</h3><ul><li>任何一层服务实现的改变对于其它系统其他层都是透明的。</li><li>例如，登机过程的改变并不影响航空系统的其他部分。</li></ul><h3 id="有利于标准化"><a href="#有利于标准化" class="headerlink" title="有利于标准化"></a><strong>有利于标准化</strong></h3><p><code>分层是否有不利之处？</code> 会导致效率不足</p><h2 id="分层网络的基本概念"><a href="#分层网络的基本概念" class="headerlink" title="分层网络的基本概念"></a>分层网络的基本概念</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 1-1692438417405-40.png)</p><p><code>实体</code> <strong>(entity)</strong> 表示任何可以发送或者接收信息的硬件或者软件进程</p><p><code>协议</code>是控制两个对等实体进行通信的规则的集合，协议是<code>水平的</code> 。</p><p>任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供<code>服务</code>，服务是垂直的。</p><p>下层协议的实现对上层的服务用户是<strong>透明</strong>的。</p><p>同系统的相邻层实体之间通过接口进行交互，通过服务访问点（SAP），交换原语，指定请求的特定服务。</p><hr><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 2-1692438417406-44.png)</p><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>开放系统互连（OSI）参考模型 $\rightarrow$ 分层网络体系结构模型（1984）</p><p>目的是支持 异构网络系统的互联互通。</p><p>异构网络系统互联的国际标准</p><p>理解网络通信的最佳<code>学习工具</code>（理论模型）</p><p>✅理论成功 市场失败</p><p>7层 （功能）， 每层完成特定的网络功能。</p><h2 id="OSI参考模型的通信过程"><a href="#OSI参考模型的通信过程" class="headerlink" title="OSI参考模型的通信过程"></a>OSI参考模型的通信过程</h2><p>主机从应用层发出信息，通过七个层到达物理层，通过传输介质传输到路由器的物理层，通过遵循各层的协议，经过物理层 $\rightarrow$ 数据链路层 $\rightarrow$ 网络层 $\rightarrow$ 数据链路层 $\rightarrow$ 物理层的转换再进入传输介质，然后再通过七层进入下一个主机的应用层。</p><p><strong>实线表示的是信息的<code>物理传输</code></strong></p><ul><li>通过接口实现</li></ul><p><strong>虚线表示的是<code>协议传输</code></strong></p><ul><li>和写信一样，无关传输过程，只看数据的交换</li></ul><p><strong>端-端层（end - end）</strong></p><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 3-1692438417406-42.png)</p><h2 id="OSI参考模型数据封装与通信过程"><a href="#OSI参考模型数据封装与通信过程" class="headerlink" title="OSI参考模型数据封装与通信过程"></a>OSI参考模型数据封装与通信过程</h2><p>用户数据从主机A出发</p><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 4-1692438417406-46.png)</p><h2 id="为什么要进行数据封装？"><a href="#为什么要进行数据封装？" class="headerlink" title="为什么要进行数据封装？"></a>为什么要进行数据封装？</h2><h3 id="增加控制信息"><a href="#增加控制信息" class="headerlink" title="增加控制信息"></a>增加控制信息</h3><ul><li>构造协议单元（PDU）</li></ul><h3 id="控制信息主要包括"><a href="#控制信息主要包括" class="headerlink" title="控制信息主要包括"></a>控制信息主要包括</h3><ul><li>地址（Address）：表示发送端、接收端</li><li>差错检测编码（Error-detecting code）：用于差错检测或纠正</li><li>协议控制（Protocol control）:实现协议功能的附加信息，如：<strong>优先级（priority） 、服务质量(QoS)、安全控制等</strong></li></ul><hr><h2 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h2><p>就是实现每一个bit的传输，具体的来讲：</p><ul><li><strong>接口特性</strong><ul><li><code>机械特性</code>  、<code>电气特性</code> 、<code>功能特性</code>、<code>规程特性</code></li></ul></li><li><strong>比特编码问题</strong></li><li><strong>数据率</strong></li><li><strong>比特同步</strong><ul><li>时钟同步,在发送设备和接受设备之间的信号同步</li></ul></li><li><strong>传输模式</strong><ul><li>单工<strong>（Simplex）</strong>也就是只能单向的通信</li><li>半双工<strong>（half-duplex）****对讲机</strong></li><li>全双工<em>（full-duplex）</em></li></ul></li></ul><hr><h2 id="数据链路层功能"><a href="#数据链路层功能" class="headerlink" title="数据链路层功能"></a>数据链路层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 5-1692438417406-48.png)</p><p>作为数据链路层解决的主要是<strong>节点到节点</strong>的数据传输</p><p><strong>组帧（Framing）构成帧的主要目的是能够成功的切分出数据帧</strong></p><p><strong>物理寻址（Physical addressing）</strong></p><ul><li>在帧头中增加发送端和接收端的物理地址标识数据帧的发送端和接收端</li></ul><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 6-1692438417406-50.png)</p><p><strong>流量控制（Flow control）</strong></p><ul><li>避免淹没接收端</li></ul><p><strong>差错控制（Error control）</strong></p><ul><li>检测并重传损坏或丢失帧，并避免重复帧</li></ul><p><strong>访问(接入)控制（Access control）</strong></p><ul><li>在任一给定时刻决定那个设备具有链路（物理介质）控制使用权</li></ul><hr><h2 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 7-1692438417406-52.png)</p><ul><li>负责从<strong>源主机到目的主机</strong>数据分组（packet）交付<ul><li>可能穿越多个网络</li></ul></li><li><strong>逻辑寻址（Logical addressing）</strong><ul><li>全局唯一逻辑地址，确保数据分组被送往目的主机，比如IP地址。</li></ul></li><li><strong>路由（Routing）</strong><ul><li>路径选择</li><li>互联网络并由路由分组☞目的主机</li></ul></li><li><strong>分组转发</strong></li></ul><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 8-1692438417406-54.png)</p><hr><h2 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 9-1692438417406-56.png)</p><p>负责源-目的（端-端）（进程间）完整报文传输</p><ul><li><strong>分段和重组</strong></li><li><strong>SAP寻址</strong><ul><li>确保将完整的报文提交给正确进程比如<code>端口号</code></li></ul></li></ul><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 10-1692438417406-58.png)</p><ul><li><strong>连接控制</strong></li><li><strong>流量控制</strong></li><li><strong>差错控制</strong></li></ul><hr><h2 id="会话层功能"><a href="#会话层功能" class="headerlink" title="会话层功能"></a>会话层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 11-1692438417406-60.png)</p><ul><li><strong>对话控制（dialog controling）</strong><ul><li>建立 维护</li></ul></li><li><strong>同步（synchronization）</strong></li><li>最<code>薄</code> 的一层</li></ul><hr><h2 id="表示层功能"><a href="#表示层功能" class="headerlink" title="表示层功能"></a>表示层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 12-1692438417406-62.png)</p><p>处理两个系统之间交换信息的语法和语义<em>（syntax and semantics）</em>问题</p><ul><li><strong>数据表示转化</strong><ul><li>转换为主机独立的编码</li></ul></li><li><strong>加密&#x2F;解密</strong></li><li><strong>压缩&#x2F;解压缩</strong></li></ul><hr><h2 id="应用层问题"><a href="#应用层问题" class="headerlink" title="应用层问题"></a>应用层问题</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 13-1692438417406-64.png)</p><p>支持用户通过用户代理（如浏览器）或者网络接口使用网络（服务）</p><p>典型应用层服务：</p><ul><li>文件传输（FTP）</li><li>电子邮件（SMTP）</li><li>Web（HTTP）</li><li>……</li></ul><p><strong>TCP&#x2F;IP参考模型</strong></p><p>![*IP over Everything*](D:\MarkdownNotes\计算机网络\assets\Untitled 14-1692438417406-66.png)</p><p><em>IP over Everything</em></p><hr><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 15-1692438417406-68.png)</p><p>综合OSI和TCP&#x2F;IP的优点</p><p>大部分都是这样的参考模型</p><p>在功能上基本类似之前的7层</p><p><strong>应用层：支持网络应用</strong></p><p><strong>传输层：进程-进程的数据传输</strong></p><p><strong>网络层：相邻网络元素（主机、交换机、路由器）的数据传输</strong></p><p><strong>物理层：比特传输</strong></p><p><strong>报文</strong>（message）的传播过程如下：</p><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 16-1692438417406-70.png)</p><p>💬可以看到交换机和路由器的本质区别是一个只有两层而一个是三层。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.3 网络核心</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.3%20%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.3%20%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 网络核心<h2 id="为什么需要数据交换"><a href="#为什么需要数据交换" class="headerlink" title="为什么需要数据交换"></a>为什么需要数据交换</h2><ul><li>$N^2$ 链路问题</li><li>将主机和交换设备连接</li><li>连通性</li><li>网络规模</li></ul><h2 id="交换？"><a href="#交换？" class="headerlink" title="交换？"></a>交换？</h2><ul><li>动态转接</li></ul><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png" alt="dynamic connect" style="zoom:67%;" /><ul><li>动态分配传输资源</li></ul><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.png" alt="dynamic sourse" style="zoom:67%;" /><h2 id="数据交换的类型"><a href="#数据交换的类型" class="headerlink" title="数据交换的类型"></a>数据交换的类型</h2><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换的特点</p><ul><li>最典型的电路交换网络：<strong>电话网络</strong></li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png" alt="Untitled" style="zoom:67%;" />W</p><ul><li>所以电路交换过程可以分为三个阶段：<ul><li>建立连接（呼叫&#x2F;电路建立）</li><li>通信</li><li>释放连接</li></ul></li><li>独占资源（比如信道资源）是不能被第三方共享的</li></ul><h3 id="电路交换网络的链路共享"><a href="#电路交换网络的链路共享" class="headerlink" title="电路交换网络的链路共享"></a>电路交换网络的链路共享</h3><p>→ 电路交换网络如何共享中继线？</p><hr><h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><ul><li>多路复用简称复用，是通信技术的基本概念</li><li>传输能力大于单路的信息，所以要实现多路复用技术</li></ul><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%203.png" alt="复用器进行组合，分用器来进行拆分" style="zoom:67%;" /><p>复用器进行组合，分用器来进行拆分</p><p><strong>多路复用：</strong>链路、网络资源 划分为<strong>资源片</strong></p><p>将资源片分配给各路“呼叫”</p><p>每路呼叫独占分配到的资源篇进行通信</p><p>资源片可能闲置</p><h3 id="典型多路复用方法"><a href="#典型多路复用方法" class="headerlink" title="典型多路复用方法"></a>典型多路复用方法</h3><ul><li><p><strong>频分多路复用</strong></p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%204.png" alt="最具代表性的就是有线电视网络" style="zoom:67%;" />  <p>  最具代表性的就是有线电视网络</p><p>  每个用户占用不同的带宽资源</p><p>  用户在分配到一定的频带后，那自始自终都占用这个频带</p><p>  频分多路技术</p></li><li><p><strong>时分多路复用</strong></p><p>  划分为<strong>帧</strong> 每个用户占据固定序号的时间间隙</p><p>  每个用户占用的时间间隙是周期性出现的</p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%206.png" alt="Untitled" style="zoom:50%;" />  <p>  在频率上是不分割的</p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%207.png" alt="时分多路复用"></p><p>  时分多路复用</p></li><li><p><strong>波分多路复用</strong></p><p>  光的频分复用</p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%208.png" alt="Untitled"></p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%209.png" alt="中间的链路是可以共享的，称为中继线"></p><p>  中间的链路是可以共享的，称为中继线</p></li><li><p><strong>码分多路复用</strong></p><p>  广泛应用于无线链路共享（蜂窝网，卫星通信）</p><p>  每个用户分配一个唯一的m bit的<strong>码片序列<em>chipping sequence</em></strong></p><p>  用户使用相同频率载波，利用各自码片序列编码数据</p><p>  $编码信号 &#x3D; (原始数据)\times (码片序列)$。</p><ul><li><p>如发送比特1(+1），则发送自己的m bit码片序列</p></li><li><p>如发送比特0(-1)，则发送该码片序列的m bit码片序列的反码</p></li><li><p>各个用户码片序列相互正交</p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2010.png" alt="Untitled"></p></li><li><p><strong>解码</strong>：码片序列和编码信号的<strong>内积</strong></p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2011.png" alt="Untitled"></p></li></ul><p>  <strong>具体的实现步骤</strong></p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2012.png" alt="在发送端和接收端的信号传输"></p><p>  在发送端和接收端的信号传输</p><p>  <strong>如果是多个用户向信道发送数据</strong></p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2013.png" alt="需要保证码片之间是正交的"></p><p>  需要保证码片之间是正交的</p><h2 id="数据交换：报文交换，分组交换"><a href="#数据交换：报文交换，分组交换" class="headerlink" title="数据交换：报文交换，分组交换"></a>数据交换：报文交换，分组交换</h2><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>  电路交换资源是独占的，报文指的是发送的信息的整体</p><p>  比如：一个文件</p><h3 id="分组交换（package-switch）"><a href="#分组交换（package-switch）" class="headerlink" title="分组交换（package switch）"></a>分组交换（<em><strong>package switch</strong></em>）</h3><p>  分组：报文分叉出来的一系列相对较小的数据包</p><p>  <strong>头 + 数据</strong></p><p>  分组交换需要保温的拆分和重组</p><p>  产生额外开销（因为要消费额外开销）</p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2014.png" alt="Untitled"></p></li></ul><p>作为分组交换网络，这样的共享不是事先就分配一部分，而是两个的数据分别都是用完整带宽进行转发，具有很强的随机性。所以也称为统计多路复用统计多路复用最大的特点就是按需共享链路。</p><p>每一个分组从上一个节点完整的转发分组，然后存储之后转发走。称为<strong>存储转发操作</strong>。</p><p>这里能保证是有效的数据，有且仅有当两个向量正交的时候才有效，可以通用数学推导出来。主要原因是因为可以去除S1信道和S2信道的交叉乘积的影响，达到隔离的目的：</p><p> $P&#x3D; \underset{1}{\overset{2}{\sum}}d_i \cdot S_i$</p><p>所以可以推导出</p><p>$d_1&#x3D;\frac{1}{m}\cdot S_i \cdot \underset{1}{\overset{2}{\sum}}d_i \cdot S_i &#x3D; \frac{(S_1)^2}{m} \cdot d$。</p><p>可以看出和上面的表达式是相同的</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2015.png" alt="Untitled"></p><hr><p>区别：</p><ul><li>报文交换用完整的报文</li><li>分组交换用较小的分组</li></ul><h3 id="所以哪种方式更好呢？"><a href="#所以哪种方式更好呢？" class="headerlink" title="所以哪种方式更好呢？"></a>所以哪种方式更好呢？</h3><p><strong>分组交换：传输延迟</strong></p><p>场景假设，源主机有两个分组信息需要发射，每个分组L bit大小</p><p>发送主机：</p><ul><li>接受应用报文（消息）</li><li>拆分为较小长度为L bits的分组</li><li>在传输速率为R的链路上进行传输</li></ul><h3 id="报文交换-vs-分组交换"><a href="#报文交换-vs-分组交换" class="headerlink" title="报文交换 vs 分组交换"></a>报文交换 vs 分组交换</h3><p>报文交换：</p><ul><li>报文长度为M bits</li><li>链路带宽为R bps</li><li>每次传输报文需要M&#x2F;R秒</li></ul><p>分组交换：</p><ul><li>报文被拆分为多个组</li><li>分组长度为L bits</li><li>每个分组传输时延为L&#x2F;R秒</li></ul><p>举例：</p><blockquote><p>M &#x3D; 7.5 Mbits</p><p>L &#x3D; 1500 bits</p><p>M &#x3D; 5000L</p><p>R &#x3D; 1.5 Mbps</p></blockquote><p>如果使用报文交换的时候，路由器的缓存就至少需要一个报文的大小</p><p>分组交换中，原来的主机是要把报文进行拆分拆分成分组，5000个分组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">title 报文交换</span><br><span class="line">section 时间分布</span><br><span class="line">    dateFormat YYYY-MM-DD</span><br><span class="line">    axisFormat %d</span><br><span class="line">empty:2023-1-1,9d</span><br><span class="line">M/R=7.5/1.5=5:2023-1-10,9d</span><br><span class="line">empty:2023-1-19,10d</span><br></pre></td></tr></table></figure><p>主要都采用分组交换技术</p><h1 id="分组交换的交付时间"><a href="#分组交换的交付时间" class="headerlink" title="分组交换的交付时间"></a>分组交换的交付时间</h1><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230807113712816.png" alt="image-20230807113712816" style="zoom:50%;" /><p>报文：M bits</p><p>链路带宽：（数据传输速率）：R bits</p><p>分组长度（大小）：L bits；</p><p>跳步数量：h</p><p>路由器数量：n &#x3D; h-1</p><p>$T_{传输时间}&#x3D;M&#x2F;R+(h-1)L&#x2F;R&#x3D;M&#x2F;R+nL&#x2F;R$</p><p>跳步指的是从一点到下一个相邻一点就叫做跳步（一个跳步等于链路数量）</p><p><strong><code>M/R</code> 是 整个报文的传输时间</strong></p><p><strong><code>L/R</code> 是 一个路由器的转发时间</strong> </p><h2 id="试题举例"><a href="#试题举例" class="headerlink" title="试题举例"></a>试题举例</h2><blockquote><p> 在下图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为100 M bps，分组大小为1 000 B，其中分组头大小为20 B。若主机H 1向主机H 2发送一个大小为980 000 B的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H 1发送开始到H 2接收完为止，需要的时间至少是多少?</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230807114528393.png" alt="image-20230807114528393"></p></blockquote><p>分组大小是1000 B，分组头占其中的20 B，所以有980 B携带的是报文数据；</p><p>至少是什么时间，指的是走最近的链路；</p><p>980 KB大小 的文件需要分1000个分组，每个分组1000 B。H 1发送整个文件需要的传输延迟为（980 000 + 20 * 1000 ）* <strong>8</strong> &#x2F; 100 000 000 &#x3D; 80 ms<strong>（注意单位换算）</strong>; <strong>根据路由选择基本定理</strong>，所有数据分组应该经过两个路由器的转发，所以再加上最后一个分组的两次转发的传输延迟，也就是 2 * 1000 * 8 &#x2F; 100 000 000 &#x3D; 0.16 ms。 所以，H 2接受完整个文件至少需要80 + 0.16 &#x3D; 80.16 ms</p><p><em>两次转发的延迟，因为是两个路由器，所以要加上。</em></p><p>例如：1 Mb&#x2F;s 链路</p><p>每个用户：</p><p>:heavy_check_mark: “活动” 时间需要100 Kb&#x2F;s</p><p>:heavy_check_mark: 每个用户的平均活动时间为10 %</p><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p>电路交换的特点是不能共享，虽然不传输数据但是其他用户是不能使用的，所以在这种情况下的效率很低。:togo:10个用户</p><h3 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h3><p>当一个用户活动的时候恰好赶上了另一个用户活动，可以将活动错开。:heavy_check_mark:对于35个用户，大于10个用户同时活动的概率&lt;0.0004</p><blockquote><p>分组交换允许更多用户同时使用网络！——网络资源充分共享</p></blockquote><h2 id="分组交换绝对由于电路交换？"><a href="#分组交换绝对由于电路交换？" class="headerlink" title="分组交换绝对由于电路交换？"></a>分组交换绝对由于电路交换？</h2><ul><li>适用于<strong>突发</strong>数据传输网络。<ul><li>资源充分共享</li><li>简单、无需呼叫建立  $\Rightarrow$ 可能产生拥塞：分组延迟和丢失</li><li>需要协议处理可靠数据传输和拥塞控制</li></ul></li><li>现在使用的计算机网络具备突发的数据传输特点。</li><li>但是视频传输和通话的传输不具备突发性。</li></ul><p>Q：如何提供电路级性能保障？打电话会出现停顿现象，所以需要使用协议来进行传输</p><hr><p>上一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.2 计算机网络的结构]]</p><p>下一页:  [[CourseNotes&#x2F;计算机网络&#x2F;CN-No.4 计算机网络性能]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.1 计算机网络基本概念</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]# 计算机网络基本概念<h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><p>计算机网络 &#x3D; 通信技术 + 计算机技术</p><ul><li>计算机网络是通信系统和计算机技术紧密结合的产物</li><li>通信系统模型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"> A(&quot;信源&quot;)</span><br><span class="line"> B(&quot;发送设备&quot;)</span><br><span class="line"> C(&quot;信道&quot;)</span><br><span class="line"> D(&quot;噪声源&quot;)</span><br><span class="line"> E(&quot;接受设备&quot;)</span><br><span class="line"> F(&quot;信宿&quot;)</span><br><span class="line"> A--&gt; B--&gt;C--&gt;E--&gt;F</span><br><span class="line"> D--&gt;C</span><br></pre></td></tr></table></figure><ul><li>计算机网络就是一种通信网络</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的自治的计算机集合</p><p>自治  → 没有主从关系</p><p>互联 → 互联互通</p><ul><li>通信链路</li><li>各个节点叫做主机，连接主机的叫做通信链路</li><li>距离远数量大的时候怎么保证互联</li></ul><p>通过<strong>交换网络</strong>互联主机</p><p>中间一个交换网络，主机连在交换网络上，交换网络里面的节点叫做交换节点</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Screenshot_20230713_151648.jpg" alt="Screenshot_20230713_151648.jpg"></p><h3 id="什么是Internet-组成细节角度"><a href="#什么是Internet-组成细节角度" class="headerlink" title="什么是Internet? - 组成细节角度"></a>什么是Internet? - 组成细节角度</h3><ul><li>全球的最大互联网络<ul><li>ISP( Internet Service Provider )网络互联的“网络的网络”</li><li>数以百万计的互联的计算设备集合：<ul><li>主机（host）&#x3D; 端系统（end system）</li><li><strong>运行各种网络应用</strong></li></ul></li><li>通信链路<ul><li>光纤，铜缆无线电等</li></ul></li><li>分组交换：转发分组(数据包)<ul><li>路由器（routers）和交换器（switches）</li></ul></li></ul></li></ul><h3 id="什么是Internet？-服务角度"><a href="#什么是Internet？-服务角度" class="headerlink" title="什么是Internet？ - 服务角度"></a>什么是Internet？ - 服务角度</h3><ul><li>为网络应用提供通信服务的通信基础设施：<ul><li>Web,VolP,email,网络游戏，电子商务，社交网络，……</li></ul></li><li>为网络应用提供编程接口（API）：<ul><li>支持应用程序“连接”Internet，发送&#x2F;接受数据</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Q： 仅有硬件链接Internet能否顺畅运行？能保证应用数据的有序交付吗？</p><p>A：No！ </p><p><strong>还需要协议！</strong></p><hr><p>下一页[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.2 计算机网络的结构]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.2 计算机网络的结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.2%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.2%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 计算机网络的结构<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><ul><li>主机</li><li>网络应用</li></ul><h2 id="接入网络、物理介质"><a href="#接入网络、物理介质" class="headerlink" title="接入网络、物理介质"></a>接入网络、物理介质</h2><ul><li>有限或者无线通信链路</li></ul><h2 id="核心网络（网络核心）"><a href="#核心网络（网络核心）" class="headerlink" title="核心网络（网络核心）"></a>核心网络（网络核心）</h2><ul><li>互联的路由器（或者分组转发设备）</li><li>网络之网络</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png" alt="Untitled"></p><h1 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a>网络边缘</h1><hr><h2 id="主机端系统"><a href="#主机端系统" class="headerlink" title="主机端系统"></a>主机端系统</h2><ul><li>位于网络边缘</li><li>运行网络应用程序</li></ul><h2 id="客户、服务器应用模型"><a href="#客户、服务器应用模型" class="headerlink" title="客户、服务器应用模型"></a>客户、服务器应用模型</h2><ul><li>客户端发送请求，服务端接受请求并作出响应</li><li>Web应用，文件传输FTP应用</li><li>所有的通信是在客户和服务器之间进行</li></ul><h2 id="对等应用模型"><a href="#对等应用模型" class="headerlink" title="对等应用模型"></a>对等应用模型</h2><ul><li>没有专用服务器</li><li>通信在对等实体之间相互进行</li><li>QQ</li></ul><h1 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h1><hr><ul><li>居民接入网络</li><li>机构接入网络</li><li>移动接入网络</li></ul><p><strong>用户关心的是</strong> </p><ul><li>带宽（bps）</li><li>接入方式是独占的还是共享的</li></ul><h2 id="代表性的接入网络"><a href="#代表性的接入网络" class="headerlink" title="代表性的接入网络"></a><strong>代表性的接入网络</strong></h2><aside>    <img src="https://www.notion.so/icons/merge_yellow.svg" alt="https://www.notion.so/icons/merge_yellow.svg" width="40px" /> <strong>Example 1： 数字用户线路</strong></aside><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.png" alt="Untitled"></p><ul><li>利用已有的电话网络来进行接入中心局的DSLAM<ul><li>数据通信通过DSL线接入internet</li><li>语音通过DLS线接入电话网络</li></ul></li><li>上行速率低，下行速率快</li><li>下行：&gt;50KHz ~ 1MHz<br>上行：4KHz ~ 50KHz<br>传统电话：0KHz ~ 4KHz</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png" alt="Untitled"></p><ul><li>频分多路复用技术：在不同的载波上传输不同的频道<ul><li>HFC 混合光纤同轴电缆</li><li>下行大于上行</li></ul></li></ul><p><strong>典型家庭网络的接入</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%203.png" alt="Untitled"></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%204.png" alt="Untitled"></p><ul><li>主要用于高校、企业、公司等机构</li><li>目前端系统通常直接连接以太网交换机（switch）</li></ul><h2 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h2><p>通过共享的无线接入网络连接端系统和路由器</p><ul><li>通过基站或者称为”接入点”</li></ul><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><ul><li>同一建筑物内（30m）</li></ul><h3 id="广域无线接入"><a href="#广域无线接入" class="headerlink" title="广域无线接入"></a>广域无线接入</h3><ul><li>3G 4G 5G</li></ul><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><hr><ul><li><p>互联的路由器网络</p></li><li><p>网络的核心功能：路由+转发</p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%205.png" alt="Untitled"></p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>  确定分组从源到目的传播路径</p><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>  将分组从路由器的输入端口交换至正确的输出端口</p></li></ul><h1 id="Internet-网络结构：网络之网络"><a href="#Internet-网络结构：网络之网络" class="headerlink" title="Internet 网络结构：网络之网络"></a>Internet 网络结构：网络之网络</h1><ul><li><p>端系统通过接入ISP（access ISP）连接到internet</p></li><li><p>接入ISP必须进一步互联</p></li><li><p>构成复杂的网络互连的网络：经济和国家政策是网络演进的主要推动力</p></li><li><p>当前的Internet网络结构是什么样的呢？动态性很强，无法给出描述</p></li><li><p>数以百万计的ISP是如何互联在一起的呢</p><p>  方案1： 全连接</p><p>  但是当基数过大会导致连接数量指数级增长</p><p>  方案2：构建一个全球的大ISP</p><p>  实际上不可能只有一个ISP</p><p>  最终情况：有多个大型的ISP来进行互联，再将大型的ISP进行互联 → 互联的方式：对等链路</p><p>  <img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%206.png" alt="Untitled"></p><p>  最后会用区域性的局域网络来连接每一部分的ISP，就构建好了整个的Internet网络</p></li></ul><hr><p>上一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.1 计算机网络基本概念]]<br>下一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.3 网络核心]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-NetworkLayer-Reading</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NetworkLayer-Reading/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NetworkLayer-Reading/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-NAT</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NAT/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NAT/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>网络地址转换（NAT）</p><h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h2><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016213809.png" alt="image.png" style="zoom: 67%;" /><p>本地网络内通信的IP数据包的源和目的IP地址均在子网10.0.0&#x2F;24内</p><p><strong>所有离开</strong>本地网络去往Internet的数据报的<strong>源IP地址</strong>需要替换成<strong>相同</strong>的NATIP地址：138.76.29.7以及<strong>不同</strong>的端口号。</p><h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>只能&#x2F;需要从ISP中申请一个IP地址，IPv4地址耗尽。</p><p>本地网络设备IP地址的变更，无需通告外界网络。</p><p>无论怎么变对外界来说都是一样的。</p><p>变更ISP的时候，无需修改内部网络设备IP地址</p><p>内部网络设备对外界网络不可见，也就是不可直接寻址（安全）</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IPD地址，源端口号）</p><h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>将每对（NAT IP地址，新端口号）和（源IP地址，源端口号）的替换信息存储到NAT转换表中</p><h4 id="替换-1"><a href="#替换-1" class="headerlink" title="替换"></a>替换</h4><p>根据NAT转换表，利用（源IP地址，源端口号）替换每个进入内网IP数据报的（目的IP地址，目的端口号），也就是（NAT IP地址，新端口号）</p><p><strong>16-bit端口号字段</strong>：65536 可以同时支持60，000多个并行连接</p><p><strong>NAT的主要争议</strong>：</p><ul><li><p>路由器应该只处理第三层功能</p></li><li><p>违背端到端的通信原则</p><ul><li>应用开发者必须考虑到NAT的存在，e.g P2P应用</li></ul></li><li><p>地址短缺问题应该由IPv6来解决</p></li></ul><h2 id="NAT穿透问题"><a href="#NAT穿透问题" class="headerlink" title="NAT穿透问题"></a>NAT穿透问题</h2><p>穿透问题：</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016215448627.png" alt="image-20231016215448627" style="zoom: 67%;" />10.0.0.1的服务器<ul><li><p>客户并不能直接利用地址10.0.0.1直接访问服务器</p></li><li><p>对外唯一课件的地址是NAT地址138.76.29.7</p></li></ul><p><strong>解决方案1：</strong> 静态配置NAT，将特定端口的连接请求转发给服务器</p><p>e.g.,(138.76.29.7,2500)总是转发给(10.0.0.1,25000)</p><p><strong>解决方案2</strong>：利用UPnP互联网网关设备协议（IGD-Internet Gateway Device）</p><ul><li><p>学习到NAT公共IP地址(138.76.29.7)</p></li><li><p>到NAT转发表中，增删端口映射</p></li></ul><p><strong>解决方案3</strong>：中继（e.g. Skype）</p><ul><li><p>NAT内部的客户和中继服务器建立连接</p></li><li><p>外部的客户也和中继服务器建立连接</p></li><li><p>中继服务器桥接两个连接的分组</p></li></ul><ol><li>connection to relay initiated byu NATed host</li><li>connection to relay initiated by client</li><li>relaying established</li></ol><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016220212.png" alt="image.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Lab4</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab4/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab4/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/697ba05420e5977359d220437080785.png" alt="697ba05420e5977359d220437080785.png"></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/6daf8280a4deff66b6f1e719217d621.png" alt="6daf8280a4deff66b6f1e719217d621.png"></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/872afc88738ffb252b96e868938e6e6.png" alt="872afc88738ffb252b96e868938e6e6.png"></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231031110917.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-lab2,3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-lab2,3/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Open File] --&gt; B&#123;File Empty?&#125;</span><br><span class="line">    B -- No --&gt; C[Read Data from File]</span><br><span class="line">    C --&gt; D&#123;Window Not Full?&#125;</span><br><span class="line">    D -- Yes --&gt; E[Send Data]</span><br><span class="line">    E --&gt; F&#123;Data Sent Successfully?&#125;</span><br><span class="line">    F -- Yes --&gt; G[Start Timer]</span><br><span class="line">    F -- No --&gt; H&#123;Wait and Retry?&#125;</span><br><span class="line">    H -- Yes --&gt; D</span><br><span class="line">    H -- No --&gt; J[Receive Acknowledgment]</span><br><span class="line">    J -- Updated Window --&gt; K&#123;End of File?&#125;</span><br><span class="line">    K -- Yes --&gt; L[Stop Sending]</span><br><span class="line">    K -- No --&gt; D</span><br><span class="line">    B -- Yes --&gt; L</span><br><span class="line">    J -- Lost Acknowledgment --&gt; M&#123;Resend Data&#125;</span><br><span class="line">    M -- Data Resent --&gt; F</span><br><span class="line">    J -- Data Received --&gt; N[Write Data to File]</span><br><span class="line">    N --&gt; O&#123;Window Not Empty?&#125;</span><br><span class="line">    O -- Yes --&gt; P[Update Base]</span><br><span class="line">    O -- No --&gt; Q&#123;Continue Receiving?&#125;</span><br><span class="line">    Q -- Yes --&gt; J</span><br><span class="line">    Q -- No --&gt; R[Stop Sending and Receiving]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP编址</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E7%BC%96%E5%9D%80/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E7%BC%96%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>IP分组：</p><p>源地址（SA）- 从哪里来</p><p>目的地址（DA）- 到哪里去</p><p>接口（interface）：主机&#x2F;路由器和物理链路的连接</p><ul><li>实现网络层的功能</li><li>路由器通常有多个接口</li><li>主机通常只有一个或者两个接口（e.g 有限的以太网接口，无线的802.11接口）</li></ul><h2 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h2><p>IP地址：32bit（IPv4）</p><p>编号标识主机、路由器的<strong>接口</strong></p><p>IP地址和每个接口关联</p><p>怎样为接口分配IP地址？</p><h2 id="IP子网-subnets"><a href="#IP子网-subnets" class="headerlink" title="IP子网 subnets"></a>IP子网 <code>subnets</code></h2><p>IP地址：</p><p>网络号（NETID）高位比特</p><p>主机号（HOSTID）低位比特</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015201817985.png" alt="image-20231015201817985" style="zoom:67%;" /><p>实际上的网络的标识方式如下：</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015201905891.png" alt="image-20231015201905891" style="zoom:67%;" /><p>可以用相同的网络号来描述相同区域的网络，称为IP<strong>子网</strong></p><p><strong>子网</strong>的IP地址的网络号是相同的，在所有网络里面所有的接口不超过三个网络设备就可以物理联通</p><p><strong>不跨越路由器</strong> （第三以及上层网络设备）可以彼此物理联通的接口</p><p>在存储向哪个网络转发数据的时候，只用知道子网地址就可以</p><p>可以用一个地址来描述子网：<strong>IP子网地址</strong></p><p>图中网络有多少个IP子网? 通过IP地址就能够描述一个个的描述地址和子网</p><p>一个个IP子网互联而形成的互联网络</p><p>接口对应的IP地址保留之后可以看到有一些网络是孤岛（也就是IP子网）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Lab1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h1 id="实验-1"><a href="#实验-1" class="headerlink" title="实验 1"></a>实验 1</h1><p><strong>HTTP 代理服务器的设计与实现代理服务器的设计与实现代理服务器的设计与实现</strong> </p><h2 id="1-1-1-实验⽬的"><a href="#1-1-1-实验⽬的" class="headerlink" title="1.1.1.实验⽬的"></a>1.1.1.实验⽬的</h2><p><strong>实验⽬的</strong> </p><p>熟悉并掌握 Socket ⽹络编程的过程与技术；</p><p>深⼊理解 HTTP 协议， 掌握 HTTP 代理服务器的基本⼯作原理；</p><p>掌握 HTTP 代理服务器设计与 编程实现的基本技能。 </p><h2 id="2-2-2-实验环境实验环境实验环境"><a href="#2-2-2-实验环境实验环境实验环境" class="headerlink" title="2.2.2.实验环境实验环境实验环境"></a>2.2.2.实验环境实验环境实验环境</h2><ul><li><p>接⼊ Internet 的实验主机； </p></li><li><p>Windows 操作系统； </p></li><li><p>开发语⾔：C&#x2F;C++（或 Java）等。</p></li></ul><h2 id="3-3-3-实验内容实验内容实验内容"><a href="#3-3-3-实验内容实验内容实验内容" class="headerlink" title="3.3.3.实验内容实验内容实验内容"></a>3.3.3.实验内容实验内容实验内容</h2><p>(1) 设计并实现⼀个基本 HTTP 代理服务器。要求在指定端⼝（例如 8080）接收来⾃客户的 HTTP 请求并且根据其中的 URL 地址访问该地址 所指向的 HTTP 服务器（原服务器），接收 HTTP 服务器的响应报⽂，并 将响应报⽂转发给对应的客户进⾏浏览。 </p><p>(2) 设计并实现⼀个⽀持 Cache 功能的 HTTP 代理服务器。要求能缓 存原服务器响应的对象，并能够通过修改请求报⽂（添加 if-modified-since 头⾏），向原服务器确认缓存对象是否是最新版本。（选作内容，加分项 ⽬，可以当堂完成或课下完成） </p><p>(3) 扩展 HTTP 代理服务器，⽀持如下功能：（选作内容，加分项⽬， 可以当堂完成或课下完成） </p><p>a) ⽹站过滤：允许&#x2F;不允许访问某些⽹站； </p><p>b) ⽤户过滤：⽀持&#x2F;不⽀持某些⽤户访问外部⽹站； </p><p>c) ⽹站引导：将⽤户对某个⽹站的访问引导⾄⼀个模拟⽹站（钓⻥）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP数据报</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E6%95%B0%E6%8D%AE%E6%8A%A5/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E6%95%B0%E6%8D%AE%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="Internet-网络层"><a href="#Internet-网络层" class="headerlink" title="Internet 网络层"></a>Internet 网络层</h2><p><strong>主机、路由器网络层主要功能：</strong></p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011104748.png" alt="image.png"></p><p>计算机网络层的协议：</p><p><strong>1. 路由协议</strong>：路径选择；RIP,OSPF,BGP；<br><strong>2. 转发表（路由表）</strong><br><strong>3. IP协议</strong>：寻址规约（conventions) ；数据报（分组）格式；分组处理规约<br><strong>4. ICMP协议</strong>：差错报告；路由器信令 —— IP协议的伴随协议</p><h2 id="IP数据报（分组）格式"><a href="#IP数据报（分组）格式" class="headerlink" title="IP数据报（分组）格式"></a>IP数据报（分组）格式</h2><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011105155.png" alt="image.png" style="zoom:67%;" /><p>将IP数据报展开得到的是：</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011105216.png" alt="image.png" style="zoom:50%;" />固定部分有20个字节<h3 id="版本号：4bit-IP协议的版本号"><a href="#版本号：4bit-IP协议的版本号" class="headerlink" title="版本号：4bit IP协议的版本号"></a><strong>版本号</strong>：4bit IP协议的版本号</h3><h3 id="首部长度：4bit-IP分组的首部长度"><a href="#首部长度：4bit-IP分组的首部长度" class="headerlink" title="首部长度：4bit IP分组的首部长度"></a><strong>首部长度</strong>：4bit IP分组的首部长度</h3><blockquote><p>4bit $\to$ 0 ~ 15  <strong>所以没有办法给出20的大小的</strong><br>所以以4字节为单位才能标识全；所以在计算的时候需要乘上4</p></blockquote><p>最典型的前面两段分别是 4 和 5</p><h3 id="服务类型（TOS）字段：-8bit-指示期望获得哪种类型的服务"><a href="#服务类型（TOS）字段：-8bit-指示期望获得哪种类型的服务" class="headerlink" title="服务类型（TOS）字段： 8bit 指示期望获得哪种类型的服务"></a><strong>服务类型（TOS）字段</strong>： 8bit 指示期望获得哪种类型的服务</h3><p>这个字段改名为 <strong>区分服务</strong></p><p>只有在网络提供区分服务（DiffDev）的时候使用</p><p>一般情况下这个字段都是00H</p><h3 id="总长度字段：16bit-IP分组的总字节数（首部-数据）"><a href="#总长度字段：16bit-IP分组的总字节数（首部-数据）" class="headerlink" title="总长度字段：16bit IP分组的总字节数（首部+数据）"></a><strong>总长度字段</strong>：16bit IP分组的总字节数（首部+数据）</h3><p>最大IP分组的总长度：65535B</p><p>最小的IP分组首部：20B</p><p>IP分组可以封装的最大数据：65535 -20 &#x3D; 65515B</p><h3 id="生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数量"><a href="#生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数量" class="headerlink" title="生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数量"></a><strong>生存时间（TTL）字段</strong>占8位：IP分组在网络中可以通过的路由器数量</h3><p>路由器转发一次分组，TTL减1</p><p>如果TTL&#x3D;0，路由器丢弃该IP分组</p><h3 id="协议字段占8位：指示IP分组封装的是哪个协议的数据包"><a href="#协议字段占8位：指示IP分组封装的是哪个协议的数据包" class="headerlink" title="协议字段占8位：指示IP分组封装的是哪个协议的数据包"></a><strong>协议字段</strong>占8位：指示IP分组封装的是哪个协议的数据包</h3><p>实现了复用&#x2F;分解</p><p>Eg 6为TCP，表示封装的是TCP段；17为UDP，表示封装的是UDP数据报</p><h3 id="首部校验和字段占16位：实现对IP分组首部的差错检测"><a href="#首部校验和字段占16位：实现对IP分组首部的差错检测" class="headerlink" title="首部校验和字段占16位：实现对IP分组首部的差错检测"></a><strong>首部校验和字段</strong>占16位：实现对IP分组首部的差错检测</h3><p>计算校验和的时候，该字段设置为全0</p><p>采用反码算数运算求和，和的反码作为首部校验和字段</p><p>逐跳计算、逐跳检验</p><h3 id="源IP地址、目的IP地址字段各占32位：分别表示发送分组的源主机-路由器（网络接口）和接受分组的目的主机-路由器（网路接口）的IP地址"><a href="#源IP地址、目的IP地址字段各占32位：分别表示发送分组的源主机-路由器（网络接口）和接受分组的目的主机-路由器（网路接口）的IP地址" class="headerlink" title="源IP地址、目的IP地址字段各占32位：分别表示发送分组的源主机&#x2F;路由器（网络接口）和接受分组的目的主机&#x2F;路由器（网路接口）的IP地址"></a><strong>源IP地址、目的IP地址字段</strong>各占32位：分别表示发送分组的源主机&#x2F;路由器（网络接口）和接受分组的目的主机&#x2F;路由器（网路接口）的IP地址</h3><h3 id="选项字段占用长度可变，范围在1-40B之间；携带安全、源选路径、时间戳和路由记录等内容"><a href="#选项字段占用长度可变，范围在1-40B之间；携带安全、源选路径、时间戳和路由记录等内容" class="headerlink" title="选项字段占用长度可变，范围在1~40B之间；携带安全、源选路径、时间戳和路由记录等内容"></a><strong>选项字段</strong>占用长度可变，范围在1~40B之间；携带安全、源选路径、时间戳和路由记录等内容</h3><p>实际上很少被使用</p><h3 id="填充字段占长度可变，范围在0-3B之间；目的是不起整个首部符合32位对齐"><a href="#填充字段占长度可变，范围在0-3B之间；目的是不起整个首部符合32位对齐" class="headerlink" title="填充字段占长度可变，范围在0~3B之间；目的是不起整个首部符合32位对齐"></a><strong>填充字段</strong>占长度可变，范围在0~3B之间；目的是不起整个首部符合32位对齐</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP子网划分和子网掩码</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>A类网络的网络数量很少，C类网络的网络数量太多，B类网络编址的网络也容易被浪费掉。</p><h2 id="子网划分（Subnetting）？"><a href="#子网划分（Subnetting）？" class="headerlink" title="子网划分（Subnetting）？"></a>子网划分（Subnetting）？</h2><p>有类地址在描述的过程中会出现的问题</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205436105.png" alt="image-20231015205436105" style="zoom: 50%;" /><p>在实际网络中A类网络和B类网络肯定不可能</p><p>就需要对大的网络区分成更小的网络范围：<strong>子网划分</strong></p><p>怎么划分？  – <strong>IP地址上做文章</strong></p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205608325.png" alt="image-20231015205608325" style="zoom: 67%;" /><p>使用主机里面的IP比特之间进行划分</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205750642.png" alt="image-20231015205750642" style="zoom:67%;" /><p>其他的子网就不会受到通信的影响</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205827679.png" alt="image-20231015205827679" style="zoom:67%;" /><p>通过<strong>路由器</strong>来进行转发</p><h3 id="Q：如何确定是否划分了子网？利用多少位来划分子网？"><a href="#Q：如何确定是否划分了子网？利用多少位来划分子网？" class="headerlink" title="Q：如何确定是否划分了子网？利用多少位来划分子网？"></a>Q：如何确定是否划分了子网？利用多少位来划分子网？</h3><p>区分的越多，地址空间就会小，所以子网的方式也很重要。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>形如IP地址：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015210018797.png" alt="image-20231015210018797"></p><p>32位</p><p>点分十进制形式</p><p>取值：</p><p>NetID、SubID位全部取1</p><p>HostID位全取0</p><p>例如：</p><p>A网的默认子网掩码为：255.0.0.0</p><p>B网的默认子网掩码为：255.255.0.0</p><p>C网的默认子网掩码为：255.255.255.0</p><p>借用3bit划分子网的B网的子网掩码为255.255.224.0</p><blockquote><p>[!子网地址 + 子网掩码]</p><p>准确确定子网大小</p></blockquote><p><strong>For example</strong></p><p>子网：201.2.3.0，255.255.255.0</p><p>划分为登场的4个子网</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015210455295.png" alt="image-20231015210455295" style="zoom:67%;" /><p>利用路由器来互联在一起</p><p><strong>路由器怎么确定应该将IP分组进行转发</strong>?</p><blockquote><p>将IP分组的目的IP地址和子网掩码 按位与运算，提取紫菀地址子网地址</p></blockquote><p>例如：</p><ul><li>目的IP地址：172.32.1.112，子网掩码：255.255.254.0</li></ul><p>172.32.1.112 &#x3D; 10101100 001000000 00000001 01110000<br>255.255.255.254.0 &#x3D; 11111111 11111111 11111110 00000000</p><p>子网地址：172.32.0.0（子网掩码：255.255.254.0）<br>地址范围：172.32.0.0 ~ 172.32.1.255<br>可分配地址范围：172.32.0.1 ~ 172.32.1.254<br>广播地址：172.32.1.255</p><p><strong>一个C类网络划分子网举例</strong>：</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015211156.png" alt="image.png" style="zoom:67%;" /><p>最左侧的列对应的是每一侧子网的子网地址，最右侧代表的是广播地址</p><p>会造成一部分的浪费</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IPv6</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IPv6/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IPv6/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="IPv6：-动机"><a href="#IPv6：-动机" class="headerlink" title="IPv6： 动机"></a>IPv6： 动机</h2><p>最初动机：32位的IPv4的地址空间已经分配殆尽</p><p>其他动机：改进首部格式</p><ul><li>快速处理&#x2F;转发数据报</li><li>支持QoS</li></ul><p><strong>IPv6的数据报格式</strong>：</p><ul><li>固定长度的40字节基本首部</li><li>不允许分片 路由器不再支持分片，如果发生IP数据包的分片的话，需要在主机分片。</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022124955.png" alt="image.png"></p><p>基本的首部</p><p>其他的首部称为选项首部（大部分情况下路由器是不需要处理的）</p><p>路由处理只需要处理40字节的基本头</p><p>这些选项首部和数据部分称为<strong>载荷</strong></p><h2 id="IPv6数据报的格式"><a href="#IPv6数据报的格式" class="headerlink" title="IPv6数据报的格式"></a>IPv6数据报的格式</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022125154.png" alt="image.png"></p><p><code>优先级</code>（priority）:标识数据报文的优先级<br><code>流标签</code>（flow Label）：标识同一流中的标签</p><blockquote><p>更详细的定义还在讨论当中</p></blockquote><p>载荷的长度一共是16bit，可以表示65535的长度范围</p><p><code>下一个首部</code>指向的是第一个扩展首部，每一个扩展首部都指向下一个首部</p><p>也就是每个首部之间互相连接</p><p>跳步限制：对应了数据报在转发过程中能够通过的路由器总数</p><h2 id="IPv6和IPv4相比的改变"><a href="#IPv6和IPv4相比的改变" class="headerlink" title="IPv6和IPv4相比的改变"></a>IPv6和IPv4相比的改变</h2><p>校验和：彻底移除，以较少每跳处理时间，减少数据包的处理时间</p><p>选项(options)：允许，但是从基本首部移除，定义多个选项首部，通过下一个首部字段来指示</p><p>ICMPv6：新版的ICMP：</p><ul><li>附加报文类型 <code>Packet too big</code></li><li>多播组管理功能</li></ul><p>发送Packet too big报文转发给主机，让主机来进行分片</p><p><code>IGMP协议</code> 也就是多播组的协议，这个被集成到了IPv6之中了</p><h2 id="IPv6地址表示形式"><a href="#IPv6地址表示形式" class="headerlink" title="IPv6地址表示形式"></a>IPv6地址表示形式</h2><p>地址相当庞大，所以不能使用IPv4的点分十进制的方法</p><p>IPv6地址表示形式：冒号分割的十六进制的表示形式</p><p>一般形式：1080：0：FF：0：8：800：200C：417A</p><p>压缩形式：不能连续的两次使用连接的冒号，只用使用一次连续的冒号</p><p>IPv4的嵌入形式：0：0：0：0：0：FFFF：13.1.68.3 后面就是IPv4的嵌入形式，后面可以使用点分十进制</p><p>地址前缀：2002：43C：476b：：&#x2F;48</p><p>IPv6已经不再使用掩码的方式 利用一个斜杠加网络前缀的方式表示</p><p>URLs：http:&#x2F;&#x2F;[3FFE::1:800:200C:417A]:8000 表示形式不出现歧义</p><h2 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h2><p>单播地址(unicast):一对一通信</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022130656.png" alt="image.png"></p><p>多播地址(unicast):一对多通信</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022130704.png" alt="image.png"></p><p>没有单独的广播地址，广播地址被定义为特殊的多播地址</p><p>又定义了一种全新的数据类型：</p><p>任意播（anycast）：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022130825.png" alt="image.png"></p><p>发送到最近的接口上去</p><h2 id="IPv4向IPv6过渡"><a href="#IPv4向IPv6过渡" class="headerlink" title="IPv4向IPv6过渡"></a>IPv4向IPv6过渡</h2><p>不可能在某个时刻所有路由器同时被更新位IPv6</p><ul><li><p>不会有“标志性的日期”</p></li><li><p>IPv4和IPv6路由器共存的网络如何运行？</p></li></ul><p><strong>隧道</strong>：IPv6数据包作为IPv4数据包的载荷进行封装</p><h2 id="Tunneling-隧道"><a href="#Tunneling-隧道" class="headerlink" title="Tunneling 隧道"></a>Tunneling 隧道</h2><p>逻辑隧道：利用IPv4隧道，连接IPv6路由器</p><p>物理视角：</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022131114.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP分片</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%88%86%E7%89%87/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%88%86%E7%89%87/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p><strong>最大传输单元</strong></p><p>数据帧 IP分组</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231013111455.png" alt="image.png" style="zoom:67%;" /><p>网络链路存在MTU（最大传输单元）——  链路层数据帧可以封装数据的上限</p><p>不同链路的MTU<strong>不相同</strong></p><p>IP分片和重组问题，大IP分组向较小的MTU链路进行转发的时候，可以被分片(fragmented) <strong>也不是一定要进行分片</strong></p><p>大IP分组分片为多个小分组</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013112045421.png" alt="image-20231013112045421" style="zoom:67%;" /><p>IP分组的分片只分不装</p><p>IP分片的过程中不知道顺序关系</p><p>IP首部的相关字段用于表示分片以及确定分片的相对顺序</p><p><strong>标识字段占16位：标识一个IP分组</strong></p><p>IP协议利用一个计数器，没产生IP分组计数器加1，作为该IP分组的标识</p><p>标志位字段占3位：</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013113324350.png" alt="image-20231013113324350" style="zoom:67%;" /><p>DF禁止分片 MF更多分片</p><p>DF &#x3D; 1 禁止分片</p><p>DF &#x3D; 0 允许分片</p><p>MF &#x3D; 1 不是最后一片</p><p>MF &#x3D; 0 最后一片</p><p>片偏移字段占13位：一个IP分组分片封装原IP分组数据的相对偏移量</p><p>片偏移字段是由8字节为单位（和首部长度一样的问题）</p><p>在IP分组分片的过程中分片的数量一定是8的倍数</p><p>加收原来的IP分组总长度为L，带转发链路的MTU为M，如果L&gt;M且DF&#x3D;0，则可以&#x2F;需要分片的时候每个分片的标识赋值原IP分组的标识</p><p>分片出来的所有IP分组都是一样的标识</p><p>通常分片的时候，除了最后一个分片，其他分片均分为MTU允许的最大分片</p><p>一个最大分片可以封装的数据应该是8的倍数，因此，一个最大分片可以封装的数据是：$d &#x3D; [\frac{M-20}{8}]\times8$</p><p>需要的总片数为：$n&#x3D;[\frac{L -20}{d}]+1$</p><p>IP分片的过程</p><p>每一篇的片偏移量的取值为：$F_i&#x3D;\frac{d}{8}\times (i-1) , 1 \leq i \leq n$</p><p><strong>每一片的总长度字段</strong>：</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013121039621.png" alt="image-20231013121039621" style="zoom:50%;" /><p>每片的MF标志位为：</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013121128043.png" alt="image-20231013121128043" style="zoom:50%;" /><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013121142845.png" alt="image-20231013121142845" style="zoom: 50%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-ICMP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ICMP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ICMP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="互联网控制报文协议（ICMP）"><a href="#互联网控制报文协议（ICMP）" class="headerlink" title="互联网控制报文协议（ICMP）"></a>互联网控制报文协议（ICMP）</h2><h3 id="互联网控制报文协议ICMP（Internet-Control-Message-Protocol）"><a href="#互联网控制报文协议ICMP（Internet-Control-Message-Protocol）" class="headerlink" title="互联网控制报文协议ICMP（Internet Control Message Protocol）"></a>互联网控制报文协议ICMP（Internet Control Message Protocol）</h3><p>支持主机和路由器：</p><ul><li><p>差错（或者异常）报告</p></li><li><p>网络查询</p></li></ul><h3 id="两类ICMP报文"><a href="#两类ICMP报文" class="headerlink" title="两类ICMP报文"></a>两类ICMP报文</h3><h4 id="差错报告报文（5种）"><a href="#差错报告报文（5种）" class="headerlink" title="差错报告报文（5种）"></a>差错报告报文（5种）</h4><p>目的不可达 </p><p>丢弃的报文可以通过ICMP协议来进行请求</p><p>源抑制</p><p>超时&#x2F;超期</p><p>参数问题</p><p>重定向（Redirect）</p><h4 id="网络探寻报文-2组"><a href="#网络探寻报文-2组" class="headerlink" title="网络探寻报文(2组)"></a>网络探寻报文(2组)</h4><p>回声请求和应答报文</p><p>时间戳请求和应答报文</p><h2 id="ICMP报文"><a href="#ICMP报文" class="headerlink" title="ICMP报文"></a>ICMP报文</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016222307.png" alt="image.png"></p><h2 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h2><h3 id="几种不发送ICMP差错报告报文的特殊情况"><a href="#几种不发送ICMP差错报告报文的特殊情况" class="headerlink" title="几种不发送ICMP差错报告报文的特殊情况"></a>几种不发送ICMP差错报告报文的特殊情况</h3><ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>除了第一个IP数据报分片之外，对所有后续分片均不发送ICMP差错报告报文</li><li>对所有多播IP数据报均不发送ICMP差错报告报文</li><li>对具有特殊地址（127.0.0.0或者0.0.0.0）的IP数据报不发送ICMP差错报告报文</li></ul><h3 id="几种ICMP报文不再使用"><a href="#几种ICMP报文不再使用" class="headerlink" title="几种ICMP报文不再使用"></a>几种ICMP报文不再使用</h3><ul><li>信息请求和应答报文</li><li>子网掩码请求和应答报文</li><li>路由器询问和通告报文</li></ul><h2 id="ICMP报文的格式"><a href="#ICMP报文的格式" class="headerlink" title="ICMP报文的格式"></a>ICMP报文的格式</h2><p>ICMP报文封装到IP数据报中传输</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016222940.png" alt="image.png" style="zoom:50%;" /><h2 id="ICMP差错报告报文数据封装"><a href="#ICMP差错报告报文数据封装" class="headerlink" title="ICMP差错报告报文数据封装"></a>ICMP差错报告报文数据封装</h2><p>差错IP数据报</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016223503690.png" alt="image-20231016223503690" style="zoom:50%;" /><h2 id="ICMP的应用举例：Traceroute"><a href="#ICMP的应用举例：Traceroute" class="headerlink" title="ICMP的应用举例：Traceroute"></a>ICMP的应用举例：Traceroute</h2><h3 id="源主机向目的主机发送一系列UDP数据报"><a href="#源主机向目的主机发送一系列UDP数据报" class="headerlink" title="源主机向目的主机发送一系列UDP数据报"></a>源主机向目的主机发送一系列UDP数据报</h3><p>第一组IP数据报TTL &#x3D; 1</p><p>第二组IP数据报TTL &#x3D; 2，etc</p><p>目的端口号为不可能使用的端口号</p><h3 id="当第n组数据包（TTL-n）到达第n个路由器时"><a href="#当第n组数据包（TTL-n）到达第n个路由器时" class="headerlink" title="当第n组数据包（TTL &#x3D; n）到达第n个路由器时"></a>当第n组数据包（TTL &#x3D; n）到达第n个路由器时</h3><p>路由器丢弃数据包</p><p>向源主机发送ICMP报文</p><p>ICMP报文携带路由器名称和IP地址信息</p><h3 id="当ICMP报文返回源主机的时候，记录RTT"><a href="#当ICMP报文返回源主机的时候，记录RTT" class="headerlink" title="当ICMP报文返回源主机的时候，记录RTT"></a>当ICMP报文返回源主机的时候，记录RTT</h3><p><strong>停止准则</strong></p><p>UDP数据包最终到达目的主机</p><p>目的主机返回目的端口不可达ICMP报文</p><p>源主机停止</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-HTTP连接类型</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]# HTTP连接<h2 id="非持久性连接（Nopersistent-HTTP）"><a href="#非持久性连接（Nopersistent-HTTP）" class="headerlink" title="非持久性连接（Nopersistent HTTP）"></a>非持久性连接（Nopersistent HTTP）</h2><ul><li>每个TCP连接最多允许传输一个&#96;非持久性连接</li></ul><h2 id="持久性连接（Persitent-HTTP）"><a href="#持久性连接（Persitent-HTTP）" class="headerlink" title="持久性连接（Persitent HTTP）"></a>持久性连接（Persitent HTTP）</h2><ul><li>每个TCP连接允许<code>传输多个对象</code></li><li>HTTP 1.1 版本默认使用<strong>持久性连接</strong></li></ul><h2 id="非持久性连接"><a href="#非持久性连接" class="headerlink" title="非持久性连接"></a>非持久性连接</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917102927.png" alt="Pasted image 20230917102927"><br><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917102939.png" alt="Pasted image 20230917102939"></p><p><a href="http://www.someschool.edu/someDepartment/home.index">www.someSchool.edu/someDepartment/home.index</a> $\rightarrow$ (包含文本和指向10个jepg图片的链接)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    1A(&quot;1a:HTTP客户端向地址为\nwww.someSchool.edu/someDepartment/home.index\n的服务器上的HTTP服务器进程（端口80）\n发起TCP连接请求&quot;)--&gt;1B(&quot;1b:HTTP服务器在端口80等待TCP连接请求，接受链接并通知客户端&quot;)</span><br><span class="line">    1B--&gt; 2(&quot;2:HTTP客户端将HTTP请求消息（包含URL地址）\n通过TCP链接的套接字发出，\n消息中所含有的URL表明客户端需要对象\n someDepartment/home.index&quot;)</span><br><span class="line">    2--&gt;3(&quot;3:HTTP服务器收到请求消息，\n 解析，产生包含所需要对象的相应消息,\n并通过套接字发送给客户端&quot;)</span><br><span class="line">    3--&gt;4(&quot;4:HTTO服务器关闭TCP连接&quot;)</span><br><span class="line">    4--&gt;5(&quot;5:HTTP客户端收到响应消息，\n解析html文件，发现有10个指向jepg对象的超链接&quot;)</span><br><span class="line">    6(&quot;对每个jepg对象重复步骤1-5&quot;)</span><br></pre></td></tr></table></figure><h2 id="响应时间分析和建模"><a href="#响应时间分析和建模" class="headerlink" title="响应时间分析和建模"></a>响应时间分析和建模</h2><h3 id="RTT-Round-Trip-Time"><a href="#RTT-Round-Trip-Time" class="headerlink" title="RTT(Round Trip Time)"></a>RTT(Round Trip Time)</h3><ul><li>从客户端发送一个很小的数组包到服务器并返回所经历的时间</li></ul><h3 id="响应时间-Response-time"><a href="#响应时间-Response-time" class="headerlink" title="响应时间(Response time)"></a>响应时间(Response time)</h3><ul><li><p>发起、建立TCP连接：<strong>一个RTT</strong></p></li><li><p>发送HTTP请求消息到HTTP响应消息的前几个字节到达：<strong>一个RTT</strong></p></li><li><p>响应消息中所含有的文件&#x2F;对象传输时间</p></li><li><p>Total &#x3D; 2RTT + 文件发送时间</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911205654485.png" alt="image-20230911205654485" style="zoom:67%;" /></li></ul><h2 id="持久性HTTP"><a href="#持久性HTTP" class="headerlink" title="持久性HTTP"></a>持久性HTTP</h2><h3 id="非持久性连接的问题"><a href="#非持久性连接的问题" class="headerlink" title="非持久性连接的问题"></a>非持久性连接的问题</h3><ul><li><p>每个对象都需要<code>2个RTT</code></p></li><li><p>操作系统需要为每个TCP连接开销资源(<em><strong>overhead</strong></em>)</p></li><li><p><strong>浏览器</strong>会怎么做：</p><ul><li>打开<strong>多个并行的TCP连接</strong>以获取网页所需要的对象</li><li>给服务器端造成什么影响？<ul><li>会造成很大的负担（是有代价的,<strong>TCP很宝贵</strong>）</li></ul></li></ul></li></ul><h3 id="持久性连接"><a href="#持久性连接" class="headerlink" title="持久性连接"></a>持久性连接</h3><ul><li><p>发送响应后，服务器<code>保持TCP连接的打开</code></p></li><li><p>后续的HTTP消息可以用通过这个直接连接发送</p></li></ul><h4 id="无流水的持久性连接"><a href="#无流水的持久性连接" class="headerlink" title="无流水的持久性连接"></a>无流水的持久性连接</h4><ul><li><p>客户端只有<strong>收到前一个响应之后才发送新的请求</strong></p></li><li><p>每个被应用对象耗时<strong>1RTT</strong></p></li></ul><h4 id="带有流水机制的持续性连接"><a href="#带有流水机制的持续性连接" class="headerlink" title="带有流水机制的持续性连接"></a>带有流水机制的持续性连接</h4><ul><li>HTTP 1.1的默认选项</li><li>客户端只要<em>遇到一个应用对象就会</em>尽快发出请求</li><li>理想情况下，收到所有应用对象只需要耗时大约一个RTT<br>[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.5 计算机网络的体系结构]]</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-HTTP消息格式</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]# HTTP请求消息<h2 id="HTTP有两类消息"><a href="#HTTP有两类消息" class="headerlink" title="HTTP有两类消息"></a>HTTP有两类消息</h2><ul><li>请求消息</li><li>响应消息</li></ul><h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2><p><strong>ASCII</strong>：人直接可读</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917103514.png" alt="Pasted image 20230917103514"></p><h2 id="HTTP请求消息的通用格式"><a href="#HTTP请求消息的通用格式" class="headerlink" title="HTTP请求消息的通用格式"></a>HTTP请求消息的通用格式</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917104130.png" alt="Pasted image 20230917104130"></p><h2 id="上传输入的方法"><a href="#上传输入的方法" class="headerlink" title="上传输入的方法"></a>上传输入的方法</h2><p><strong>POST方法</strong></p><ul><li>网页需要填写表格</li><li>在请求消息的消息体（<strong>entity body</strong>）中上传客户端的输入</li></ul><p><strong>URL方法</strong></p><ul><li>使用GET方法</li><li>输入信息通过request行的URL字段上传</li></ul><h2 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h2><p><em>HTTP</em>&#x2F;1.0</p><ul><li>GET&#x2F;POST&#x2F;[[CourseNotes&#x2F;计算机网络&#x2F;CN-HEAD]]</li></ul><p><em>HTTP</em>&#x2F;1.1</p><ul><li>GET,POST,HEAD</li><li>[[CourseNotes&#x2F;计算机网络&#x2F;CN-PUT]]</li><li>[[CourseNotes&#x2F;计算机网络&#x2F;CN-DELETE]]</li></ul><h2 id="HTTP的响应消息"><a href="#HTTP的响应消息" class="headerlink" title="HTTP的响应消息"></a>HTTP的响应消息</h2><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917104921.png" alt="Pasted image 20230917104921"></p><h2 id="HTTP响应状态代码"><a href="#HTTP响应状态代码" class="headerlink" title="HTTP响应状态代码"></a>HTTP响应状态代码</h2><ul><li><p>响应消息是第一行</p></li><li><p>示例</p><ul><li>200 OK</li><li>301 Moved Permanently</li><li>400 Bad Requeast</li><li>404 Not Found</li><li>505 HTTP Version Not Supported</li></ul></li></ul><h2 id="体验一下HTTP"><a href="#体验一下HTTP" class="headerlink" title="体验一下HTTP"></a>体验一下HTTP</h2><p>利用telnet 登录到某个Web服务器</p><ul><li>telnet <a href="http://www.hit.edu.cn/">www.hit.edu.cn:80</a></li></ul><p>输入一个HTTP请求</p><ul><li>GET&#x2F;about&#x2F;profile.html <strong>HTTP&#x2F;1.1</strong></li><li>Host: <a href="http://www.hit.edu.cn/">www.hit.edu.cn</a></li></ul><p>查看HTTP服务器所返回的响应消息</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework5-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework5-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework5-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>#task<br><strong>如图所示网络。</strong></p><p>​</p><p><img src="https://edu-image.nosdn.127.net/9C515BE4A654FA395BE5952B80162EDE.png?imageView&thumbnail=520x520&quality=100"></p><p>请回答下列问题：<br>(1)主机在配置IP地址时，其正确的子网掩码和默认网关分别是多少？</p><p>​</p><p>(2)若路由器R在向互联网转发一个由主机192.168.1.5发送、ID&#x3D;12345、length&#x3D;500B、DF&#x3D;1的IP分组时，则该IP分组首部的哪些字段会被修改？如何修改？</p><p>​</p><p>(3)若主机192.168.1.10向互联网ID&#x3D;6789、length&#x3D;1500B、DF&#x3D;0的IP分组时，路由器需要将该IP分组分为几片（每片尽可能封装为最大片）？给出分片结果，包括每片的ID、DF、MF、length、offset的取值。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework4-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework4-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework4-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>#task 假设A、B两个端系统通过唯一的一条8Mbps链路连接（M&#x3D;10^6），该链路的双向传播时延是150ms；A通过一个TCP连接向B发送一个大文件，B的接收缓存足够大，每个TCP段最大段长度（MSS）为1500字节，TCP采用Reno版本，且总是处于拥塞避免阶段（即忽略慢启动）。请回答下列问题：</p><ol><li>该TCP连接能够获得的最大窗口尺寸（以TCP段数计）是多少？</li></ol><p>‏<br>2. 该TCP连接的平均窗口尺寸（以TCP段数计）和平均吞吐量（以bps计）是多少？</p><p>‏<br>3. 该TCP连接的拥塞窗口从发生丢包到恢复到最大窗口尺寸要经历多长时间？</p><p>‏</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework2-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework2-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework2-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>假设你在浏览某网页时点击了一个超链接，URL为“https://www.kicker.com.cn/index.html”，且该URL对应的IP地址在你的计算机上没有缓存；文件index.html引用了8个小图像。域名解析过程中，无等待的一次DNS解析请求与响应时间记为RTTd，HTTP请求传输Web对象过程的一次往返时间记为RTTh。请回答下列问题： <p>‍1）你的浏览器解析到URL对应的IP地址的最短时间是多少？最长时间是多少？</p><p><strong>浏览器解析到URL对应的IP地址最短时间是RTTd，最长时间是5RTTd。</strong></p><p>‍2）若浏览器没有配置并行TCP连接，则基于HTTP1.0获取URL链接Web页完整内容（包括引用的图像，下同）需要多长时间（不包括域名解析时间，下同）？</p><p><strong>如果浏览器没有配置并行TCP连接，则基于HTTP1.0获取链接Web页面完整内容所需要的时间为18RTTh</strong><br>‏<br>‍3) 若浏览器配置5个并行TCP连接，则基于HTTP1.0获取URL链接Web页完整内容需要多长时间？</p><p><strong>如果浏览器配置5个并行TCP连接，那么基于HTTP1.0获取URL链接Web页面时间为6RTTh</strong>*</p><p>‍4) 若浏览器没有配置并行TCP连接，则基于非流水模式的HTTP1.1获取URL链接Web页完整内容需要多长时间？基于流水模式的HTTP1.1获取URL链接Web页完整内容需要多长时间？</p><p><strong>如果浏览器没有配置并行TCP连接，基于非流水模式的HTTP1.1获取URL链接Web页完整内容需要的时间为3RTTh</strong><br>‏</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework3-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework3-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework3-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>(18 分） 考虑向 N 个对等方（用户）分发 F&#x3D;15Gb 的一个文件。该服务器具有 us&#x3D;30Mbps 的上传速率，每个对等方的下载速率 di&#x3D;2Mbps，上传速率为 u。请分别针对客户-服务器分发模式和 P2P 分发模式两种情况，对于 N&#x3D;10、 100 和 1000 以及 u&#x3D;500kbps、 1Mbps 和 2Mbps 的每种组合，绘制最小分发时间图表。（注： k&#x3D;10^3、 M&#x3D;10^6、 G&#x3D;10^9）</p><p><strong>列表如下所示：</strong></p><table><thead><tr><th>C&#x2F;S Mode</th><th>N&#x3D;10</th><th>N&#x3D;100</th><th>N&#x3D;1000</th></tr></thead><tbody><tr><td>500kbps</td><td>7500s</td><td>50000s</td><td>500000s</td></tr><tr><td>1Mbps</td><td>7500s</td><td>50000s</td><td>500000s</td></tr><tr><td>2Mbps</td><td>7500s</td><td>50000s</td><td>500000s</td></tr></tbody></table><table><thead><tr><th>P2P Mode</th><th>N&#x3D;10</th><th>N&#x3D;100</th><th>N&#x3D;1000</th></tr></thead><tbody><tr><td>500kbps</td><td>7500s</td><td>18750s</td><td>28302s</td></tr><tr><td>1Mbps</td><td>7500s</td><td>11538s</td><td>14563s</td></tr><tr><td>2Mbps</td><td>7500s</td><td>7500s</td><td>7500s</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework1-3</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-3/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## 题目3<p>假设主机A向主机B以存储-转发的分组交换方式发送一个大文件。主机A到达主机B的路径上有3段链路，其速率分别是R1&#x3D;500kbps，R2&#x3D;2Mbps，R3&#x3D;1Mbps。试求：</p><ol><li>假设网络没有其他流量，则传送该文件的吞吐量是多少？</li></ol><blockquote><p>吞吐量选择其中传输速率最小的链路：500kbps</p></blockquote><ol start="2"><li>假设文件大小为4MB，则传输该文件到主机B大约需要多少时间？</li></ol><blockquote><p>$T &#x3D; 4MB&#x2F;R &#x3D; 4*10^3&#x2F;500kbps &#x3D; 64s$</p></blockquote><h2 id="注：1k-10-3-1M-10-6"><a href="#注：1k-10-3-1M-10-6" class="headerlink" title="(注：1k&#x3D;10^3^,1M&#x3D;10^6^)"></a><strong>(注：1k&#x3D;10^3^,1M&#x3D;10^6^)</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework1-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## 题目2<p>( 10分 )</p><p>考虑两台主机A和主机B由一条带宽为R bps、长度为M米的链路互连，信号传播速率为V m&#x2F;s。假设主机A从t&#x3D;0时刻开始向主机B发送分组，分组长度为L比特。试求：</p><ol><li>传播延迟（时延）dp；</li></ol><blockquote><p>dp &#x3D; M &#x2F; V</p></blockquote><ol start="2"><li>传输延迟dt；</li></ol><blockquote><p>dt &#x3D; L &#x2F; R</p></blockquote><ol start="3"><li>若忽略结点处理延迟和排队延迟，则端到端延迟de是多少？</li></ol><blockquote><p>de &#x3D; dt + dp</p></blockquote><ol start="4"><li>若dp&gt;dt，则t&#x3D;dt时刻，分组的第一个比特在哪里？</li></ol><blockquote><p>此时还没有到达主机，所以第一个比特在距离A主机 $\frac{M}{V} \times dt$ 的位置处</p></blockquote><ol start="5"><li>若V&#x3D;250000km&#x2F;s，L&#x3D;512比特，R&#x3D;100 Mbps，则使带宽时延积刚好为一个分组长度（即512比特）的链路长度M是多少？</li></ol><blockquote><p>带宽时延积 &#x3D; $dp \times R$</p><p>代入带宽时延积为512bit，$dp &#x3D; \frac{512bit}{100Mbps} &#x3D; 5.12 \times 10^{-6} s&#x3D;\frac{M}{V}&#x3D;\frac{M}{250000km&#x2F;s}$</p><p>可以解得dp &#x3D; 1024m</p></blockquote><p><strong>(注：1k&#x3D;10^3^,1M&#x3D;10^6^)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-HEAD</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HEAD/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HEAD/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]请Server不要将所请求的对象放入响应消息中]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework1-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## 题目1<p>( 14分 )</p><p>如图所示网络。A在t&#x3D;0时刻开始向C发送一个2Mbits的文件；B在t&#x3D;0.1+e秒（e为无限趋近于0的小正实数）向D发送一个1Mbits的文件。忽略传播延迟和结点处理延迟。</p><p>请回答下列问题：</p><ol><li>如果图中网络采用存储-转发方式的报文交换，则A将2Mbits的文件交付给C需要多长时间？B将1Mbits的文件交付给D需要多长时间？</li></ol><blockquote><p>（1）500ms。由于采用报文交换，只有A来进行传输，B的传输不会影响A的传输。设左边的路由器为F，右边的路由器为E，那么从A到F之间的时间为2&#x2F;10&#x3D;0.2s，此后从F到E的传输则为2&#x2F;20&#x3D;0.1s，此时实现从F到E，最后从E到C所用的时间为0.2s，所以总的时间就是0.5s的时间。</p><p>（2）350ms。在从B到F的过程中不受影响，传输的时间为1&#x2F;10&#x3D;0.1s; 从F传输到E的过程中，需要等待A传输完成，A传输时间为0.1s，B端的传输时间就为0.1+0.05&#x3D;0.15s；从E传到D的时候需要0.1s。A不会影响传输所以一共为0.35s。</p></blockquote><ol start="2"><li>如果图中网络采用存储-转发方式的分组交换，分组长度为等长的1kbits，且忽略分组头开销以及报文的拆装开销，则A将2Mbits的文件交付给C需要大约多长时间？B将1Mbits的文件交付给D需要大约多长时间？</li></ol><blockquote><p>(1)  0.200015s。只需要考虑A的第一个分组的传输方式，$T&#x3D;T_{first}+T_{rest}&#x3D;\frac{2 \times 1kb}{10Mb&#x2F;s}+\frac{1kb}{20Mb&#x2F;s}+\frac{1999 \times 1kb}{10Mb&#x2F;s}&#x3D;0.200015s$</p><p>(2) 0.10002s。同样只需要考虑B的第一个传输和剩下的传输，B的第一个传输是全为10Mb&#x2F;s，$T&#x3D;M&#x2F;R+2L&#x2F;R&#x3D;\frac{1Mb}{10Mb&#x2F;s}+2 \times \frac{1kb}{10Mb&#x2F;s}&#x3D;1.0002s$</p></blockquote><ol start="3"><li>报文交换与分组交换相比，哪种交换方式更公平？（即传输数据量小用时少，传输数据量大用时长）</li></ol><blockquote><p>分组交换更公平</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Email消息格式和POP3协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Email%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%92%8CPOP3%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Email%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%92%8CPOP3%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## Email消息格式<p><strong>SMTP</strong>:  email 消息的传输&#x2F;交换协议</p><p><strong>RFC 822</strong>: 文本消息格式标准</p><ul><li>头部行<ul><li>To</li><li>From</li><li>Subject</li></ul></li><li>消息体<ul><li>消息本身</li><li>只能是ASCII字符</li></ul></li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230917171336.png" alt="image.png"></p><h2 id="Email消息格式：多媒体扩展"><a href="#Email消息格式：多媒体扩展" class="headerlink" title="Email消息格式：多媒体扩展"></a>Email消息格式：多媒体扩展</h2><p>MIME：多媒体邮件扩展RFC 2045，2056</p><ul><li>通过邮件头部增加额外的行以声明MIME的内容类型</li></ul><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230917171352.png" alt="image.png"></p><h2 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h2><p>邮件访问协议：从服务器获取邮件</p><ul><li><strong>POP</strong> ：Post Office Protocol [RFC 1939]<ul><li>认证&#x2F;授权（客户端 $\iff$ 服务器）和下载</li></ul></li><li><strong>IMAP</strong>: Internet Mail Access Protocol [RFC 1730]<ul><li>更多功能</li><li>更加复杂</li><li>能够操纵服务器上存储的信息</li></ul></li><li><strong>HTTP</strong>：163，QQ Mail等</li></ul><h2 id="POP协议"><a href="#POP协议" class="headerlink" title="POP协议"></a>POP协议</h2><h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><ul><li>客户端命令：<ul><li>User: 声明用户名</li><li>Pass：声明密码</li></ul></li><li>服务器响应<ul><li>+OK</li><li>-ERR</li></ul></li></ul><h3 id="事务阶段"><a href="#事务阶段" class="headerlink" title="事务阶段"></a>事务阶段</h3><p>List : 列出消息数量<br>Retr : 用编号获取消息<br>Dele : 删除消息<br>Quit</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918202545.png" alt="image.png"></p><p>“<strong>下载并删除模式</strong>“</p><ul><li>用户如果换了客户端软件，就没有办法重新读这个邮件</li></ul><p>“<strong>下载并保持模式</strong>” </p><ul><li>不同客户端都可以保留消息的拷贝</li></ul><h3 id="POP3是无状态的"><a href="#POP3是无状态的" class="headerlink" title="POP3是无状态的"></a><em>POP3是无状态的</em></h3><h2 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h2><p>所有消息统一保存在同一个地方：服务器</p><p>允许用户利用文件夹组织消息</p><p>IMAP支持跨会话（Session）的用户状态：</p><ul><li>文件夹的名字</li><li>文件夹和消息ID之间的映射等等</li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p><strong>MAP和POP3协议有什么不同？调研一下主流Email服务对IMAP协议的支持情况</strong> </p><p>IMAP（Internet Mail Access Protocol）和POP3（Post Office Protocol）都是用于获取和管理电子邮件的协议，但存在一些区别。</p><ol><li>差异：<ul><li>IMAP允许用户在本地和远程邮件客户端之间同步邮件状态，包括已读、删除等操作。而POP3只是简单地从服务器上下载邮件到本地，不对邮件状态进行同步。</li><li>IMAP在服务器上保留邮件的副本，用户可以在不同的设备上访问和管理邮件。而POP3将邮件下载到本地后，通常会删除服务器上的副本。</li><li>IMAP支持文件夹和子文件夹的管理，可以方便地组织和管理邮件。而POP3通常只有一个收件箱。</li></ul></li><li>关于主流Email服务对IMAP协议的支持情况，我们可以进行调研：<ul><li>根据Cloudflare的文章<a href="https://www.cloudflare.com/zh-cn/learning/email-security/what-is-imap/">What is IMAP? IMAP vs. POP3</a>，几乎所有的主流Email服务都支持IMAP协议。这包括Gmail、Outlook、Yahoo Mail等。</li><li>另外，根据知乎的回答<a href="https://www.zhihu.com/question/24605584">POP3, SMTP, IMAP 大相径庭—详解邮箱相关知识</a>，POP3协议通常用于普通邮件客户端，比如Outlook，而IMAP协议更适合移动设备和Web邮件界面。<br>综上所述，IMAP和POP3协议在邮件管理和访问方式上存在一些差异，主流Email服务一般都支持IMAP协议。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-DNS概述</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DNS%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DNS%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>#DNS<p>互联网中的核心服务</p><p>[[2023-09-18]]</p><h2 id="有关DNS基础资料查询"><a href="#有关DNS基础资料查询" class="headerlink" title="有关DNS基础资料查询"></a>有关DNS基础资料查询</h2><hr><h2 id="DNSDomain-Name-System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：-通俗易懂，了解什么是DNS及查询过程？-介绍了DNS是什么、DNS的查询过程等基础知识。-DNS基础知识详解-对DNS基础知识进行详细解析。-什么是DNS以及DNS工作原理-介绍了DNS的工作原理和作用。-DNS原理简述-简要介绍了DNS的原理和查询过程。"><a href="#DNSDomain-Name-System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：-通俗易懂，了解什么是DNS及查询过程？-介绍了DNS是什么、DNS的查询过程等基础知识。-DNS基础知识详解-对DNS基础知识进行详细解析。-什么是DNS以及DNS工作原理-介绍了DNS的工作原理和作用。-DNS原理简述-简要介绍了DNS的原理和查询过程。" class="headerlink" title="DNSDomain Name System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：- 通俗易懂，了解什么是DNS及查询过程？ - 介绍了DNS是什么、DNS的查询过程等基础知识。- DNS基础知识详解 - 对DNS基础知识进行详细解析。- 什么是DNS以及DNS工作原理 - 介绍了DNS的工作原理和作用。- DNS原理简述 - 简要介绍了DNS的原理和查询过程。"></a>DNSDomain Name System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。<br>查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：<br>- <a href="https://zhuanlan.zhihu.com/p/436199902#:~:text=%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFDNS%E5%8F%8A%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%EF%BC%9F">通俗易懂，了解什么是DNS及查询过程？</a> - 介绍了DNS是什么、DNS的查询过程等基础知识。<br>- <a href="https://www.cnblogs.com/guoxianqi2020/p/13740551.html">DNS基础知识详解</a> - 对DNS基础知识进行详细解析。<br>- <a href="https://blog.csdn.net/bangshao1989/article/details/121913780">什么是DNS以及DNS工作原理</a> - 介绍了DNS的工作原理和作用。<br>- <a href="https://www.ruanyifeng.com/blog/2022/08/dns-query.html">DNS原理简述</a> - 简要介绍了DNS的原理和查询过程。</h2><h2 id="DNS：Domain-Name-System"><a href="#DNS：Domain-Name-System" class="headerlink" title="DNS：Domain Name System"></a>DNS：Domain Name System</h2><hr><h3 id="Internet-上主机、路由器的识别问题"><a href="#Internet-上主机、路由器的识别问题" class="headerlink" title="Internet 上主机、路由器的识别问题"></a>Internet 上主机、路由器的识别问题</h3><hr><ul><li>IP地址</li><li>域名：<a href="http://www.hit.edu.cn/">www.hit.edu.cn</a></li></ul><h3 id="问题：域名和IP地址之间如何映射？"><a href="#问题：域名和IP地址之间如何映射？" class="headerlink" title="问题：域名和IP地址之间如何映射？"></a>问题：域名和IP地址之间如何映射？</h3><p>💭<strong>资料查询</strong>：</p><blockquote><p>域名和IP地址之间的映射是通过DNS（Domain Name System）来实现的。DNS是一种分布式数据库系统，它将域名解析为相应的IP地址。当用户在浏览器中输入一个域名，比如”<a href="http://www.example.com",浏览器会向dns服务器发送请求,以获取与该域名对应的ip地址.dns服务器会查询域名对应的ip地址并返回给浏览器,然后浏览器才能连接到该ip地址上的服务器.这样就实现了域名到ip地址的映射关系./">www.example.com&quot;，浏览器会向DNS服务器发送请求，以获取与该域名对应的IP地址。DNS服务器会查询域名对应的IP地址并返回给浏览器，然后浏览器才能连接到该IP地址上的服务器。这样就实现了域名到IP地址的映射关系。</a></p></blockquote><h3 id="域名解析DNS"><a href="#域名解析DNS" class="headerlink" title="域名解析DNS"></a>域名解析DNS</h3><hr><ul><li>多层命名服务器构成的分布式数据库</li><li><strong>应用层协议</strong>：完成名字的解析<ul><li>Internet核心共嗯那个，则应用层协议实现</li><li>网络边界复杂</li></ul></li></ul><h3 id="DNS-服务"><a href="#DNS-服务" class="headerlink" title="DNS 服务"></a>DNS 服务</h3><hr><ul><li>域名向IP地址的翻译</li><li>主机别名</li><li>邮件服务器别名</li><li><strong>负载均衡</strong>：Web服务器</li></ul><h3 id="问题：为什么不使用集中式的DNS？"><a href="#问题：为什么不使用集中式的DNS？" class="headerlink" title="问题：为什么不使用集中式的DNS？"></a>问题：为什么不使用集中式的DNS？</h3><blockquote><p>☁️集中式DNS存在几个问题：</p><ol><li><strong>单点失败问题</strong>：如果唯一的一个服务点（可能有多台服务器）坏掉了，所有使用域名来提供网络服务的都需要请求DNS来做事情，那么整个互联网就会瘫痪。</li><li><strong>流量问题</strong>：如果几十亿台主机都到这个服务器请求DNS查询，流量是巨大的，成本也是高昂的。<br>因此，为了解决这些问题，采用了分布式的DNS系统。这样可以提供高可用性和高伸缩性，减少了单点故障的风险，并且可以将负载均衡地分配到各个DNS服务器上。<br>来源：[CSDN博客](<a href="https://blog.csdn.net/lovelyhonghong/article/details/114850420#:~:text=%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%9A%84DNS%EF%BC%9F">https://blog.csdn.net/lovelyhonghong/article/details/114850420#:~:text=问题：为什么不使用集中式的DNS？</a> 1.单点失败问题。,如果唯一的一个服务点（可能有多台服务器）坏掉了，所有使用域名来提供网络服务的，都需要请求DNS来做事情，那么整个互联网就坏掉了。 2.流量问题。 如果几十亿台主机都到这个服务器请求DNS查询，流量是巨大的，成本也是高昂的。)</li></ol></blockquote><ol start="3"><li><strong>距离问题</strong>：在外国的服务器无法合理的访问</li><li><strong>维护性问题</strong></li></ol><h2 id="分布式层次式的数据库"><a href="#分布式层次式的数据库" class="headerlink" title="分布式层次式的数据库"></a>分布式层次式的数据库</h2><hr><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918210818.png" alt="image.png"></p><p>Level one ： 根服务器</p><p>Level two ：顶级域名服务器</p><p>Level three ：权威域名服务器</p><h3 id="客户端想要查询www-amazon-com的IP"><a href="#客户端想要查询www-amazon-com的IP" class="headerlink" title="客户端想要查询www.amazon.com的IP"></a>客户端想要查询<a href="http://www.amazon.com的ip/">www.amazon.com的IP</a></h3><ol><li><p>客户端查询根服务器，找到com域名解析服务器</p></li><li><p>客户端查询com域名解析服务器，找到amazon.com域名解析服务器</p></li><li><p>客户端查询amazon.com域名解析服务器，获得<a href="http://www.amazon.com的ip地址/">www.amazon.com的IP地址</a></p></li></ol><h2 id="DNS根域名服务器"><a href="#DNS根域名服务器" class="headerlink" title="DNS根域名服务器"></a>DNS根域名服务器</h2><p><strong>本地域名解析服务器无法解析域名的时候，访问根域名服务器</strong></p><h3 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h3><ul><li>如果不知道映射，访问权威域名服务器</li><li>获得映射</li><li>向本地域名服务器返回映射</li></ul><h2 id="TLD和权威域名解析服务器"><a href="#TLD和权威域名解析服务器" class="headerlink" title="TLD和权威域名解析服务器"></a>TLD和权威域名解析服务器</h2><h3 id="顶级域名服务器（TLD，top-level-domain）"><a href="#顶级域名服务器（TLD，top-level-domain）" class="headerlink" title="顶级域名服务器（TLD，top-level domain）"></a>顶级域名服务器（TLD，top-level domain）</h3><hr><p><strong>负责com,org,net,edu等顶级服务器和国家顶级域名，例如</strong>cn,uk,fr等</p><ul><li>Network Solution 维护com顶级域名服务器</li><li>Educause维护edu顶级域名服务器</li></ul><h3 id="权威（Authoritative）域名服务器"><a href="#权威（Authoritative）域名服务器" class="headerlink" title="权威（Authoritative）域名服务器"></a>权威（Authoritative）域名服务器</h3><hr><p><strong>组织的域名解析服务器，提供组织内部服务器的解析服务</strong></p><ul><li><code>组织负责维护</code></li><li><code>服务提供商负责维护</code></li></ul><h2 id="本地域名解析服务器"><a href="#本地域名解析服务器" class="headerlink" title="本地域名解析服务器"></a>本地域名解析服务器</h2><hr><ul><li>不属于严格的层级体系</li><li>每个ISP都有一个本地域名服务器<ul><li>默认域名解析服务器</li></ul></li><li>当主机进行DNS查询的时候，查询被发送到本地域名服务器<ul><li>作为代理(proxy)，将查询转发给(层级式)域名解析服务器系统</li></ul></li></ul><p><strong>DNS服务器除了做代理之外会不会做缓存呢？</strong></p><h2 id="DNS查询示例"><a href="#DNS查询示例" class="headerlink" title="DNS查询示例"></a>DNS查询示例</h2><hr><p><strong>Cis.poly.edu的主机想要获得gaia.cs.umass.edu的IP地址</strong></p><h3 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h3><p>被查询服务器返回域名解析服务器的名字<br><strong>我不认识这个域名，但是你可以访问这个服务器</strong><br><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918212916.png" alt="image.png"></p><h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><p>将域名解析的任务交给所联系的服务器<br><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918213045.png" alt="image.png"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为"><a href="#如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为" class="headerlink" title="如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为?"></a>如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为?</h3><blockquote><p>一条，一条</p></blockquote><h2 id="DNS记录缓存和更新"><a href="#DNS记录缓存和更新" class="headerlink" title="DNS记录缓存和更新"></a>DNS记录缓存和更新</h2><h3 id="只要域名解析服务器获得了域名——IP映射，即缓存这一映射"><a href="#只要域名解析服务器获得了域名——IP映射，即缓存这一映射" class="headerlink" title="只要域名解析服务器获得了域名——IP映射，即缓存这一映射"></a>只要域名解析服务器获得了域名——IP映射，即缓存这一映射</h3><ul><li>一段时间过后，缓存条目失效（删除）</li><li>本地域名服务器一般会缓存顶级域名服务器的映射<ul><li>因此根域名服务器不经常被访问</li></ul></li></ul><h3 id="记录的更新-通知机制"><a href="#记录的更新-通知机制" class="headerlink" title="记录的更新&#x2F;通知机制"></a>记录的更新&#x2F;通知机制</h3><p>RFC 2136</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>我国没有根域名服务器，是否会影响我国的网络安全，会有什么影响？ </p><p>根域名服务器是DNS系统中最高级的服务器，主要负责将域名转换为IP地址。如果我国没有根域名服务器，那么本地DNS服务器需要依赖其他国家或地区的根域名服务器进行域名解析。<br>这可能会导致以下影响：</p><ol><li>域名解析延迟：由于需要通过其他国家或地区的根域名服务器进行域名解析，可能会增加域名解析的延迟时间，影响用户的访问速度。</li><li>DNS污染的风险：如果依赖其他国家或地区的根域名服务器，存在被篡改或操纵的风险，可能会导致DNS污染问题，进而影响用户的网络安全。</li><li>国内域名管理困难：没有根域名服务器可能会使国内域名管理难度增加，因为国内域名需要通过其他根域名服务器进行授权和解析。<br>需要注意的是，虽然我国没有根域名服务器，但我国仍然有多个顶级域名服务器，可以解析国内的顶级域名。此外，我国也有多个根域名服务器的备用节点，以确保网络安全和稳定性。<br>来源：<a href="https://www.zhihu.com/question/51263554">zhihu.com</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-DHCP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DHCP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DHCP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="如何获得IP地址"><a href="#如何获得IP地址" class="headerlink" title="如何获得IP地址"></a>如何获得IP地址</h2><p>Q： 一个主机如何获得IP地址？</p><ul><li>”硬编码“：静态配置</li></ul><p>需要配置的信息包括IP地址和子网掩码。</p><p><strong>默认网关</strong>： 所谓的默认网关就是当这个IP的数据报在向外传递数据的时候应该向什么地方进行转发。代表的是路由器的接口。</p><p>路由器接入子网的这个接口的IP地址就是这个子网中所有主机的默认网关。</p><p>域名服务器：默认的域名服务器 <strong>本地域名服务器</strong></p><ul><li>动态地址的获取 动态主机配置协议：DHCP Dynamic Host Configuration Protocol</li></ul><p>从服务器动态获取</p><ul><li>IP地址</li><li>子网掩码</li><li>默认网关地址</li><li>DNS服务器名称和IP地址</li></ul><p>“即插即用”</p><p>允许地址的重用</p><p>支持在用地址的续租</p><p>支持移动用户加入网络</p><h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>新到主机（DHCP客户）需要本网IP地址</p><p>”主机广播“：DHCP discover（发现报文）</p><p>DHCP服务器利用”DHCP offer“(提供报文)进行相应</p><p>主机请求IP地址：”DHCP request“ (请求报文)</p><h2 id="DHCP工作过程示例"><a href="#DHCP工作过程示例" class="headerlink" title="DHCP工作过程示例"></a>DHCP工作过程示例</h2><p>DHCP server: 223.1.2.5.67</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015220123172.png" alt="image-20231015220123172" style="zoom:67%;" /><h3 id="DHCP协议在应用层实现"><a href="#DHCP协议在应用层实现" class="headerlink" title="DHCP协议在应用层实现"></a>DHCP协议在应用层实现</h3><p>请求报文封装到UDP数据报中</p><p>IP广播</p><p>链路层广播（以太网广播）</p><p>DHCP服务器构造ACK报文</p><p>包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-DELETE</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DELETE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DELETE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]删除URL字段所指定的文件]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 知识卡片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Cookie</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Cookie/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Cookie/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]<h2 id="为什么需要Cookie"><a href="#为什么需要Cookie" class="headerlink" title="为什么需要Cookie?"></a>为什么需要Cookie?</h2><p>HTTP协议无状态</p><p>很多应用需要服务器掌握客户的状态：</p><ul><li><strong>网上购物</strong></li></ul><h2 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h2><p>某些网站为了辨别身份，进行session跟踪而存储在用户本地终端上的数据（<strong>通常经过加密</strong>）<br>RFC6265</p><p><strong>Cookie的组件</strong></p><ul><li>HTTP响应消息的cookie头部行</li><li>HTTP请求消息的cookie头部行</li><li>保存在客户端主机上的cookie文件，由浏览器管理</li><li>Web服务器端的后台数据库</li></ul><h2 id="Cookie的原理"><a href="#Cookie的原理" class="headerlink" title="Cookie的原理"></a>Cookie的原理</h2><p>Susan 首次PC上网，首次和Amazon.com取得联系。界定过去访问过eBay站点，当请求报文到达该Amazon Web服务器的时候，这个Web站点将产生一个唯一的识别码，并以此缩影在它的后端数据库中产生一个表项。接下来Amazon Web服务器用一个包含Set-cookie：首部的HTTP响应报文来对Susan的浏览器进行响应，其中Set-cookie:首部含有识别码。</p><p>Susan浏览器收到了该HTTP的响应报文的时候，它会看到该Set-cookie:首部。该浏览器在它管理的特定cookie文件中添加一行，该行包含服务器的主机名和在Set-cookie：首部中的识别码。</p><p>值得注意的是当前的cookie文件已经有了eBay的表项，因为Susan过去访问过该站点。之后的浏览都会从该cookie文件中获取她对这个网站的识别码，并放到HTTP请求报文中包括识别码的cookie首部行中。</p><p>在这种方式下，Amazon服务器可以跟踪Susan在Amazon站点的活动。Amazon使用cookie来提供 <strong>购物车服务</strong> </p><p>![[assets 1&#x2F;Pasted image 20230917115446.png]]</p><h2 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h2><ul><li><p>cookie能够用于：****</p><ul><li>身份认证</li><li>购物车</li><li>推荐</li><li>Web e-mail</li><li>……</li></ul></li><li><p>隐私问题</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Cookie </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-CIDR和路由聚合</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-CIDR%E5%92%8C%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-CIDR%E5%92%8C%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>无类域间路由（CIDR：Classless InterDomain Routing)</p><p>消除传统的A类、B类和C类地址界限</p><ul><li>NetID + SubID $\to$ Network Prefix(Prefix) 可以任意的长度</li></ul><p>融合子网地址和子网掩码，方便子网进行划分</p><ul><li>无类地址格式：a.b.c.d&#x2F;x，其中x为前缀长度</li></ul><p>例如</p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015212717.png" alt="image.png" style="zoom:67%;" />和有类IP地址就有很大的区别了；也就是打破了有类地址的界限划分<p>子网 201.2.3.64，255.255.255.192 🤜 201.2.3.64&#x2F;26</p><h2 id="CIDR和路由聚合"><a href="#CIDR和路由聚合" class="headerlink" title="CIDR和路由聚合"></a>CIDR和路由聚合</h2><p>无类域间路由（CIDR)</p><ul><li>提高IPv4的地址空间分配效率</li></ul><p>可以将很多的C网划分在一起再统一的进行转发</p><ul><li>能够提高路由效率<ul><li>将多个子网聚合成一个较大的子网</li><li>构造超网</li><li><strong>路由聚合</strong>（route aggregation）</li></ul></li></ul><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015213443100.png" alt="image-20231015213443100" style="zoom: 67%;" /><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015213823598.png" alt="image-20231015213823598" style="zoom:67%;" />## 路由聚合层级编址使得路由信息通告更加高效<img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015213908264.png" alt="image-20231015213908264" style="zoom:50%;" /><p>选用更加具体的路由：<strong>最长前缀匹配优先</strong>！</p><p>通过前缀长度来加以区分</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-BGP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-BGP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-BGP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="Internet-AS间路由协议：BGP"><a href="#Internet-AS间路由协议：BGP" class="headerlink" title="Internet AS间路由协议：BGP"></a>Internet AS间路由协议：BGP</h2><p><strong>边界网关协议BGP</strong>：事实上的标准域间路由协议</p><ul><li>将Internet “粘合”为一个整体的关键</li></ul><p>BGP为每个AS提供了一种手段：</p><ol><li><p>eBGP：从邻居的自治系统获取子网的可达性信息</p></li><li><p>iBGP：向所有AS内部有尤其传播子网可达性信息</p></li><li><p>基于可达性信息和策略，确定到达其他网络的“好”路径</p></li></ol><p>容许子网向Internet其余部分通告它的存在</p><h2 id="BGP协议的基础"><a href="#BGP协议的基础" class="headerlink" title="BGP协议的基础"></a>BGP协议的基础</h2><p>BGP会话(session)：两个BGP路由器（”Peers”）交换BGP报文：</p><ul><li><p>通告去往不同目的的前缀(prefix)的路径（“路径向量”）协议</p></li><li><p>报文交换基于半永久的TCP协议</p></li></ul><p>BGP报文：</p><p>OPEN：和peers建立TCP连接，并认证发送方</p><p>UPDATE：通告新路径（或者撤销原路径）</p><p>KEEPALIVE：在没有UPDATE的时候，保活连接；也用于对OPEN请求的确认</p><p>NOTIFICATION：报告先前报文的差错；也被用于关闭连接</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029231514.png" alt="image.png"></p><p>当AS3通告一个前缀给AS1时：</p><ul><li><p>AS3 承诺可以将数据报转发给该子网</p></li><li><p>AS3在通告中会聚合网络前缀</p></li></ul><h2 id="BGP基础：分发路径信息"><a href="#BGP基础：分发路径信息" class="headerlink" title="BGP基础：分发路径信息"></a>BGP基础：分发路径信息</h2><p>在3a和1c之间AS3利用eBGP会话向AS1发送前缀可达信息。</p><p>1c则可以利用iBGP向AS1内的所有路由器分发新的前缀可达性信息</p><p>1b可以(maybe not) 进一步通过1b-到-2a的eBGP会话，向AS2通告新的可达性信息</p><p>当路由器获得新的前缀可达性的时候，就会在转发表中增加关于该前缀的入口(路由项)</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029231942.png" alt="image.png"></p><h2 id="路径属性和BGP路由-route"><a href="#路径属性和BGP路由-route" class="headerlink" title="路径属性和BGP路由(route)"></a>路径属性和BGP路由(route)</h2><p>通告的前缀信息包括BGP属性</p><ul><li>前缀 + 属性 &#x3D; “路由”</li></ul><p>两个重要属性：</p><ul><li>AS-PATH : 包含前缀通告所经过的AS序列：e.g. AS 67,AS 17</li><li>NEXT-HOP(下一跳)：开始一个AS-PATH的路由器接口，指向吓一跳的AS</li></ul><h2 id="BGP的路由选择"><a href="#BGP的路由选择" class="headerlink" title="BGP的路由选择"></a>BGP的路由选择</h2><p>网关路由器收到路由通告之后，利用其输入策略决策接收或者拒绝该路由</p><p>从不将流量路由到ASx<br>基于策略的路由</p><p>路由器可能或者到某目的AS的多条路由，基于以下准则：</p><ul><li><p>本地偏好值属性：策略决策</p></li><li><p>最短的AS-PATH</p></li><li><p>最近的下一跳路由器</p></li></ul><h2 id="BGP路由选择策略"><a href="#BGP路由选择策略" class="headerlink" title="BGP路由选择策略"></a>BGP路由选择策略</h2><p>提供商网络<br>客户网络<br>桩网络<br>双宿网络</p><p><img src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/6034294e3b9c0feeabde6fc50c50ec2.jpg" alt="6034294e3b9c0feeabde6fc50c50ec2.jpg"></p><h3 id="为什么采用不同的AS内和AS间的路由协议"><a href="#为什么采用不同的AS内和AS间的路由协议" class="headerlink" title="为什么采用不同的AS内和AS间的路由协议"></a>为什么采用不同的AS内和AS间的路由协议</h3><h4 id="策略-policy"><a href="#策略-policy" class="headerlink" title="策略(policy):"></a>策略(policy):</h4><p>inter-AS:期望能够管理控制流量如何被路由，谁路由经过其网络等<br>intra-AS: 单一管理，无需策略决策</p><h4 id="规模-scale"><a href="#规模-scale" class="headerlink" title="规模(scale)"></a>规模(scale)</h4><p>层次路由节省路由表大小，减少路由更新流量<br>适应大规模互联网</p><h4 id="性能-performance"><a href="#性能-performance" class="headerlink" title="性能(performance):"></a>性能(performance):</h4><p>intra-AS:侧重性能<br>inter-AS: 策略主导</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-ARP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ARP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ARP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>32位的IP地址：</p><ul><li>接口的网络层地址</li><li>用于标识网络层(第三层)分组，支持分组转发</li></ul><p>MAC地址（或称LAN地址，物理地址，以太网地址）</p><p>作用：用于局域网内的标识一个帧从哪个接口发出没到达哪个物理相连的其他接口</p><p>48位MAC地址（用于大部分LANs）固化在网卡的ROM中，有时也可以用软件设置</p><p>局域网的每块网卡都有唯一的MAC地址</p><p>MAC地址由IEEE统一管理和分配</p><p>网卡生产商够吗MAC地址空间（前24bit）</p><p>类比：</p><ul><li>MAC地址：身份证号</li><li>IP地址：邮政地址</li></ul><p><strong>MAC地址是“平面”地址: 可“携带</strong></p><p>可以从一个LAN移到另一个LAN</p><p><strong>IP地址是层次地址: 不可“携带“</strong></p><p>IP地址依赖于结点连接到哪个子网</p><h2 id="ARP：地址解析协议"><a href="#ARP：地址解析协议" class="headerlink" title="ARP：地址解析协议"></a>ARP：地址解析协议</h2><p>问题：（在同一个LAN内）如何在一致目的接口的IP地址前提下确定其MAC地址？</p><p>ARP表：LAN中的每个IP结点(主机&#x2F;路由器)维护一个表</p><ul><li><p>存储某些LAN结点的IP、MAC关系地址映射关系：&lt;IP;MAC;TTL&gt;</p></li><li><p>TTL(Time To Live): 经过这个时间之后这个映射关系会被遗弃</p></li></ul><p>A想要给同一个局域网内的B发送数据报</p><p>B的MAC地址不再A的ARP表中。</p><p>A广播ARP查询分组，其中包含B的IP分组</p><p>目的MAC地址 &#x3D; FF-FF-FF-FF-FF-FF</p><p>LAN中的所有结点都会接收ARP查询</p><p>B接收ARP查询分组，IP地址匹配成功，向A应答B的MAC地址</p><ul><li>利用单播帧向A发送应答</li></ul><p>A在其ARP表中，缓存B的IP-MAC地址对，直至超时</p><ul><li>超时之后，再次刷新</li></ul><p>ARP是”即插即用“协议：</p><ul><li>结点自主创建ARP表，无需干预</li></ul><h2 id="寻址：从一个LAN路由到另一个LAN"><a href="#寻址：从一个LAN路由到另一个LAN" class="headerlink" title="寻址：从一个LAN路由到另一个LAN"></a>寻址：从一个LAN路由到另一个LAN</h2><p>通信过程：A通过路由器R向B发送数据报</p><ul><li>关注寻址：IP地址（数据报中）和MAC地址（帧中）</li><li>假设A直到B的IP地址（怎么知道的?）</li><li>假设A知道第一跳路由器R（左）接口IP地址</li><li>假设A知道第一条路由器R（左）接口的MAC地址</li></ul><p>A构造IP数据报，其中源IP地址是A的IP地址，目的IP地址是B的IP地址</p><p>A构造链路层帧，其中源MAC地址是A的MAC地址，目的MAC地址做接口的MAC地址，封装A到B的数据报</p><p>帧从A发送到R</p><p>R接收帧，提取IP数据报，传递给上层的IP协议</p><p>R转发IP数据报</p><p>R构造链路层帧，其中源MAC地址是R接口的MAC地址，目的MAC地址是B的MAC地址，封装A到B的IP数据报</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
