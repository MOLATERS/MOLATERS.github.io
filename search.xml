<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CA-量化设计的基本原则</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E9%87%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E9%87%8F%E5%8C%96%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 量化设计的基本原则<h2 id="CourseNotes-计算机体系结构-CA-CPU性能公式"><a href="#CourseNotes-计算机体系结构-CA-CPU性能公式" class="headerlink" title="[[CourseNotes&#x2F;计算机体系结构&#x2F;CA-CPU性能公式]]"></a>[[CourseNotes&#x2F;计算机体系结构&#x2F;CA-CPU性能公式]]</h2><h2 id="大概率事件优先原则"><a href="#大概率事件优先原则" class="headerlink" title="大概率事件优先原则"></a>大概率事件优先原则</h2><p><strong>基本思想</strong>：对于大概率事件，赋予它优先的处理权和资源使用权，以获得全局的最优结果，以达到事半功倍的效果</p><p>类似于：哈夫曼编码</p><p>比如说：CPU在进行加法的时候，运算结果无溢出为大概率事件，溢出是小概率事件，所以就针对无溢出情况来做CPU优化设计</p><h2 id="Amdahl-定律"><a href="#Amdahl-定律" class="headerlink" title="Amdahl 定律"></a>Amdahl 定律</h2><p>Amdahl定律既可以用来<strong>确定系统中对性能限制最大的组件</strong>,也可以用来<em><strong>计算通过改进某些部件所获得的系统性能的提高</strong></em></p><p><strong>加快某部件执行速度所获得的系统性能加速比,受限于该部件在系统中所占的重要性</strong></p><h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><h4 id="系统加速比"><a href="#系统加速比" class="headerlink" title="系统加速比"></a>系统加速比</h4><p>$$<br>系统加速比 &#x3D; \frac{系统性能_{改进之后}}{系统性能_{改进之前}}<br>$$<br><strong>或者</strong><br>$$<br>系统加速比 &#x3D; \frac{总执行时间_{改进之前}}{总执行时间_{改进之后}}<br>$$</p><p><code>系统加速比</code> 可以告诉人们 <strong>改进之后的机器比改进之前快多少</strong></p><p><code>系统加速比</code>依赖于两个因素</p><ol><li>可改进部分在原系统计算时间中所占的比例</li></ol><p><strong>可改进比例</strong> $\in (0,1) \rightarrow \delta$ </p><ol start="2"><li>该部分改进之后的性能提高</li></ol><p><strong>部件加速比</strong> $\in (1,\infty) \rightarrow \alpha$</p><p>所以总执行时间:</p><p>$T &#x3D; (1-\delta) \times T_{改进前} + \frac{\delta \times T_{改进前}}{\alpha}$</p><p>所以系统加速比:</p><p>$\alpha_{系统}&#x3D;\frac{1}{(1-\delta)+\frac{\delta}{\alpha}}$</p><h2 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h2><p>程序的局部性原理（Principle of Locality）是指在程序访问内存时，往往倾向于访问最近才使用过的数据和即将使用的数据。这个原理可以分为两个方面：时间局部性和空间局部性。</p><p>时间局部性（Temporal Locality）指的是程序中的数据项一旦被访问，很可能在不久的将来再次被访问。这意味着在程序的执行过程中，某个数据项的访问往往会连续发生，因此将该数据项保留在高速缓存中，可以显著提高程序的性能。</p><p>空间局部性（Spatial Locality）指的是程序中的数据项的访问往往是以连续的方式进行的，即如果一个数据项被访问，那么与之相邻的数据项也很可能被访问。因此，将这些连续的数据项一起加载到高速缓存中，可以提高缓存的命中率，从而减少了访问内存的时间。</p><p>在程序设计和优化中，能够充分利用局部性原理可以提高程序的性能。例如，可以通过使用数组而不是链表来提高空间局部性，因为数组中的元素在内存中是连续存储的；可以通过合理安排数据访问的顺序来提高时间局部性，避免频繁地访问不相邻的数据。</p><p>参考来源：<a class="link"   href="https://zhuanlan.zhihu.com/p/30127242" >知乎专栏：深入理解程序的局部性原理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><blockquote><p>[!hello]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-读书报告-李煦-2021112864</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A-%E6%9D%8E%E7%85%A6-2021112864/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A-%E6%9D%8E%E7%85%A6-2021112864/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 需求、瓶颈和好运:微处理器进化的动因## Part 1 基础架构<img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230921182614.png"                      alt="image.png" style="zoom: 67%;"                 ><h3 id="A-计算机体系结构是一门权衡的科学"><a href="#A-计算机体系结构是一门权衡的科学" class="headerlink" title="A. 计算机体系结构是一门权衡的科学"></a>A. 计算机体系结构是一门权衡的科学</h3><p>计算机体系结构更多地是一门“艺术”而不是“科学”。</p><p>计算机如果真的是一门科学，那就是一门权衡的科学。计算机架构师不断发展知识基础，这样就能够来更好的进行权衡；这个过程尤其表现在微处理器的演变过程中。</p><h3 id="B-转化的级别"><a href="#B-转化的级别" class="headerlink" title="B. 转化的级别"></a>B. 转化的级别</h3><p>在问题的解决过程中，需要通过一系列的转换过程来逐步将问题转化到电子（或设备）级别。转换的级别可以分为算法、机械语言、指令集架构（ISA）、微架构和电子数字电路。每个微处理器都由实现硬件结构（微架构）的电路组成，为软件提供一个接口（ISA）。不同的ISA会影响编译器开发的接口质量以及微架构执行的工作方式。在层次结构的每个步骤中，从算法的选择到语言、ISA、微架构和电路的选择都需要在性能和成本之间进行权衡。这些转换的选择都是基于性能和经济之间的权衡。</p><p>以下是按照转化的方法来构建的流程图：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">A(算法) --&gt; B(机械语言)</span><br><span class="line"></span><br><span class="line">B --&gt; C(指令集架构)</span><br><span class="line"></span><br><span class="line">C --&gt; D(微架构)</span><br><span class="line"></span><br><span class="line">D --&gt; E(电子数字电路)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>从算法的选择到语言、ISA架构、电路的选择，每个层级都存在选择和权衡。通常情况下，但并非总是如此，选择是在更高的性能和更低的成本之间进行。</p><h3 id="C-设计的关键点"><a href="#C-设计的关键点" class="headerlink" title="C. 设计的关键点"></a>C. 设计的关键点</h3><p>设计处理器涉及到做出权衡，所以要考虑微处理器里面最重要的特征。强烈影响设计的有性能、成本、散热和功耗；同时另一个设计点是高可用性，也就是不会产生错误；追求高性能和低功耗。</p><h3 id="D-应用空间"><a href="#D-应用空间" class="headerlink" title="D. 应用空间"></a>D. 应用空间</h3><p>应用程序的空间越来越大，是因为人们对计算机的用途也越来越广泛，也就导致了对微处理器的需求和每个需求所做的权衡就会不断扩展。</p><p>计算机和微处理器的使用方面可以在<strong>科学应用</strong>，<strong>基于交易的应用</strong>、<strong>网络应用</strong>、<strong>确保交付应用</strong>、<strong>嵌入式应用</strong>、<strong>媒体应用</strong>、<strong>随机软件包</strong>等地方发挥作用。</p><p>每一个这样的应用都有他们的不同的地方、每一个应用区域都针对微处理器需要不同程度的统筹协调的进行特殊处理，以完成对应的工作。</p><h3 id="E-处理的基础"><a href="#E-处理的基础" class="headerlink" title="E. 处理的基础"></a>E. 处理的基础</h3><p>简单的把一个微处理器的行为定义为执行命令。为了做到这一点，处理器需要做到下面三件事：</p><ul><li>为能够让每个指令正确运行的处理器核心提供命令</li><li>为每一条指令提供所需要的数据</li><li>运行每一个被要求的指令</li></ul><h3 id="F-指令的提供"><a href="#F-指令的提供" class="headerlink" title="F. 指令的提供"></a>F. 指令的提供</h3><p>在过去的取指方案里，一条指令被提取，解码并传送给处理器核心进行处理。现在随着技术的发展，从一次性提取一条指令变成了一次性可以提取四条指令，甚至现在有可能已经能够一次性提取六条或者八条。有三件事情会阻碍我们将指令完全传输给内核并执行：</p><ul><li>指令Cache的不命中</li><li>取指暂停（fetch misses）</li><li>条件预测错误。</li></ul><h3 id="G-数据的提供"><a href="#G-数据的提供" class="headerlink" title="G. 数据的提供"></a>G. 数据的提供</h3><p>为了提供有效的数据，需要满足三个条件：</p><ul><li><p>具备提供无线的所需要的数据的能力</p></li><li><p>能够以极快的速度提供数据的能力</p></li><li><p>能够用合理的成本提供数据的能力</p></li></ul><p>现在使用的是存储的层次结构，一小部分数据能够在一到三个时间周期获取，更多的程序能够在十到十六个时钟周期获取，这些都是在芯片内的存储的情况；更多的数据是在芯片以外的方式进行存储，获取数据可能需要到数百个时间周期。</p><p>实际上，在作者的那个年代，外部芯片的延迟还很糟糕，作者提出，在几年内在外部内存访问数据可能需要数千个处理器周期。</p><h3 id="H-指令处理"><a href="#H-指令处理" class="headerlink" title="H. 指令处理"></a>H. 指令处理</h3><p>要执行这些指令所需的操作，需要足够数量的功能单元来处理数据，一旦数据可用，即时提供结果到需要它作为源操作数的功能单元。然而，足够的互连并不足够。随着芯片周期时间的减小，将一个部分芯片中的功能单元产生的结果转发到另一个部分芯片中需要这些结果作为源操作数的功能单元的延迟也会变得更糟。</p><h2 id="Part-2-处理器发展的推动因素"><a href="#Part-2-处理器发展的推动因素" class="headerlink" title="Part 2 处理器发展的推动因素"></a>Part 2 处理器发展的推动因素</h2><p>许多因素帮助了微处理器的发展：</p><ol><li>购买大众的意愿抢购供应商生产的产品——如果没有市场，任何产品都无法产生。</li><li>工程师在遇到问题时想出答案的创造力——没有解决方案，就不会有进化。</li><li>❗进化的动因则是：新的需求、瓶颈和好运。</li></ol><h3 id="A-新的需求"><a href="#A-新的需求" class="headerlink" title="A. 新的需求"></a>A. 新的需求</h3><p>早期处理器限制在每个周期获取一条指令，对指令进行解码并交给核心中的单元进行处理。 </p><p>对高性能的需求。有一个演变方向是变成了宽问题处理器，能够每个周期提取、解码和发送多个指令到执行核心。有另外一个演变方向，能够在执行核心中包含多个功能单元，一次可以做多个指令的操作。</p><p>又出现了新的功耗需求。要求是提供先前相同的计算机性能，但是能够降低先前的功耗。</p><p>预测未来的需求是人机交互的需求。</p><h3 id="B-瓶颈"><a href="#B-瓶颈" class="headerlink" title="B. 瓶颈"></a>B. 瓶颈</h3><p>我们已经在上面确定了指令处理的三个组成部分(指令提供、数据提供和执行指令的操作)，以及它们各自需要做什么。到目前为止，微处理器的大部分改进都是由于试图消除阻碍这三个组件工作的瓶颈。</p><p><strong>解决取指周期太长的问题</strong></p><p>解决方法：指令缓存。</p><p><strong>由条件分支导致取指令的过程当中不能取到的指令</strong></p><p>解决方法：条件分支预测器</p><h3 id="C-好运气"><a href="#C-好运气" class="headerlink" title="C. 好运气"></a>C. 好运气</h3><p>能够使用之前没有优化的剩余空间来做更多的优化，这就是作者所陈述的好运气（Good Furtune）的内容。作者给出的例子是引入了片上浮点加速器和片商多媒体指令扩展功能。</p><h2 id="Part-3-演化：从1971到如今（2001）"><a href="#Part-3-演化：从1971到如今（2001）" class="headerlink" title="Part 3 演化：从1971到如今（2001）"></a>Part 3 演化：从1971到如今（2001）</h2><p>微处理器已经从Intel 4004的2300个晶体管发展到今天的样子。这种进化是由上面所说的几个因素造成的。最后演变出来的结果就是，奔腾IV与1971年的英特尔4004几乎没有相似之处。下面是这种进化的一些例子。</p><h3 id="A-流水线"><a href="#A-流水线" class="headerlink" title="A. 流水线"></a>A. 流水线</h3><p>早期的微处理器在开始处理下一条指令之前先处理一条指令从取到执行结束。流水线，至少从20世纪60年代开始就出现在大型计算机中，是解决性能瓶颈的一个明显的解决方案。商业上可行的微处理器，如英特尔8086，在20世纪70年代末通过在当前指令执行时预取下一条指令，向流水线迈出了第一步。</p><h3 id="B-芯片内缓存"><a href="#B-芯片内缓存" class="headerlink" title="B. 芯片内缓存"></a>B. 芯片内缓存</h3><p>芯片内缓存的发展过程</p><ul><li>1984年摩托罗拉推出了一个具有商业可行性的芯片缓存处理器。</li><li>1986年，摩托罗拉公司推出了首款包含独立片上指令和数据缓存的微处理器。</li><li>1994年开始出现拥有两级缓存的高性能微处理器。</li></ul><h3 id="C-分支预测"><a href="#C-分支预测" class="headerlink" title="C. 分支预测"></a>C. 分支预测</h3><p>如果需要等待上一条指令产生条件跳转所需要的结果，那么条件跳转的线路的优势就会丢失。硬件(运行时)<strong>分支预测器</strong>直到20世纪90年代初才出现在微处理器芯片上。一些早期引入运行时分支预测器的微处理器是摩托罗拉的MC88110、Digital的Alpha 21064和英特尔的Pentium。</p><h3 id="D-片上的浮点单元"><a href="#D-片上的浮点单元" class="headerlink" title="D. 片上的浮点单元"></a>D. 片上的浮点单元</h3><p>片上浮点单元早期的微处理器有一个<u>单独的芯片来处理浮点运算</u>。随着晶体管越来越小，芯片越来越大，晶体管数量达到了浮点单元可以与主处理单元放在同一芯片上的程度，利用了“新的”备用容量，节省了不必要的片外通信。摩托罗拉MC88100和英特尔486是20世纪80年代末在主处理器芯片上采用浮点单元的两种早期芯片</p><h3 id="E-额外特殊功能单元"><a href="#E-额外特殊功能单元" class="headerlink" title="E. 额外特殊功能单元"></a>E. 额外特殊功能单元</h3><p>早期的微处理器只有一个或者很少的功能单元。但是人们发现可以<strong>利用多个单元来并发执行提高效率</strong>。后面先后引入了单独地址的<code>ALU</code>、更复杂的LOAD&#x2F;STORE存储单元、辅助图形处理单元等。</p><h3 id="F-乱序执行"><a href="#F-乱序执行" class="headerlink" title="F. 乱序执行"></a>F. 乱序执行</h3><p>最初，指令只能顺序执行，如果有数据正在执行，且下一条指令需要上一条指令产生的结果，就会产生瓶颈。<br>从20世纪60年代以来，IBM就饶过了这个瓶颈，使用了<strong>乱序处理</strong>。后来出现了乱序处理和精确异常处理的结合。为了适应乱序执行，就使用了大量的寄存器混叠和保留站。<strong>遵循的思想就是，只要指令的资源可用，指令就被允许执行。</strong> 但是它们在退出的时候还是严格按照顺序。要做大这一点就要一个在发生异常恢复状态的结构，这在现在大多数微处理器上表现的就是Recorder Buffer。</p><h3 id="G-集群处理器"><a href="#G-集群处理器" class="headerlink" title="G. 集群处理器"></a>G. 集群处理器</h3><p>由于片上的频率增加，导致芯片内一个功能单元产生的数值不能传递到对应的接受单元，所以有了将执行核心划分为多个<strong>集群</strong>的概念。一个集群的功能单元产生的结果将由同一个集群中的另一个单元来使用。</p><h3 id="H-芯片内的多处理器"><a href="#H-芯片内的多处理器" class="headerlink" title="H. 芯片内的多处理器"></a>H. 芯片内的多处理器</h3><p>问题出现：当指令缓存访问导致缓存缺失的时候，指令供应就会受到影响，在等待缓存确实被满足的过程中会浪费大量的容量。所以出现了<strong>备用容量</strong>的概念，在20世纪90年代出现之后，它被扩展到允许在交替的周期中从单个指令流里面单独获取。</p><h3 id="I-高频率内核"><a href="#I-高频率内核" class="headerlink" title="I. 高频率内核"></a>I. 高频率内核</h3><p>在计算密集型任务中，等待早期指令生成结果的源操作数的流依赖关系可能是一个重要的瓶颈。一个解决方案——以比微处理器其他部分快得多的频率运行执行核。奔腾IV芯片于2000年推出，其工作频率为1.7 GHz，但ALU的工作频率为3.4 GHz。</p><h2 id="Part-4-十亿晶体管芯片的未来"><a href="#Part-4-十亿晶体管芯片的未来" class="headerlink" title="Part 4 十亿晶体管芯片的未来"></a>Part 4 十亿晶体管芯片的未来</h2><p>讨论了在未来的十年里（指的是2001到2011），如何利用10亿个晶体管的技术能力来涉及计算机架构。作者介绍了几种不同的设计方案，包括CMP，SMT、单处理器、简单核心和片上系统，并且表达了自己对最高性能处理器的偏好。所以作者接下来进行更加细致的讲解：</p><h3 id="A-新型微处理器"><a href="#A-新型微处理器" class="headerlink" title="A. 新型微处理器"></a>A. 新型微处理器</h3><p>也就是将原来在软件层面实现的算法和程序放在硬件上来实现，真正的成为一个能够解决问题的处理器，就是新型处理器的进化方向。可以采用的形式是：使用可重构的逻辑、在ISA中设置特殊的专用指令，或者是在芯片上提供的集成功能单元。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230923145827.png"                      alt="image.png" style="zoom:50%;"                 ><h3 id="B-新型数据通路"><a href="#B-新型数据通路" class="headerlink" title="B. 新型数据通路"></a>B. 新型数据通路</h3><p>新型数据通路的挑战就在于根据新的导线长度限制重新设计数据路径。</p><h3 id="C-软错误的纠错机制"><a href="#C-软错误的纠错机制" class="headerlink" title="C. 软错误的纠错机制"></a>C. 软错误的纠错机制</h3><p>另外一个需要考虑的因素就是那些容易受到时钟频率影响的材质问题，会不经意的让处理器出现错误。所以未来的处理器需要能够纠正这样的错误功能。</p><h3 id="D-异步和同步单元的共存问题"><a href="#D-异步和同步单元的共存问题" class="headerlink" title="D. 异步和同步单元的共存问题"></a>D. 异步和同步单元的共存问题</h3><p>由于部分模块同步和异步的性质，当时钟周期在六千兆赫的时候情况就会更糟。作者的期望是能看到在一定的固定时间内进行异步运行的结构，同时和全局的时钟进行同步。不同的结构将要不同的时间，所以就更需要异步操作来解决独特的倾斜问题。</p><h3 id="E-不同功能的不同周期时间"><a href="#E-不同功能的不同周期时间" class="headerlink" title="E. 不同功能的不同周期时间"></a>E. 不同功能的不同周期时间</h3><p>因为不同的模块功能所需要时间（时钟周期数）不同，所以可以例如通过让不需要快速运行的部件设计为慢速运行来达到优化时钟分配的作用，为了解决不同功能的不同周期时间，作者提出希望未来的处理器能够只能的使用时钟，在需要的提放提高速度，在不需要的地方降低速度。这样就能动态的分配资源，节约资源。</p><h3 id="F-新材料"><a href="#F-新材料" class="headerlink" title="F. 新材料"></a>F. 新材料</h3><p>作者不了解未来的材料怎么出现，但是根据摩尔定律，每隔五年就会有关键材料的提升，作者希望未来的材料能够胜任够优秀处理器的功率要求和散热问题。</p><h3 id="G-扩展使用微程序"><a href="#G-扩展使用微程序" class="headerlink" title="G. 扩展使用微程序"></a>G. 扩展使用微程序</h3><p>作者基于离片带宽和片上带宽的成本和丰富性，提出未来的处理器需要更有效的利用片上的带宽。使用扩展的微程序是实现设一个目标的方式。这些微代码能够进行动态的重新编译，计算一些符合指令，调整缓存的替换策略或者用其他的方式来执行计算从而使得主要指令流速度更快。</p><h3 id="H-可重构逻辑"><a href="#H-可重构逻辑" class="headerlink" title="H. 可重构逻辑"></a>H. 可重构逻辑</h3><p>未来的微处理器可能会采用较高粒度的可重构逻辑结构。这种结构可以根据不同应用的需求动态调整，使得微处理器能够更有效地满足特定应用的要求。</p><h3 id="I-展望综合"><a href="#I-展望综合" class="headerlink" title="I. 展望综合"></a>I. 展望综合</h3><p>作者根据自己对未来处理器的设想提出了如下的清单内容：</p><ol><li>类似于块结构的ISA或者重播机制</li><li>利用核心的剩余能力来调整硬件结构的片上微程序</li><li>动态编译正在执行程序</li><li>三级缓存</li><li>用于数值预测的硬件</li><li>监视和影响芯片能源使用的片上结构</li></ol><h2 id="Part-5-总结"><a href="#Part-5-总结" class="headerlink" title="Part 5 总结"></a>Part 5 总结</h2><p>自1971年被发明以来，微处理器经历了一段激动人心的旅程。很少有技术能像它那样取得如此巨大的进步。不幸的是，有些人认为这个黄金时代即将结束。但这种唱反调的人以前也有过。他们说MIPS R2000是1986年所有人都需要的微处理器，十年后，他们说英特尔奔腾Pro是所有人都需要的微处理器。该行业继续做得更好，该技术的用户继续使用“更好”。这并不是说事情不会改变，不再需要新的创造力。在下游，我们可能需要一个彻底的范式转变，比如量子计算来拯救我们，但我们现在几乎没有受到限制。当然，我们需要开发更好的CAD工具。当前的CAD工具在验证当今的微处理器方面存在困难，更不用说本文中的建议了。当然，我们需要更广泛地思考微处理器的概念。但最重要的是，摩尔定律仍然存在，而且仍然提供了大量的机会。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-计算机体系结构第一章作业</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[CourseNotes/计算机体系结构/CA-CPU性能公式]]# Homework 1<h3 id="💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10-，现在希望对浮点操作进行加速。"><a href="#💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10-，现在希望对浮点操作进行加速。" class="headerlink" title="💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10%，现在希望对浮点操作进行加速。"></a>💯假设在某程序执行的过程中，浮点操作占据整个执行时间的10%，现在希望对浮点操作进行加速。</h3><ol><li>设对浮点操作的加速比为$S_r$。画出程序总加速比$S_p$和$S_r$之间的关系曲线</li></ol><p><strong>1~10&#x2F;9 ,  单调递增</strong></p><ol><li>请问程序的最大加速比可以达到多少</li></ol><p><strong>10&#x2F;9, 此时Sf趋于无穷大</strong></p><hr><h3 id="💯计算机系统中有三个部件可以改进，这三个部件的加速比如下："><a href="#💯计算机系统中有三个部件可以改进，这三个部件的加速比如下：" class="headerlink" title="💯计算机系统中有三个部件可以改进，这三个部件的加速比如下："></a>💯计算机系统中有三个部件可以改进，这三个部件的加速比如下：</h3><blockquote><pre><code>        $部件加速比_1 = 30$        $部件加速比_2 = 20$        $部件加速比_3 = 10$</code></pre></blockquote><ol><li>如果部件1和部件2的可改进比例均为30%，那么当部件3的可改进比例为多少的时候，系统加速比才能达到10%。</li></ol><p><strong>约为36.1%</strong></p><ol start="3"><li>如果三个不见的可改进比例分别为30%、30%和20%，三个部件同时改进，那么系统中不可加速部分的执行时间在总执行时间中的比例是多少？</li></ol><p><strong>为22.5%</strong></p><ol start="5"><li>如果相对某个测试程序三个部件的可改进比例分别为20%、20%和70%，要达到最好的改进效果，仅对一个部件改进的时候，要选择哪个部件？如果允许改进两个部件，又应该怎么选择？</li></ol><p><strong>仅改进一个部件的时候,选择改进部件3;<br>改进两个部件的时候,选择改进部件1,3;</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-计算机体系结构第二章作业</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>### 2. 区别不同指令系统的主要因素是什么？根据这个主要因素可以将指令系统结构分为哪三类？>区别不同指令系统的主要因素是指令的长度和操作码的结构。根据这个主要因素，指令系统结构可以分为以下三类：>1. 固定指令长度结构：指令长度固定且操作码结构简单，例如MIPS指令集。>2. 变长指令长度结构：指令长度可变且操作码结构复杂，例如x86指令集。>3. 配位码结构：指令长度固定且操作码结构复杂，例如IBM System/360指令集。这些分类是根据指令的长度和操作码的结构来区分不同的指令系统结构。来源：[计算机科学与技术词典 - 指令系统](https://www.itsfun.com.tw/指令系统/wiki-9390980-7806088)<h3 id="12-根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点"><a href="#12-根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点" class="headerlink" title="12. 根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点"></a>12. 根据CPU性能公式简述RISC指令集结构计算机和CISC指令集结构计算机的性能特点</h3><blockquote><p>RISC和CISC是两种常见的指令集结构。RISC表示精简指令集计算机（Reduced Instruction Set Computer），而CISC表示复杂指令集计算机（Complex Instruction Set Computer）。</p></blockquote><p><strong>RISC指令集结构计算机的性能特点包括</strong>：</p><ol><li>简化的指令集：RISC计算机使用更少、更简单的指令，使得指令执行速度更快。</li><li>精简的指令：RISC指令通常只执行基本操作，如加载、存储、算术和逻辑操作，并不包含复杂的指令。</li><li>流水线技术：RISC计算机通常采用流水线技术，可以同时执行多个指令，提高了指令执行效率。</li><li>高效的编译器：RISC指令集可由编译器更轻松地优化和转换，提高执行效率。<br><strong>CISC指令集结构计算机的性能特点包括</strong>：</li><li>复杂的指令集：CISC计算机提供丰富的指令集，包含复杂的指令和多种寻址模式，提供更高级别的指令操作。</li><li>高级的指令：CISC指令可以执行复杂的操作，如字符串处理、数据类型转换等，减少了编程的复杂度。</li><li>变长指令：CISC指令长度可以不固定，能够执行更多的操作，但也增加了指令的复杂度和执行时间。</li><li>快速的内存访问：CISC计算机通常具有高速缓存，可以减少内存访问时间。</li></ol><h3 id="15-某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？"><a href="#15-某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？" class="headerlink" title="15. 某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？"></a>15. 某机的指令字长为16位，设有单指令地址和二指令地址，如果每个地址字段均为6位，且两地址指令有A条，问单地址指令最多有多少条？</h3><p>（16-A）* 64</p><h3 id="18-某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。"><a href="#18-某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。" class="headerlink" title="18. 某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。"></a>18. 某处理机的指令字长为16位，有二地址指令、单地址指令和0地址指令三类，每个地址字段的长度均为16位。</h3><p><strong>1. 如果二指令地址有15条，单地址指令和零地址指令的条数基本相等，那么单地址指令和零地址指令各有多少条，为三类指令分配操作码。</strong><br><strong>2. 如果指令系统要求这三类指令条数比例为1：9：9，那么这三类指令各有多少条?为三类指令分配操作码。</strong></p><p>15 63 63</p><p>14 126 126</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-编译器控制的预取</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A2%84%E5%8F%96/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%BC%96%E8%AF%91%E5%99%A8%E6%8E%A7%E5%88%B6%E7%9A%84%E9%A2%84%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><h2 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h2><p>Cache性能分析</p><p>✔️ 平均访存失效</p><p>✔️ CPU时间</p><p>改进Cache性能</p><p>降低失效率</p><p>✔️ 3C失效 （强制性失效，容量失效，冲突失效）</p><p>✔️ 调节块的大小</p><p>✔️ 提高相联度</p><p>✔️ Victim Cache 和伪相连Cache</p><p>✔️ 硬件预取</p><p>✔️ 编译器控制的预取</p><h2 id="编译器控制的预取"><a href="#编译器控制的预取" class="headerlink" title="编译器控制的预取"></a>编译器控制的预取</h2><p>$T_{访存} &#x3D; T_H + F \times T_M$</p><p>没有预取的时候 251次失效</p><p>有预取的时候：19次失效</p><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><ol><li><p>基本思想 ： 在编译的时候，对程序中的执行和数据进行重新的组织，降低Cache失效率</p></li><li><p>可以重新组织程序不影响程序的正确性</p></li></ol><ul><li>把一个程序中的过程重新排序，就可能会减少冲突不命中，从而降低不命中率。</li></ul><p>✔️ 研究如何使用配置文件来执行优化</p><p>✔️ 2K字节，缺失率降低50%，8K字节，缺失率降低75%</p><p>针对数据的编译优化技术包括：</p><ul><li>数组合并</li></ul><blockquote><p>存的位置更集中，更容易进行访存</p></blockquote><ul><li>内外循环交换</li></ul><blockquote><p>有些计算是用列来进行运算的时候将数组进行转置，转换成行的计算</p></blockquote><ul><li>循环融合</li></ul><blockquote><p>对同样的数据做不同的运算，就能够在一个循环里面进行，可以在读入Cache的数据在被替换出去之前得到反复的使用</p></blockquote><ul><li>分块</li></ul><h2 id="降低Cache失效率的方法"><a href="#降低Cache失效率的方法" class="headerlink" title="降低Cache失效率的方法"></a>降低Cache失效率的方法</h2><p>增加块的大小</p><p>提高相联度</p><p>牺牲Cache</p><p>伪相连</p><p>硬件预取指令和数据</p><p>编译器控制的预取</p><p>用编译技术减少Cache不命中次数</p><h1 id="减少Cache失效开销"><a href="#减少Cache失效开销" class="headerlink" title="减少Cache失效开销"></a>减少Cache失效开销</h1><h2 id="写缓冲和写合并"><a href="#写缓冲和写合并" class="headerlink" title="写缓冲和写合并"></a>写缓冲和写合并</h2><p>写直达Cache </p><ul><li><p>依靠写缓冲来减少对下一级存储器写操作的时间</p></li><li><p>如果写缓冲其为空，就把数据和对应的地址写入缓冲器</p></li><li><p>从CPU的角度来看，写操作就是完成了</p></li></ul><p>提高写缓冲的效率和利用率 <code>写合并</code></p><p>提好了写缓冲器的空间利用率，而且还能减少因为写缓冲器满了而要进行的等待时间。</p><ul><li><p>如果写缓冲器中已经有了待写入的数据，就要把这次的写入地址与写缓冲器中已有的所有地址进行比较，看是否有匹配的项如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据与该项合并。这就叫写缓冲合并。</p></li><li><p>如果写缓冲器满且又没有能进行写合并的项，就必须等待</p></li></ul><h2 id="让读失效也优先于写"><a href="#让读失效也优先于写" class="headerlink" title="让读失效也优先于写"></a>让读失效也优先于写</h2><ol><li>Cache中的写缓冲器导致对存储器访问的复杂化</li></ol><p>在读不命中时，所读单元的最新值有可能还在写缓冲器中，尚未写入主存。</p><p><strong>例5.9 考虑以下指序列:</strong></p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SW R3,512(R0),  ;M[512]-R3 (Cache Index =0)</span><br><span class="line">LW R1，1024(R0) ;R1-M[1024](Cache Index =0)</span><br><span class="line">LW R2, 512(R0)  ;R2-M512](Cache Index =0)</span><br></pre></td></tr></table></figure></div><p>假设Cache采用写直达法和直接映像，并且地址512和1024映射到同一块，写缓冲器为4个字，问R2的值总等于R3吗?</p><blockquote><p>在执行SW指令之后，R3中数据放入ndex为0的Cache块和写缓器。第一条LW指令将该位置上的数据替换成MI[1024] (读失效)，第条LW指令又要替换这块Cache为M[512] (读失效)如果此时写缓冲还未更新完MI[512]，则R2不等于R3</p></blockquote><ol start="2"><li>解决问题的方法(读失效的处理)</li></ol><h3 id="推迟读失效的处理直到写缓冲排空"><a href="#推迟读失效的处理直到写缓冲排空" class="headerlink" title="推迟读失效的处理直到写缓冲排空"></a>推迟读失效的处理直到写缓冲排空</h3><p>缺点: 读失效的开销增加</p><h3 id="优先读操作"><a href="#优先读操作" class="headerlink" title="优先读操作"></a>优先读操作</h3><p>读失效时先检查写缓冲器中的内容<br>缺点:增加硬件</p><h2 id="请求字处理"><a href="#请求字处理" class="headerlink" title="请求字处理"></a>请求字处理</h2><ol><li>请求字(Requested Word)</li></ol><p>从下一级存储器调入Cache的块中，只有一个字是立即需要的。这个字称为请求字。</p><ol start="2"><li>应尽早把请求字发送给CPU</li></ol><p><strong>尽早重启动</strong>：调块时，从块的起始位置开始读起旦请求字到达，就立即发送给CPU，让CPU继续执行。</p><p><strong>请求字优先</strong>：调块时，从请求字所在的位置读起。这样，第一个读出的字便是请求字。将之立即发送给CPU。</p><ol start="3"><li>这种技术在Cache块比较小的情况下的效果不大，下一指令正好访问同一个Cache块的另一个部分</li></ol><h2 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h2><ol><li>应把Cache做得更快?还是更大?</li></ol><p>答案:二者兼顾，再增加一级Cache</p><ul><li>第一级Cache(L1)小而快。</li></ul><p>与快速的CPU运行时钟周期时间相匹配</p><ul><li>第二级Cache(L2)容量大</li></ul><p>捕捉到对主存进行的大多数访问</p><ol start="2"><li>性能分析</li></ol><p>$平均访问时间 &#x3D; 命中时间_{L1} + 失效率_{L1} \times 失效开销_{L1}$</p><ol start="3"><li>局部失效率和全局失效率</li></ol><p>$局部失效率 &#x3D; 该级Cache的失效次数&#x2F;到达该级Cache的访问次数$</p><p>$全局失效率 &#x3D; n级Cache的失效次数&#x2F;CPU发出的访存总次数$</p><p>$全局失效率 &#x3D; 失效率_{L1} \times 失效率_{L2}$</p><p>评价多级Cache的时候应该使用<strong>全局失效率</strong>的指标</p><p>假设某一两级Cache: 第一级Cache为L1，第二级Cache为L2(1) 设在1000次访存中，L1的不命中是40，L2的不命中是20。求各种局部不命中率和全局不命中率。(2L210个，L2开200时钟周期，L1的命中时间是1个时钟周期，平均每条指令访存1.5次，不考虑写操作的影响。问:平均访存时间是多少?每条指令的平均停顿时间是多少个时钟周期?</p><p>解<br>(1)<br>第一级Cache的不命中率(全局和局部) 是40&#x2F;1000，即4%;<br>第二级Cache的局部不命中率是20&#x2F;40，即50%;<br>第二级Cache的全局不命中率是20&#x2F;1000，即2%。<br>(2)<br>平均访存时间 &#x3D; 命中时间_{L1}<br>&#x3D;1+4% * (10+50% *200)<br>&#x3D;1+4% * 110 &#x3D; 5.4个时钟周期<br>每次访存的平均停顿时间为:  5.4-1.0&#x3D;4.4<br>所以:<br>由于平均每条指令访存1.5次每条指令的平均停顿时间&#x3D;4.4 * 1.5&#x3D;6.6个时钟周期</p><h3 id="Miss-Status-Holding-Register"><a href="#Miss-Status-Holding-Register" class="headerlink" title="Miss Status Holding Register"></a>Miss Status Holding Register</h3><p>MSHR包含正在等待处理的失效</p><p>相同的块可以包含多个未解决的Load&#x2F;Store失效</p><p>可以有多个没有解决的块地址</p><p>失效可以分为：</p><ol><li>第一次发起存储请求的时候的字符串</li></ol><h3 id="MSHR-Operation"><a href="#MSHR-Operation" class="headerlink" title="MSHR Operation"></a>MSHR Operation</h3><p>当失效的时候</p><table><thead><tr><th align="left">优化技术</th><th align="left">命中开销</th><th align="left">硬件复杂度</th></tr></thead><tbody><tr><td align="left">写缓冲写合并</td><td align="left">+</td><td align="left">1</td></tr><tr><td align="left">使读失效优先于写</td><td align="left">+</td><td align="left">1</td></tr><tr><td align="left">请求字处理</td><td align="left">+</td><td align="left">2</td></tr><tr><td align="left">两级cache</td><td align="left">+</td><td align="left">2</td></tr><tr><td align="left">非阻塞cache</td><td align="left">+</td><td align="left">3</td></tr></tbody></table><h2 id="减少命中时间"><a href="#减少命中时间" class="headerlink" title="减少命中时间"></a>减少命中时间</h2><p>命中时间直接影响到处理器的时钟频率。在当今的许多计算机中，往往是Cache的访问时间限制了处理器的时钟频率</p><h3 id="容量小，结构简单的Cache"><a href="#容量小，结构简单的Cache" class="headerlink" title="容量小，结构简单的Cache"></a>容量小，结构简单的Cache</h3><p>硬件越简单 速度就越快。</p><p>应该让Cache足够小，便于可以和CPU一起放在同一块芯片上。</p><p>折衷：Cache放在片内，把Cache的数据存储器放在片外，这样既可以实现快速标识检测，又能利用独立的存储芯片来提供更大的容量。</p><p>多级Cache，一级Cache大多采用2路组相联或者直接映像。</p><p>In recent designs, there are <strong>three</strong> other factors that have led to the use of higher associativity in first-level caches</p><ul><li><p>many processors take at least two clock cycles toaccess the cache and thus the impact of a longer hittime may not be critical</p></li><li><p>with the introduction of multithreading, conflict missescan increase, making higher associativity moreattractive</p></li><li><p>keep the TLB out of the critical path (a delay thatwould be larger than that associated with increasedassociativity</p></li></ul><h1 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h1><p>存储器组织技术</p><p>假设基本存储器结构的性能为：</p><p>送地址需要4个时钟周期，每个字访问时间为24个时钟周期</p><p>传送一个字的数据需要4个时钟周期</p><p>如果Cache大小是4个字，那么：</p><p>$失效开销&#x3D;4 \times (4+24+4) &#x3D; 128(时钟周期)$</p><p>存储器组织技术：</p><ol><li>增加存储器的宽度</li></ol><blockquote><p>增设Cache和多路选择器</p></blockquote><p><strong>性能分析</strong>:失效开销更改为32周期，带宽变为0.5字节&#x2F;周期</p><p><strong>缺点</strong>：</p><ul><li>增加CPU和存储器之间的连接通路宽度</li><li>CPU和Cache之间有一个多路选择器</li><li>扩充主存的最小增量增加了相应的倍数</li><li>写入有可能变得复杂</li></ul><p><strong>实例</strong>：DEC的Alpha Axp21064</p><ol start="2"><li>采用简单的多体交叉存储器</li></ol><p>存储系统中采用多个DRAM，利用它们潜在的并行性</p><p>分时启动</p><p>每个个体都有独立的MAR和读&#x2F;写电路</p><p>初始的时间是CPI&#x3D;3.15</p><p>块 2个字</p><p>64位总线和存储器，不采用多体交叉</p><p>性能提高了14%</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-第十四讲 分支目标缓冲</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AE%B2%20%E5%88%86%E6%94%AF%E7%9B%AE%E6%A0%87%E7%BC%93%E5%86%B2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AE%B2%20%E5%88%86%E6%94%AF%E7%9B%AE%E6%A0%87%E7%BC%93%E5%86%B2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<h2 id="BTB实现"><a href="#BTB实现" class="headerlink" title="BTB实现"></a>BTB实现</h2><p>分支目标缓存BTB每个单元应该包括</p><ul><li>分支指令的地址</li><li>分支目标的地址</li><li>分支预测标识</li></ul><p>取指阶段，所有指令地址都和BTB中保存的分支指令地址作比较，一旦相同，就认为本指令是分支指令，并且分支成功</p><p>它的目标地址就是保存在缓冲区内的分支目标地址</p><ul><li>取出之后直接送入NPC</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018081222.png"                      alt="image.png"                ></p><h2 id="BTB的执行过程"><a href="#BTB的执行过程" class="headerlink" title="BTB的执行过程"></a>BTB的执行过程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018081242.png"                      alt="image.png"                ></p><h2 id="采用BTB技术的时候在各种情况下的延迟"><a href="#采用BTB技术的时候在各种情况下的延迟" class="headerlink" title="采用BTB技术的时候在各种情况下的延迟"></a>采用BTB技术的时候在各种情况下的延迟</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018081330.png"                      alt="image.png"                ></p><h2 id="BTB的改进"><a href="#BTB的改进" class="headerlink" title="BTB的改进"></a>BTB的改进</h2><p>分支预测技术受限于预测精度，以预测失效之后产生的开销</p><p>根据不同程序特点以及缓冲区的大小，典型的BTB可以实现80%到95%的预测精度</p><p>降低失效开销技术：在一个时钟周期内同时取出不同分支路径的指令</p><ul><li>会引入其他开销，比如存储器洗头膏的端口加倍</li></ul><h2 id="Instruction-Fech-Unit"><a href="#Instruction-Fech-Unit" class="headerlink" title="Instruction Fech Unit"></a>Instruction Fech Unit</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018082131.png"                      alt="image.png"                ></p><h2 id="分支预测局限性总结"><a href="#分支预测局限性总结" class="headerlink" title="分支预测局限性总结"></a>分支预测局限性总结</h2><p>预测的准确性：80% ~ 90%</p><p>预测性能依赖于</p><ul><li>程序类型</li><li>缓冲区大小</li></ul><p>预测失效开销的优化</p><ul><li>预测不同分支路径指令</li><li>存储端口数目加倍，交叉存取缓冲</li></ul><h2 id="Corei7分支预测浪费的指令"><a href="#Corei7分支预测浪费的指令" class="headerlink" title="Corei7分支预测浪费的指令"></a>Corei7分支预测浪费的指令</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018082652.png"                      alt="image.png"                ></p><h1 id="基于硬件的前瞻执行"><a href="#基于硬件的前瞻执行" class="headerlink" title="基于硬件的前瞻执行"></a>基于硬件的前瞻执行</h1><p><strong>前瞻执行的基本思想</strong>：</p><p>对于分支指令的结果进行猜测，并假设这个猜测总是对的，然后按照这个猜测结果继续取、流出和执行后续的指令。</p><p>执行指令的结果不是写回到寄存器或者是存储器，而是写入一个称为再定序缓冲器ROB（ReOrder Buffer。得到相应的指令得到”确认“(commit)（也就是确实是应该执行的）之后，才将结果写入寄存器或者存储器</p><p>基于硬件的前瞻执行结合了<strong>3种思想</strong>：</p><ul><li>采用动态分支预测来选择后续执行的指令</li><li>在控制相关的结果尚未出来之前，前瞻的执行后续指令</li><li>对基本块采用动态调度</li></ul><p>对Tomasulo算法加以扩充，就可以支持前瞻执行。</p><ul><li>把Tomasulo算法的写结果和指令完成加以区分写成两个不同的段：<ul><li>写结果，指令确认</li></ul></li></ul><h3 id="写结果段"><a href="#写结果段" class="headerlink" title="写结果段"></a>写结果段</h3><ul><li>把前瞻执行的结果写到ROB种</li><li>通过CDB在指令之间传送结果，供需要用到这些结果的指令使用</li></ul><h3 id="指令确认段"><a href="#指令确认段" class="headerlink" title="指令确认段"></a>指令确认段</h3><p>在分支指令结果出来之后，对相应的指令的前瞻执行给予确认。</p><ul><li>如果前面所做的猜测是正确的，把ROB中的结果写到寄存器或者存储器。</li><li>如果发现前面对分支结果的猜测是错误的，那就不予以确认，刷新ROB，并从那条分支指令的另一条路径开始重新执行</li></ul><p><strong>ROB中的每一项由以下的4个字段组成</strong>：</p><ul><li>指令类型（instruction）</li><li>状态（state）</li><li>目标地址（destination)</li><li>数据值（value）</li></ul><p><strong>保留站RS中增加的域</strong>：</p><ul><li>目标地址(destination)：对应的ROB编号</li></ul><p>In-Order Issue&#x2F;Commit<br>Out-of-order Execution&#x2F;Writeback</p><h2 id="前瞻执行的流程"><a href="#前瞻执行的流程" class="headerlink" title="前瞻执行的流程"></a>前瞻执行的流程</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231018085112.png"                      alt="image.png"                ></p><h2 id="支持前瞻执行的Tomasulo算法的总结"><a href="#支持前瞻执行的Tomasulo算法的总结" class="headerlink" title="支持前瞻执行的Tomasulo算法的总结"></a>支持前瞻执行的Tomasulo算法的总结</h2><p>实际系统的实现非常相似</p><ul><li>Pretium P6 PowerPC,MIPS多种型号等</li></ul><p>不足之处：硬件非常复杂</p><ul><li><p>Too many value copy operations</p><ul><li>Register File RS ROB Register</li></ul></li><li><p>Too many muxes&#x2F;buses(CDB)</p><ul><li>Values are from everywhere to every</li></ul></li></ul><h2 id="超标量"><a href="#超标量" class="headerlink" title="超标量"></a>超标量</h2><p>超标量处理器的可获得的并行度，需要才哟个更有效的编译技术</p><p>循环展开成5个副本</p><p>使用先前用到的代码作为例子</p><p>在超标量流水线上对代码进行调度以获得更多的指令机并行度</p><p>每一次迭代需要12个时钟周期。</p><p>每个迭代的时候为2.4个时钟周期</p><ul><li>前面在普通的流水线上，通过循环展和调度，可以达到每个迭代为3.5个时钟周期</li><li>超标量可以获得更好的性能，代价是硬件复杂性大幅度增加</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-第十二讲 指令集并行</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<p>Recap</p><p>ILP是指令序列潜在的并行性、软硬件技术相结合<br>结构冲突、数据冲突、控制冲突对CPI的影响<br>基本块和循环级并行</p><p><strong>循环展开调度的基本方法</strong><br>浮点流水线、整数流水线的特性<br>循环无调度执行<br>循环调度、循环展开<br>循环展开并结合调度执行</p><h1 id="指令的动态调度"><a href="#指令的动态调度" class="headerlink" title="指令的动态调度"></a>指令的动态调度</h1><h2 id="动态调度原理"><a href="#动态调度原理" class="headerlink" title="动态调度原理"></a>动态调度原理</h2><p>编译器本质上通过对循环中的寄存器重命名开展开循环</p><p>硬件也可以通过寄存器重命名和乱序执行的方法（OoO）来获得同样的效果</p><h3 id="冲突的检测和调度"><a href="#冲突的检测和调度" class="headerlink" title="冲突的检测和调度"></a>冲突的检测和调度</h3><p>存在数据相关：</p><ol><li>暂停</li><li>停止取指和发射指令</li></ol><p><em><strong>静态调度</strong></em>：</p><p>依靠编译器</p><p>编译期间的代码调度和优化</p><p>相关指令拉开距离来减少可能产生的停顿</p><p><em><strong>动态调度</strong></em>：</p><p>依靠专门硬件对代码进行调度</p><h3 id="动态调度的原理"><a href="#动态调度的原理" class="headerlink" title="动态调度的原理"></a>动态调度的原理</h3><p>指令是按照顺序流出的，是按照顺序执行的</p><div class="highlight-container" data-rel="Basic"><figure class="iseeu highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIVD F4 F0 F2</span><br><span class="line">ADDD F10 F4 F6</span><br><span class="line">SUBD F12 F6 F14</span><br></pre></td></tr></table></figure></div><p>ADDD指令和DIVD指令关于F4相关，导致流水线停顿</p><p>SUBD指令虽然无关，<strong>但是也会被阻塞</strong></p><p>在基本流水线中</p><ul><li>检测结构冲突</li><li>检测数据冲突</li></ul><p>乱序执行</p><p>指令的执行顺序和程序的顺序不同<br>指令的完成也不同</p><p>为了支持<strong>乱序执行</strong></p><p><strong>流出</strong>：指令译码，检查是否有数据冲突</p><p><strong>读操作数</strong></p><h3 id="动态调度算法之一：记分牌"><a href="#动态调度算法之一：记分牌" class="headerlink" title="动态调度算法之一：记分牌"></a>动态调度算法之一：记分牌</h3><p>记分牌在1964年被Cray用于CDC 6600</p><p>记分牌允许乱序执行，前提是：</p><ul><li><p>充足的资源</p></li><li><p>指令可以乱序执行</p></li></ul><p>基本原理：</p><p>每条指令经过记分牌，记录各个指令之间的数据相关的信息，进行相关的检测，控制指令的流出和执行</p><p>如果记分牌判断出一条指令不能立即执行，它就检测硬件的变化从而决定什么时候可以执行</p><p>集中控制寄存器和处理单元的数据传送，检测或者消除数据的相关性，加快程序的执行速度</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011082554.png"                      alt="image.png" style="zoom:50%;"                 ><h4 id="记分牌的执行过程"><a href="#记分牌的执行过程" class="headerlink" title="记分牌的执行过程"></a>记分牌的执行过程</h4><ol><li><p>流出</p><ul><li>本指令所需要的功能部件有空闲</li><li>正在执行指令使用的目的寄存器和本指令不同<br>  :heavy_check_mark: 保证没有写后写相关（<code>WAW</code>）</li><li>如果存在结构冲突或者WAW相关，这个指令就不会流出，本指令就不会流出，后面的指令也不会流出，直至阻塞消失</li></ul></li><li><p>读操作数</p><ul><li>前面已经流出的还在运行的指令不会本指令的源操作数寄存器进行写操作</li><li>一个正在工作的功能部件已经完成了对这个寄存器的写操作<br>  :heavy_check_mark: 动态解决RAW相关</li></ul></li></ol><blockquote><p><strong>前面两步完成了原来ID段的功能</strong></p></blockquote><ol start="3"><li>执行</li></ol><ul><li>开始于取到操作数之后</li><li>结果产生之后，修改记分牌</li><li>FP流水部件会占用多个周期</li></ul><ol start="4"><li>写结果：<strong>检查WAR相关</strong></li></ol><p>  出现以下的情况的时候，不允许指令写结果</p><ul><li>前面某条指令（已经按照顺序）还没有读取操作数</li><li>而且其中某个源造作书和本指令的目的寄存器相同</li></ul><h4 id="记分牌结构"><a href="#记分牌结构" class="headerlink" title="记分牌结构"></a>记分牌结构</h4><p>指令状态表</p><p>功能部件的状态表</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231011084825332.png"                      alt="image-20231011084825332" style="zoom:50%;"                 ><p>结果寄存器状态表</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231011083849333.png"                      alt="image-20231011083849333" style="zoom:50%;"                 >#### 记分牌实例<img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011084344.png"                      style="zoom:50%;"                 ><p>In-order Issue</p><p>out-of-order execute</p><p>out-of-order WR</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231011090944982.png"                      alt="image-20231011090944982" style="zoom:50%;"                 >### 动态调度算法之二：Tomasulo算法<p>整个360系列仅一个指令系统和一个编译器</p><p>要求具有很高的浮点性能，但是不是通过高端机器的专用的编译器实现</p><p>只有四个双精度浮点寄存器，编译器调度的有效性受到很大的限制</p><p>访存时间和浮点运算的时间都很长</p><p>可以支持的循环的多次迭代重叠执行</p><h3 id="Tamassulo和记分牌"><a href="#Tamassulo和记分牌" class="headerlink" title="Tamassulo和记分牌"></a>Tamassulo和记分牌</h3><p>采用了很多和记分牌中的理念</p><p>两个较大的差异</p><ul><li><p>Tomasulo算法中，冲突检测和执行控制是分布的，利用保留站实现</p></li><li><p>Tomasulo算法不检查WAR和WAW相关通过算法本身消除。<strong>计算结果</strong>通过专用通道直接从功能部件<strong>进入到保留站进行缓冲</strong>，而不是写到寄存器。</p></li></ul><h3 id="Tomasulo算法核心思想"><a href="#Tomasulo算法核心思想" class="headerlink" title="Tomasulo算法核心思想"></a>Tomasulo算法核心思想</h3><p>记录并检测指令的RAW相关，操作数一旦准备就绪就立即执行，把发生RAW冲突的可能性降到最低。</p><p>不检查WAR和WAW相关，通过换名（Remainning）技术来消除WAR和WAW冲突</p><p>✔️ 基于Tomasulo算法的MIPS处理器浮点部件的基本结构</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011092721.png"                      alt="image.png" style="zoom: 50%;"                 ><p><strong>MIPS五阶段的流水线的改造</strong></p><ol><li>流出（数据就已经在保留栈中）<br>✨ 所以就不需要进行读出数据了</li><li>执行</li><li>结果写回</li></ol><p>Tomasulo算法的三阶段</p><ol><li><p>Issue：从队列中取出指令，如果存在一个空闲的保留站，就控制发射指令和操作数，消除WAR，WAW相关</p></li><li><p>Execution：当两个操作数就绪的时候就可以执行；如果没有准备好，就检测Common Data Bus 来获取结果；通过推迟指令执行避免RAW相关</p></li><li><p>Write result：将结果通过Common Data Bus 传给所有等待该结果的部件</p></li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093440.png"                      alt="image.png" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093449.png"                      alt="image.png" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093458.png"                      alt="image.png" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011093507.png"                      alt="image.png" style="zoom:67%;"                 >#### 和记分牌的不同<p>无需任何的操作来检查数据的写后写WAW和先读后写WAR冲突，在指令流出的过程中，操作数寄存器号换成操作数本身（如果已经就绪）或者相应的保留站标识</p><p>通过公共数据总线来广播结果，将计算结果直接东产生的保留站传送到所有需要它的功能部件而不需要经过寄存器（动态解决了RAW）</p><p>存储器存和取都能作为基本的功能部件</p><p>由于保留站技术能够有效的解决先写后读，记分牌中的用于判断RAW的’<em>取操作数</em>‘段被取消。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令集并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-第十三讲</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AE%B2%20Tomasulo%20%E5%92%8C%20%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%A3%E5%86%B3%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AE%B2%20Tomasulo%20%E5%92%8C%20%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%A3%E5%86%B3%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<h2 id="Reservation-Station-结构"><a href="#Reservation-Station-结构" class="headerlink" title="Reservation Station 结构"></a>Reservation Station 结构</h2><p><code>Op</code>: 部件所进行的操作<br><code>Vj</code>, <code>Vk</code>: 源操作数的值。Store 缓冲区有Vk域，用于存放要写入存储器的 值。V域和Q域不同时有效。<br><code>A</code>：存放存储器地址。开始存立即数，计算出有效地址后，存放有效地址<br><code>Qj</code>, <code>Qk</code>: 产生源操作数的保留站号<br>✓ 没有记分牌中的准备就绪标志， Qj, Qk&#x3D;0 &#x3D;&gt; ready<br>✓ Store 缓存区只有Qk表示产生结果的保留站号<br><code>Busy</code>: 标识保留站RS或相应的功能部件FU是否空闲</p><p>Register result status—如果存在对寄存器的写操作，指示对该寄存器 进行写操作的部件. <code>Qi</code>: 保留站的编号</p><h2 id="Tomasulo实例"><a href="#Tomasulo实例" class="headerlink" title="Tomasulo实例"></a>Tomasulo实例</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016102533.png"                      alt="image.png"                ></p><p>Note：不像是记分牌，两个Lw指令可以一起流出</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016103304.png"                      alt="image.png"                ></p><p>在第六拍的时候所有指令就全部流出了</p><p>减法完成之后，需要去做什么？<strong>可以看到加法指令在第八拍的时候需要</strong></p><p>Add2拿到的两个操作数之后就立即启动</p><p>加法做完之后也可以把结果写回 <strong>这是和记分牌最不一样的地方</strong></p><p>根本上来讲也是按序的流出，乱序的进行执行，乱序的写入</p><h2 id="基于Tomasulo算法的动态循环展开"><a href="#基于Tomasulo算法的动态循环展开" class="headerlink" title="基于Tomasulo算法的动态循环展开"></a>基于Tomasulo算法的动态循环展开</h2><p>为了保证正确的异常行为，Tomasulo算法对指令的执行有一个限制：一旦有一条分支指令还没有执行完，其后的指令是不允许进入执行段的</p><p>动态存储器地址判别技术，解决存储器访问的时候的RAW、WAW、WAR冲突</p><p>第一次取数LD，由于Cache miss,需要8个时钟周期延迟，之后的取数LD，只需要一个时钟周期，存数SD需要3个时钟周期。</p><p>乘法需要4个时钟周期</p><h2 id="Tomasulo循环实例"><a href="#Tomasulo循环实例" class="headerlink" title="Tomasulo循环实例"></a>Tomasulo循环实例</h2><p>Loop： LD F0, 0(R1)<br>           MULTD F4, F0, F2<br>           SD 0(R1), F4<br>           SUBI R1, R1, #8<br>           BNEZ R1, Loop</p><p>存在隐含的换名情况</p><p>[[课件综合&#x2F;计算机体系结构 - 第13讲.pdf#page&#x3D;35&amp;selection&#x3D;236,0,239,7|计算机体系结构 - 第13讲, page 35]]</p><p>F0被动态的消除了</p><h2 id="Tomasulo算法的优点"><a href="#Tomasulo算法的优点" class="headerlink" title="Tomasulo算法的优点"></a>Tomasulo算法的优点</h2><p>分布式硬件冲突检测</p><p>利用寄存器换名，彻底消除WAW和WAR这两种名相关</p><p>如果多个保留站等待同一个操作数，当操作数在CDB上广播的时候，它们可以同时获得所需要的数据</p><p>对于存储器访问，<strong>动态存储器地址判别技术</strong>可以解决RAW冲突（取操作数的时候判断）、WAR和WAW冲突（存操作数的时候判断）</p><p>能够达到很高的性能</p><h2 id="Tomasulo-算法的缺点"><a href="#Tomasulo-算法的缺点" class="headerlink" title="Tomasulo 算法的缺点"></a>Tomasulo 算法的缺点</h2><p>高复杂性：需要大量的硬件</p><p>存在瓶颈：单个数据总线会引发竞争</p><p>需要额外的数据总线：在每个保留站上需要为每条总线都设置重复的硬件接口</p><p>为了保证正确的异常行为，对指令的执行有一个限制：</p><p><strong>一旦有一条指令还没有执行完，其后的指令是不允许进入执行段</strong></p><h2 id="动态调度方法中的异常行为处理"><a href="#动态调度方法中的异常行为处理" class="headerlink" title="动态调度方法中的异常行为处理"></a>动态调度方法中的异常行为处理</h2><p>指令乱序大大增加了异常处理的复杂度。</p><p>不精确异常（Imprecise Exeption）：当指令i导致发生异常的时候，处理机的现场（状态）和严格按照程序顺序执行不相同。</p><p>精确异常(Precise Exception)：处理机现场和严格按照程序新婚徐执行的时候指令i的现场相同</p><p>不精确异常产生的原因：</p><p>:heavy_check_mark: 流水线可能已经执行完按照程序顺序是位于指令i之后的指令</p><p>:heavy_check_mark:流水线可能还没有完成按照程序顺序是指令i之前的指令</p><h2 id="动态调度方法中的异常行为处理-1"><a href="#动态调度方法中的异常行为处理-1" class="headerlink" title="动态调度方法中的异常行为处理"></a>动态调度方法中的异常行为处理</h2><p>ADD指令LW指令SUB指令没有数据相关，可以乱序执行</p><p>SUB指令在LW指令执行完之前，更改R7</p><p>但是LW指令可能会硬气存储器的异常（如访存缺页、访存越界等）</p><h1 id="控制相关的动态解决技术"><a href="#控制相关的动态解决技术" class="headerlink" title="控制相关的动态解决技术"></a>控制相关的动态解决技术</h1><h2 id="分支预测缓冲"><a href="#分支预测缓冲" class="headerlink" title="分支预测缓冲"></a>分支预测缓冲</h2><p>动态分支的两个理由</p><ul><li>n流出的处理器加速上限为n倍</li><li>Amdahl定律提示：在较低CPI机器上，控制相关导致的空转对机器性能影响大</li></ul><p>前面解决控制相关的静态策略</p><ul><li>需要编译器将一条或者多条指令移动到流水线产生的分支延迟槽中</li></ul><p>关于分支预测的两部分工作</p><ul><li>预测的分支是否成功</li><li>执行分支目标指令</li></ul><h2 id="分支预测的效果"><a href="#分支预测的效果" class="headerlink" title="分支预测的效果"></a>分支预测的效果</h2><p>预测的准确率</p><p>分支的开销</p><ul><li>预测正确的开销</li><li>预测错误的开销</li><li>决定分支开销的因素：流水线的结构、预测的方法、预测错误的时候的回复策略等</li></ul><h2 id="分支预测缓冲（BPB）：原理"><a href="#分支预测缓冲（BPB）：原理" class="headerlink" title="分支预测缓冲（BPB）：原理"></a>分支预测缓冲（BPB）：原理</h2><p>最简单的分支预测策略</p><p>BPB也被称为BHT（Branch History Table,BHT）</p><p>分支预测缓冲是一个小的存储器阵列</p><ul><li>每个单元最小可以只有一位，记录最近一次的分支是否成功的信息</li><li>预测位为1的时候，标识预测分支成功，并从目标分支位置开始取指令</li><li>在预测错误的时候，要作废已经预取和分析的指令，恢复现场，并从零一条分支路径重新取指令</li></ul><h2 id="分支预测指令不成功和重新执行过程"><a href="#分支预测指令不成功和重新执行过程" class="headerlink" title="分支预测指令不成功和重新执行过程"></a>分支预测指令不成功和重新执行过程</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016112704067.png"                      alt="image-20231016112704067" style="zoom:67%;"                 ><h3 id="一位的BOB的状态图"><a href="#一位的BOB的状态图" class="headerlink" title="一位的BOB的状态图"></a>一位的BOB的状态图</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016112809699.png"                      alt="image-20231016112809699"                ></p><p>这种单位预测策略：</p><ul><li>当分支不成功的时候，将会发生连续两次预测出错</li><li>2位预测策略能够改善这种情况</li></ul><h3 id="2位BPB工作原理"><a href="#2位BPB工作原理" class="headerlink" title="2位BPB工作原理"></a>2位BPB工作原理</h3><p>在两位的预测策略中，一个预测必须错误两次才会改变。</p><p>对于一个2096条记录的BPB，利用两位预测策略，用SPEC89测试，命中率位82%到99%</p><p>准确率最高的测试程序一般包含大量的循环</p><p>没有循环的线性代码一般准确率最差</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016113235730.png"                      alt="image-20231016113235730" style="zoom:67%;"                 ><p>还有另外一种的状态转化图：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016113405020.png"                      alt="image-20231016113405020" style="zoom:67%;"                 ><h2 id="4096单元2位BPB的预测错误率"><a href="#4096单元2位BPB的预测错误率" class="headerlink" title="4096单元2位BPB的预测错误率"></a>4096单元2位BPB的预测错误率</h2><p>测试程序位SPEC89</p><p>整数测试程序：平均11%</p><ul><li>gcc, espresso,eqntott,li</li></ul><p>浮点测试程序：平均4%</p><ul><li>nasa7,matrix300,tomcatv</li></ul><p>为什么？</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016113854745.png"                      alt="image-20231016113854745" style="zoom:50%;"                 ><h2 id="BPB实现"><a href="#BPB实现" class="headerlink" title="BPB实现"></a>BPB实现</h2><p>BPB的实现方案</p><ul><li>实现一个小而特殊的”cache“，利用指令地址进行寻址，在IF流水段访问</li><li>为指令cache中每一块增加附加位，与指令一起取出</li></ul><p>如果一个指令在ID段被译码位分支指令，且对应的BPB标志位预测其成功，则</p><ul><li>一旦PC已知，立刻从分支目标位置开始取指</li></ul><p>对于改进MIPS，分支判断和计算分支目标地址都在ID段完成，BPB无效果</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-第八讲 流水线技术</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%85%AB%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%85%AB%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># Recap<ul><li>流水线的基本概念<ul><li><input checked="" disabled="" type="checkbox"> 流水技术的定义</li><li><input checked="" disabled="" type="checkbox"> 流水线的特点</li></ul></li><li>流水线的分类<ul><li><input checked="" disabled="" type="checkbox"> 实现的功能（单功能和双功能）</li><li><input checked="" disabled="" type="checkbox"> 连接方式（静态和动态）</li><li><input checked="" disabled="" type="checkbox"> 子过程的粒度（部件级、处理机级和处理机间）</li><li><input checked="" disabled="" type="checkbox"> 数据表示（标量和向量）</li><li><input checked="" disabled="" type="checkbox"> 反馈回路 （线性和非线性）</li></ul></li><li>MIPS基本流水线<ul><li><input checked="" disabled="" type="checkbox"> 将数据通路划分流水段，加入段间寄存器文件</li><li><input checked="" disabled="" type="checkbox"> 没功能段完成指令子过程的相应操作</li><li><input checked="" disabled="" type="checkbox"> 多路线选择器的控制</li></ul></li></ul><h2 id="流水线性能分析"><a href="#流水线性能分析" class="headerlink" title="流水线性能分析"></a>流水线性能分析</h2><p><strong>三项性能指标：吞吐率、加速比和效率</strong></p><h3 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h3><p>是衡量流水线的重要指标</p><ul><li><p>吞吐率是指单位时间内流水线所完成的任务数或输出结果的数量</p></li><li><p>最大吞吐率$TP_{max}$是指流水线在达到稳定状态后所得到的吞吐率。</p></li><li><p>设流水线由m段组成，完成n个任务的吞吐率称为 <strong>实际吞吐率</strong>，记作<strong>TP</strong></p></li></ul><h3 id="最大吞吐率"><a href="#最大吞吐率" class="headerlink" title="最大吞吐率"></a>最大吞吐率</h3><p>假设流水线的隔断时间相等，均为$\Delta t_0$，则：<br>$TP_{max}&#x3D;1&#x2F;\Delta t_0$<br>假设流水线隔段时间不等，第i段时间为$\Delta t_i$,则：<br>$TP_{max}&#x3D;1&#x2F;max{\Delta t_i}$</p><ul><li>最大吞吐率取决于流水线中最慢的一段时间，这段称为流水线的瓶颈</li></ul><p><strong>- 消除瓶颈的方法</strong></p><ul><li>细分瓶颈段</li><li>重复设置瓶颈段</li></ul><h3 id="实际吞吐率"><a href="#实际吞吐率" class="headerlink" title="实际吞吐率"></a>实际吞吐率</h3><ul><li>如果隔断时间相等（假设均为$\Delta t_0$）,则完成时间</li></ul><p>$T_{流水}&#x3D;m\Delta t_0 + (n-1)\Delta t_0$</p><h3 id="实际吞吐率-1"><a href="#实际吞吐率-1" class="headerlink" title="实际吞吐率"></a>实际吞吐率</h3><p>$$<br>TP&#x3D;\frac n{T_{\textit{流水}} }&#x3D;\frac n{<em>{m{\Delta}t</em>{0}+(n-1)\bullet{\Delta}t_{0}}}<br>$$<br>$$<br>TP&#x3D;\frac{n}{\sum_{\mathrm{i}&#x3D;1}^{m}\Delta t_{i}+(n-1):\Delta t_{j}}<br>$$</p><h3 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h3><p>如果流水线是m段，每一段时间均为$\Delta t_0$,那么<br>$$<br>S&#x3D;\frac{\mathrm{mn}}{m+n-1}&#x3D;\frac{m}{1+\frac{m-1}n}<br>$$</p><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>通过时间和排空时间使得各段不是一直满负载工作</p><p>$$<br>E&#x3D;\frac{n\triangle t_{o}}{T_{流水}}&#x3D;\frac{n}{m+n-1}&#x3D;\frac{1}{1+\frac{m-1}{n}}<br>$$</p><h2 id="流水线举例"><a href="#流水线举例" class="headerlink" title="流水线举例"></a>流水线举例</h2><p>$$<br>\sum^{4}_{i&#x3D;1}A_iB_i&#x3D; A_1B_1+A_2B_2+A_3B_3+A_4B_4<br>$$</p><p>乘法：1，6，7，8 —— 4次<br>加法：1，2，3，4，5，8 —— 3次</p><h3 id="有关流水线性能的若干问题"><a href="#有关流水线性能的若干问题" class="headerlink" title="有关流水线性能的若干问题"></a>有关流水线性能的若干问题</h3><ul><li>流水线并不能减少单条指令的执行时间，但是能够提高吞吐率</li></ul><h2 id="流水线中的冲突"><a href="#流水线中的冲突" class="headerlink" title="流水线中的冲突"></a>流水线中的冲突</h2><p>结构冲突<br>数据冲突<br>控制冲突</p><p>导致结构冲突的常见原因</p><ul><li>功能部件不是全流水</li><li>重复设置的资源数量不足</li></ul><p>示例：当数据和指令在同一个寄存器中的时候，访存指令回应一存储器访问冲突</p><p>解决方法：</p><ul><li>插入暂停周期</li><li>将指令寄存器和数据存储器分离</li></ul><h3 id="避免结构冲突的方法"><a href="#避免结构冲突的方法" class="headerlink" title="避免结构冲突的方法"></a>避免结构冲突的方法</h3><ul><li>所有功能单元完全流水化</li><li>设置足够多的硬件资源 但是硬件代价很大！</li></ul><p>当前许多机器都没有将浮点功能单元完全流水，比如在MIPS实现中，浮点乘需要5个时钟周期但对该指令不流水。请分析由此引起的结构冲突对mdlidp2基准程序在MIPS上运行的性能有何影响? 为简单起见，假设浮点乘法服从均匀分布。</p><blockquote><p>mdljdp2中浮点乘法出现的频率约为14%<br><strong>最坏情况</strong>：每个浮点成都要和其他操作重叠执行，都需要五个周期，此时的CPI为1.56<br><strong>最好情况</strong>：可以完全重叠执行，仅需要一个周期，此时没有性能损失</p></blockquote><h2 id="流水线的数据冲突"><a href="#流水线的数据冲突" class="headerlink" title="流水线的数据冲突"></a>流水线的数据冲突</h2><p>数据冲突简介</p><p>产生原因：当指令在流水线中重叠执行的时候，流水线有可能改变指令读&#x2F;写操作数的顺序，使之不同于它们在非流水实现的时候的顺序，这将导致数据冲突。</p><p><strong>消除方法</strong>：<em>向流水线中插入暂停周期</em></p><h3 id="通过定向技术减少数据冲突带来的暂停"><a href="#通过定向技术减少数据冲突带来的暂停" class="headerlink" title="通过定向技术减少数据冲突带来的暂停"></a>通过<em>定向技术</em>减少数据冲突带来的暂停</h3><p>定向（Forwarding），也称为旁路（Bypassing），是指在计算机指令流水线中，将运算结果从前一条指令的执行阶段直接送往下一条指令的执行阶段，而不需要等待写回阶段的结果。这样可以节省一部分时间，提高计算机的运算效率。定向可以理解为”抄近道”，不必等待写回阶段的结果即可将数据直接送往下一指令的输入端。</p><p>工作过程</p><p>主要思路：将计算结果从其产生的地方直接送到真正需要它的地方，就可以避免暂停。</p><ul><li>寄存器文件中的ALU运算结果总是回送到ALU的输入寄存器</li><li>从定向通路得到输入数据的ALU操作不必从源寄存器中读取操作数</li></ul><h3 id="通过定向技术减少数据冲突带来的暂停-1"><a href="#通过定向技术减少数据冲突带来的暂停-1" class="headerlink" title="通过定向技术减少数据冲突带来的暂停"></a>通过定向技术减少数据冲突带来的暂停</h3><p><strong>进一步推广</strong>：一个结果不经可以从某一个功能单元的输出定向到其自身的输入，而且还可以定向到其它功能单元的输入。</p><p>在MIPS中，任何流水寄存器到任何功能单元的输入都可能需要定向路径，将形成复杂的旁路网络。</p><p>两条指令访问同一个存储单元，也可能引起数据冲突，例如访问数据Cache失效的时候</p><p><strong>只讨论寄存器数据冲突！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 流水线技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-第十一讲 指令集并行</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AE%B2%20%E6%8C%87%E4%BB%A4%E9%9B%86%E5%B9%B6%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<h1 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h1><p><strong>流水线控制冲突</strong></p><p>分支指令的行为特点</p><p>减少流水线分支损失的方法（冻结或排空、预测分支转移失败、预测分支转移成功、分支延迟槽）</p><p><strong>流水线的实例</strong> MIPS R4000</p><p>整形流水线</p><p>浮点流水线</p><p>流水线性能分析</p><p>向量处理机 Cray-I</p><p>性能指标、基本结构</p><p>链接技术</p><h1 id="指令集并行"><a href="#指令集并行" class="headerlink" title="指令集并行"></a>指令集并行</h1><ol><li>指令集并行的概念</li><li>指令的动态调度</li><li>控制相关的动态解决技术</li><li>多指令流水技术</li></ol><p>基于预测的乱序执行</p><h2 id="指令集并行的概念"><a href="#指令集并行的概念" class="headerlink" title="指令集并行的概念"></a>指令集并行的概念</h2><p>循环展开调度的基本方法</p><p><strong>相关性</strong></p><p>指令之间不存在相关的时候，它们在流水线中式可以重叠起来执行的。这种指令序列中存在的潜在并行性称为指令集并行</p><p><strong>怎么知道指令之间需要并行？软硬件如何支持指令级并行，怎么研究这些问题？</strong></p><p>硬件技术或者软件技术都可以提高指令级并行性</p><h2 id="性能评价"><a href="#性能评价" class="headerlink" title="性能评价"></a>性能评价</h2><p>流水线处理器的实际CPI</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231009101405.png"                      alt="image.png" style="zoom:50%;"                 ><p>软件和硬件的支持</p><h2 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h2><p><strong>基本（程序）块</strong>：一段除了入口和出口之外的不包含其他分支的线性代码段</p><ul><li>程序平均每 6 ~ 7条指令就会有一个分支</li><li>必须在多个基本块之间开发指令级的并行性</li></ul><blockquote><p><em>所以最重要的就是循环</em></p></blockquote><p><strong>循环级并行</strong>：开发循环体的不同迭代之间存在的并行性</p><p>开发循环级并行的基本技术方法：</p><ol><li>指令调度</li><li>循环展开</li><li>换名</li></ol><h2 id="循环展开调度的基本方法"><a href="#循环展开调度的基本方法" class="headerlink" title="循环展开调度的基本方法"></a>循环展开调度的基本方法</h2><p><code>循环展开</code>指的是展开循环体若干次，将<strong>循环级并行</strong>转换为 <strong>指令级并行</strong>的技术</p><p>这个过程：编译器静态完成 &amp;&amp; 硬件动态完成</p><p><strong>分支指令</strong> $\iff$ <strong>条件分支指令</strong></p><p>编译器在完成这种指令调度的时候，受限于两个特性</p><h2 id="整数流水线特性说明"><a href="#整数流水线特性说明" class="headerlink" title="整数流水线特性说明"></a>整数流水线特性说明</h2><p>载入延迟为一个节拍</p><p>由于数据的取操作的结果可以毫无停顿的通过相关通路机制传送到数据存部件，所以延迟为0.</p><p>分支指令，由整数流水线执行</p><p>分支条件检测搭调整到ID段</p><p>如果分支指令使用上一条指令的结果作为分支条件，就要延迟一个节拍</p><p>分支指令有一个节拍的延迟操</p><p>浮点运算一般为64位</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令集并行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-第九讲 流水线中的冲突</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B9%9D%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B9%9D%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<p><strong>流水线的性能</strong></p><p>吞吐率 加速比 效率</p><p>流水线性能的若干问题</p><p><strong>流水线的冲突</strong></p><p>产生的原因</p><p>冲突的分类</p><p><strong>流水线的结构冲突</strong></p><p>产生的原因</p><p>避免结构冲突的办法</p><p>有些流水线的设计允许结构冲突的存在</p><p><strong>流水线的数据冲突（暂停和定向）</strong></p><h2 id="流水线的数据冲突"><a href="#流水线的数据冲突" class="headerlink" title="流水线的数据冲突"></a>流水线的数据冲突</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925100551.png"                      alt="image.png"                ></p><p><em><strong>产生的原因</strong></em>：当指令在流水线中重叠执行时，流水线有可能改变指令读&#x2F;写操作数的顺序，使之不同于它们在非流水实现时的顺序，这将导致数据冲突。</p><p><em><strong>消除方法</strong></em>: 向流水线中插入暂停周期</p><h3 id="通过定向技术减少数据冲突带来的暂停"><a href="#通过定向技术减少数据冲突带来的暂停" class="headerlink" title="通过定向技术减少数据冲突带来的暂停"></a>通过定向技术减少数据冲突带来的暂停</h3><p>定向（forwarding）, <strong>也称为旁路</strong></p><p><strong>工作过程</strong></p><p>主要思路：将计算结果直接从产生的地方送到正需要的地方，就可以避免暂停。</p><ul><li><p>寄存器文件EX&#x2F;MEM中的ALU运算结果总是回送到ALU的输入寄存器</p></li><li><p>从定向通路得到输入数据的ALU操作不必从源寄存器里面读取操作数</p></li></ul><h4 id="进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入"><a href="#进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入" class="headerlink" title="进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入"></a>进一步推广：一个结果不仅可以从某一个功能单元输出定向到其自身的输入，而且还可以定向到功能单元的输入</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925101208.png"                      alt="image.png"                ></p><h3 id="数据冲突的分类"><a href="#数据冲突的分类" class="headerlink" title="数据冲突的分类"></a>数据冲突的分类</h3><p>两条指令 i 和 j, 都会访问同一个寄存器R，假设i先进入流水线，那么它们对R有四种不同的访问顺序：</p><p><u>先写后读冲突</u>（RAW）—— i 写 j 读</p><p>最常见的数据冲突，是程序最重要的特征之一。</p><p><u>先写后写冲突</u>（WAW）—— i 写 j 写</p><p>修改之后的DLX流水线就会产生WAW相关</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925101914.png"                      alt="image.png"                ></p><p><em><strong>这个是后面的指令在前面的指令之前就写回</strong></em></p><p><u>先读后写冲突</u>（WAR）—— i 读 j 写</p><p>注意没有读后读冲突。</p><h3 id="需要暂停的数据冲突"><a href="#需要暂停的数据冲突" class="headerlink" title="需要暂停的数据冲突"></a>需要暂停的数据冲突</h3><p>并非所有的冲突都可以通过定向技术解决</p><p>增加流水线“<strong>流水线互锁</strong>”部件，当互锁硬件发现这样的冲突之后，就<u>暂停流水线</u>，直到相关解除。</p><p>在这种情况下，暂停的时钟周期数就称为“<strong>载入延迟</strong>”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925103031.png"                      alt="image.png"                ></p><p>解决的方法：就是产生气泡，将之前出现数据冲突的方式给再隔开</p><h3 id="对数据冲突的编译调度方法"><a href="#对数据冲突的编译调度方法" class="headerlink" title="对数据冲突的编译调度方法"></a>对数据冲突的编译调度方法</h3><p>流水线中会遇到多类型的暂停</p><p>编译器可以通过重新排列代码的顺序来消除这种暂停，这就是”<strong>流水线调度</strong>“和“<strong>指令调度</strong>”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925103501.png"                      alt="image.png"                ></p><p>基于调度来执行暂停的方法，可以将不相关的指令来进行调度，可以不仅起到气泡的作用，还可以不影响正常的执行速度</p><h3 id="对MIPS流水线控制的实现"><a href="#对MIPS流水线控制的实现" class="headerlink" title="对MIPS流水线控制的实现"></a>对MIPS流水线控制的实现</h3><p><strong>指令发射</strong>：指令从流水线的译码段进入执行段的过程称为指令的发射</p><p><strong>检测数据冲突</strong>：</p><ul><li>ID段可以检测所有的数据冲突</li><li>也可以在使用一个操作数的时钟周期的开始，并确定必须的定向</li><li>流水线相关硬件可以检测到的各种冲突情况</li></ul><p>针对不同的数据相关的内容，就需要检测数据相关的问题：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925104601.png"                      alt="image.png"                ></p><h4 id="Load互锁的检测与实现"><a href="#Load互锁的检测与实现" class="headerlink" title="Load互锁的检测与实现"></a>Load互锁的检测与实现</h4><p>在ID段检测是否需要启动Load互锁，必须进行三种比较</p><p>一旦检测到冲突，控制部件必须在流水线中插入暂停周期，并使IF和ID段中的指令停止前进。</p><ul><li>讲ID&#x2F;EX中控制部分清0</li><li>保持IF&#x2F;ID的内容不变</li></ul><h4 id="对MIPS流水线控制的实现-1"><a href="#对MIPS流水线控制的实现-1" class="headerlink" title="对MIPS流水线控制的实现"></a>对MIPS流水线控制的实现</h4><p>定向逻辑的实现</p><ul><li>所有定向都是从ALU&#x2F;DM的输出到ALU、DM或者0单元的输入</li><li>形成了一个<em><strong>旁路网络</strong></em><br>✔️需要比较哪些信息？<br>✔️ALU输入端应该采用多少个输入的MUX？</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925110658.png"                      alt="image.png"                ></p><h2 id="流水线的控制冒险"><a href="#流水线的控制冒险" class="headerlink" title="流水线的控制冒险"></a>流水线的控制冒险</h2><h3 id="分支指令的实现"><a href="#分支指令的实现" class="headerlink" title="分支指令的实现"></a>分支指令的实现</h3><ul><li>一旦分支转移成功，正确的地址要在Mem段才会被写入PC。</li><li>一旦ID段检测到分支指令，就执行执行其后的指令，直到分支指令到达Mem段，确定新的PC为止</li><li>分支转移成功将导致MIPS流水线暂停3个周期</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925112814.png"                      alt="image.png"                ></p><h3 id="减少分支开销的途径"><a href="#减少分支开销的途径" class="headerlink" title="减少分支开销的途径"></a>减少分支开销的途径</h3><p>✔️ 两个基本途径：同时采用，缺一不可！</p><p>:luc_check:在流水线尽早哦按段分支转移是否成功<br>:luc_check:转移成功的时候，尽早计算出转移目标地址</p><p>经过改进，MIPS流水线可以将分支开销减少一拍</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925113236.png"                      alt="image.png"                ></p><table><thead><tr><th>流水段</th><th>分支指令操作</th></tr></thead><tbody><tr><td>IF</td><td>IF&#x2F;ID.IR $\leftarrow$ Mem[PC]; IF&#x2F;ID.NPC,PC $\leftarrow$ (if ID&#x2F;EX.Cond {ID&#x2F;EX.NPC} else {PC+4})</td></tr><tr><td>ID</td><td></td></tr><tr><td>EX</td><td></td></tr><tr><td>MEM</td><td></td></tr><tr><td>WB</td><td></td></tr></tbody></table><p>再改进，MIPS流水线可以将分支开销再减少一拍</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925113253.png"                      alt="image.png"                ></p><p><em><strong>减少分支开销的途径</strong></em></p><h4 id="程序中分支指令的行为特点"><a href="#程序中分支指令的行为特点" class="headerlink" title="程序中分支指令的行为特点"></a>程序中分支指令的行为特点</h4><p>各种能改变PC值的指令的执行额度</p><p>条件分支：</p><ul><li>整数程序: 14-15%</li><li>浮点程序: 3-12%</li></ul><p>其中，向前分支和向后分支的比：3：1</p><p>条件分支转移成功的概率</p><ul><li>向前转移成功率：60%；向后转移成功率：85%</li></ul><h4 id="减少流水线分支损失的方法"><a href="#减少流水线分支损失的方法" class="headerlink" title="减少流水线分支损失的方法"></a>减少流水线分支损失的方法</h4><ol><li><p><strong>冻结或者排空流水线</strong></p><p> 思路：在流水线中停住或者删除分支之后的指令，直到知道转移目标地址</p><p> 优点：简单</p></li><li><p><strong>预测分支转移失败</strong></p><p> 思路：流水线继续照常流动，如果分支转移成功，就将分支指令后的指令转换为空操作，并从分支目标处开始取指令执行；否则照常执行</p></li><li><p><strong>预测分支转移成功</strong></p><p> 思路：始终假设分支成功，直接从分支目标处取指令执行，对MIPS没有任何好处</p></li><li><p><strong>延迟分支</strong></p><p> ⭐思路：分支开销为n的分支指令后面紧跟有n个延迟槽，流水线遇到分支指令的时候，按照正常方式来处理，顺带执行延迟槽中的指令，从而减少分支开销。</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927082642.png"                      alt="image.png"                ></p><p>所以什么样的指令能够放入分支延迟槽</p><p>三种调度方法：</p><ul><li>从前调度</li><li>从目标处调度</li><li>从失败的位置调度</li></ul><h4 id="各种分支处理方法的性能"><a href="#各种分支处理方法的性能" class="headerlink" title="各种分支处理方法的性能"></a>各种分支处理方法的性能</h4><ol><li>假设理想CPI &#x3D; 1，则加速比</li></ol><p>$$<br>S &#x3D; D &#x2F; (1+C) &#x3D; D &#x2F; (1+f \times p_{分支})<br>$$<br>这里，D为流水线的深度，$p_{分支}$为分支开销，C为分支引起的流水线暂停时钟周期数</p><h2 id="实例分析-：-MIPS-R4000"><a href="#实例分析-：-MIPS-R4000" class="headerlink" title="实例分析 ： MIPS R4000"></a>实例分析 ： MIPS R4000</h2><p>MIPS R4000的整型流水线<br>MIPS R4000的浮点流水线<br>MIPS R4000流水线性能分析</p><p>整型流水线</p><p>指令集：64位MIPS-3指令集</p><p>MIPS R4000流水线结构</p><ul><li>超流水结构</li><li>访存操作流水化</li></ul><p>流水线各段的功能</p><p>指令序列在流水线中的重叠执行过程。</p><p><strong>定向+插入暂停周期</strong></p><p>载入延迟为两个时钟周期</p><p>指令序列在流水线中的<strong>执行时空图</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927090904.png"                      alt="image.png"                ></p><p>R4000流水线的定向路径远多于MIPS流水线</p><p>ALU输入端的定向源有4个：EX&#x2F;DF,DF&#x2F;DS,DS&#x2F;TC,TC&#x2F;WB</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 流水线技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-第七讲 流水线技术</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B8%83%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E7%AC%AC%E4%B8%83%E8%AE%B2%20%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h1 id="流水线概述"><a href="#流水线概述" class="headerlink" title="流水线概述"></a>流水线概述</h1><h2 id="流水线的基本概念"><a href="#流水线的基本概念" class="headerlink" title="流水线的基本概念"></a>流水线的基本概念</h2><h3 id="产品生产流水线"><a href="#产品生产流水线" class="headerlink" title="产品生产流水线"></a>产品生产流水线</h3><p>一个问题</p><p>假设某个产品需要四道工序；1工人，1机器，8小时可以生产120件</p><p><strong>要将该产品8小时提高到480件</strong>，怎么实现目标</p><h4 id="两种解决方法"><a href="#两种解决方法" class="headerlink" title="两种解决方法"></a>两种解决方法</h4><p><strong>方案一</strong>：增加3名工人、三套设备</p><p><strong>方案二</strong>：产品生产采用流水线的方式，分为4道工序；增加3名工人，每人一道工序</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918101255.png"                      alt="Pasted image 20230918101255"                ></p><h4 id="两种方案的工作过程对比"><a href="#两种方案的工作过程对比" class="headerlink" title="两种方案的工作过程对比"></a>两种方案的工作过程对比</h4><p>两种方案中每一件生产时间不变</p><p><strong>但是在稳定情况下</strong>：</p><p>方案一：需要三套设备</p><p>方案二：不需要增加任何设备</p><p>使得每件产品的产出时间从表面上来看是从原来的4分钟缩减到1分钟</p><h3 id="计算机中的流水线"><a href="#计算机中的流水线" class="headerlink" title="计算机中的流水线"></a>计算机中的流水线</h3><h4 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918101705.png"                      alt="Pasted image 20230918101705"                ></p><h4 id="功能部件流水线"><a href="#功能部件流水线" class="headerlink" title="功能部件流水线"></a>功能部件流水线</h4><h3 id="流水技术的定义"><a href="#流水技术的定义" class="headerlink" title="流水技术的定义"></a>流水技术的定义</h3><p>将一重复的时序过程分解为若干子过程，每个子过程都可有效地在其专用功能段上与其它子过程同时执行这种技术称为流水技术。</p><h3 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h3><p>从时间和空间两个方面来描述流水线的工作流程，横坐标表示时间，纵坐标表示各个流水段。</p><p><strong>流水线需要改造的话需要考虑的原则</strong>：</p><p><strong>1. Repetition of identical operations</strong><br>Repetition of identical operations refers to the practice of carrying out the same set of tasks multiple times. This can be done intentionally to achieve a specific goal or unintentionally due to errors or inefficiencies in a process. Repetition of identical operations can be seen in various domains, including manufacturing, software development, data entry, and administrative tasks.</p><p><strong>2. Repetition of independent operations</strong><br>Repetition of independent operations refers to the process of repeatedly carrying out the same operations on different elements or data sets. </p><p>For example, if you have a list of numbers and you want to multiply each number by 2, you can use repetition of independent operations to apply the same multiplication operation to each number in the list. This can be achieved through looping or iterating over the data set and performing the operation on each element.</p><p>By utilizing repetition of independent operations, you can save time and effort by avoiding the need to manually perform the operation on each element individually. Instead, you can automate the process and apply the operation to all the elements in a more efficient manner.</p><h4 id="流水线技术原理"><a href="#流水线技术原理" class="headerlink" title="流水线技术原理"></a>流水线技术原理</h4><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918102435.png"                      alt="Pasted image 20230918102435"                ></p><p>左边的三角表示的是<strong>载入时间</strong></p><p>右边的三角叫做<strong>排空时间</strong></p><h3 id="流水线的特点"><a href="#流水线的特点" class="headerlink" title="流水线的特点"></a>流水线的特点</h3><ul><li><p>流水过程由多个相关的子过程组成，这些子过程称为流水线的“级” 和 “段” 。 </p></li><li><p>每个子过程由专用的功能段实现</p></li><li><p>各个功能段的时间应该基本相等，通常为一个时钟周期</p></li><li><p>流水线需要一定的 <strong>通过时间</strong>才能稳定</p></li><li><p>流水技术适合于<strong>大量重复的时序过程</strong></p></li></ul><h2 id="流水线分类"><a href="#流水线分类" class="headerlink" title="流水线分类"></a>流水线分类</h2><h3 id="单功能流水线和多功能流水线"><a href="#单功能流水线和多功能流水线" class="headerlink" title="单功能流水线和多功能流水线"></a>单功能流水线和多功能流水线</h3><ul><li>按照流水线所完成的功能分类</li><li><strong>单功能流水线</strong></li></ul><p>A single-function pipeline refers to a type of manufacturing or production system where each stage of the process is dedicated to performing a specific task. This means that the different stages of the pipeline are set up to carry out only one particular function or operation. Single-function pipelines are commonly used in industries such as assembly lines, where each stage focuses on a specific task to achieve efficiency and specialization.<br>Source: <a class="link"   href="https://en.wikipedia.org/wiki/Assembly_line" >Wikipedia - Assembly line <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li><strong>多功能流水线</strong><br>多功能流水线是一种在制造过程中用于完成多种任务的系统。它可以自动化地将产品从一个工作站传递到另一个工作站，实现高效的生产和制造。</li></ul><p>加工、装配或检测操作。这样，同一条流水线可以生产多种不同的产品，实现灵活的生产线调整。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918103607.png"                      alt="Pasted image 20230918103607"                ></p><h3 id="静态流水线和动态流水线"><a href="#静态流水线和动态流水线" class="headerlink" title="静态流水线和动态流水线"></a><em>静态流水线和动态流水线</em></h3><p><strong>静态流水线</strong>和<strong>动态流水线</strong>是计算机体系结构中常见的两种流水线设计方式。静态流水线是指在工作期间固定不变的流水线，而动态流水线则允许流水线结构在运行过程中进行改变。</p><p><code>静态流水线</code>的特点是流水线的各个阶段的<strong>功能和顺序是固定不变的</strong>。这种设计适用于执行时间相对稳定且操作相对简单的任务。静态流水线的优点是结构简单，并且可以通过合理安排各个阶段的操作来达到最小化时钟周期的效果。但是，静态流水线的缺点是对于执行时间不稳定的任务不太适用，并且无法处理<br>控制流转移和异常。</p><p><code>动态流水线</code>允许在运行过程中根据需要改变流水线结构。这种设计更适用于执行时间波动较大或包含复杂分支转移的任务。动态流水线的优点是可以根据任务的要求动态地修改流水线的结构，以充分利用各个阶段的处理能力。但是，动态流水线的缺点是在改变流水线结构时会带来额外的开销，并且可能导致流水线中的指令乱序执行，影响性能。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918103804.png"                      alt="Pasted image 20230918103804"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918103815.png"                      alt="Pasted image 20230918103815"                ></p><h3 id="部件级、处理机级以及处理机之间的流水线"><a href="#部件级、处理机级以及处理机之间的流水线" class="headerlink" title="部件级、处理机级以及处理机之间的流水线"></a>部件级、处理机级以及处理机之间的流水线</h3><ul><li><p>按照流水的级别划分</p></li><li><p>部件级流水线 <strong>运算操作流水线</strong></p></li><li><p>处理机级流水线 <strong>指令流水线</strong></p></li><li><p>处理机间流水线 <strong>宏流水线</strong></p></li></ul><h3 id="标量流水处理机和向量流水处理机"><a href="#标量流水处理机和向量流水处理机" class="headerlink" title="标量流水处理机和向量流水处理机"></a>标量流水处理机和向量流水处理机</h3><ul><li><p>按照数据来表示分类</p></li><li><p>标量流水处理机</p></li><li><p>向量流水处理机</p></li></ul><blockquote><p>According to my knowledge, there are several ways to classify processors based on their data representation and processing methods. Two common classifications are scalar pipeline processing and vector pipeline processing.</p></blockquote><blockquote><p>Scalar pipeline processing, also known as scalar processing, operates on one data element at a time. It follows a single instruction stream and performs sequential execution of instructions.</p></blockquote><blockquote><p>Vector pipeline processing, on the other hand, operates on multiple data elements simultaneously. It uses vector instructions that can perform the same operation on multiple data elements in parallel.</p></blockquote><blockquote><p>For more detailed information and examples of these classifications, you can refer to the following source: [source URL]</p></blockquote><h3 id="线性流水线和非线性流水线"><a href="#线性流水线和非线性流水线" class="headerlink" title="线性流水线和非线性流水线"></a>线性流水线和非线性流水线</h3><ul><li><p>按照是否有回馈回路来进行分类</p></li><li><p><strong>线性流水线</strong>是指流水线的隔断串行连接，没有反馈回路</p></li><li><p><strong>非线性流水线</strong>指的是流水线中除了有串行连接的通路之外，还有反馈回路</p></li></ul><p><strong>存在流水线调度问题</strong></p><p>确定什么时候想流水线引进新的输入，从而使得新输入的数据和先前操作的反馈数据在流水线中不产生冲突，这就是 <strong>流水线调度的问题</strong></p><h1 id="MIPS基本流水线"><a href="#MIPS基本流水线" class="headerlink" title="MIPS基本流水线"></a>MIPS基本流水线</h1><h2 id="基本MIPS流水线"><a href="#基本MIPS流水线" class="headerlink" title="基本MIPS流水线"></a>基本MIPS流水线</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918104742.png"                      alt="Pasted image 20230918104742"                ></p><p>要好好讲一讲上面这个图 ⬆</p><ol><li>I类 SW&#x2F;LW ADDI&#x2F;SUBI</li><li>R类 AND&#x2F;OR</li><li>J类 J name</li></ol><p>这几类指令在上图中都有什么操作？</p><hr><p><strong>取指</strong>：IR $\leftarrow$ IMem[PC] NPC $\leftarrow$ PC+4<br><strong>译码</strong>：A $\leftarrow$ $Regs[IR_{6…10}]$ B $\leftarrow Regs[IR_{11…15}]$ Imm $\leftarrow$ $Regs[(IR_{16})^{16}# #IR_{17…32}]$<br><strong>执行</strong>：SW&#x2F;LW ALUoutput $\leftarrow$ A+Imm<br><strong>ALU</strong>：<br>ADDI&#x2F;SUBI ALUoutput $\leftarrow$ A op Imm<br>ADD&#x2F;OR ALUoutput $\leftarrow$ A Func B<br>BEQZ ALUoutput $\leftarrow$ NPC + Imm, Cond $\leftarrow$ A op 0<br><strong>访存</strong>：<br>SW DMEM[ALUoutput] $\leftarrow$ B<br>LW LDM $\leftarrow$ DMEM[ALUoutput]<br>BEQZ if(Cond) PC $\leftarrow$ ALUoutput else PC $\leftarrow$ NPC<br><strong>写回</strong>：<br>ADDI&#x2F;SUBI  $Regs[IR_{11…15}]$ $\leftarrow$ ALUoutput<br>AWB&#x2F;OR $Regs[IR_{16…20}]$ $\leftarrow$ ALUoutput<br>LW $Regs[IR_{11…15}]$ $\leftarrow$ LMD</p><hr><h3 id="MIPS32的一种简单实现"><a href="#MIPS32的一种简单实现" class="headerlink" title="MIPS32的一种简单实现"></a>MIPS32的一种简单实现</h3><p>性能分析</p><p>在数据通路商，分支指令需要4个时钟周期</p><p>其他指令需要5个时钟周期</p><p>假设分支指令占总指令数量的12%，问CPI &#x3D; ？</p><p>$CPI &#x3D; 4 \times 12% + 5 \times(1-12%)&#x3D;4.88$</p><p><strong>结论：就性能和硬件开销而言，上述实现不是一种优化实现</strong>！</p><h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a>改进方法</h4><p>在Mem周期完成ALU指令</p><blockquote><p>假设ALU指令数占指令总数的44%，则在时钟周期不变的同时，CPI可以降低至4.44</p></blockquote><p>如果要进一步降低CPI，可能需要延长时钟周期时间，使得每个时钟周期能够完成更多的工作</p><p>采用单周期实现，可以将CPI降低为1，但是时钟周期时间却会增加为原来的5倍</p><p><strong>一般不采用这种方法，为什么？</strong></p><h3 id="一种简单的MIPS流水线"><a href="#一种简单的MIPS流水线" class="headerlink" title="一种简单的MIPS流水线"></a>一种简单的MIPS流水线</h3><p>数据通路流水画<br>数据通路中的每一个周期就成为流水线的一段<br>每个时钟周期启动一条指令<br><strong>——得到了一条简单的MIPS流水线</strong><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918111702.png"                      alt="Pasted image 20230918111702"                ></p><h3 id="实现流水技术应该解决的一些问题"><a href="#实现流水技术应该解决的一些问题" class="headerlink" title="实现流水技术应该解决的一些问题"></a>实现流水技术应该解决的一些问题</h3><h4 id="应该保证流水线各个段不会在同一周期内使用相同的通路资源"><a href="#应该保证流水线各个段不会在同一周期内使用相同的通路资源" class="headerlink" title="应该保证流水线各个段不会在同一周期内使用相同的通路资源"></a>应该保证流水线各个段不会在同一周期内使用相同的通路资源</h4><ul><li>例如，不能要求一个ALU既做有效地址结算，又做减法操作</li><li>IF和Mem两个阶段都要访问存储器，怎样避免访存冲突</li><li>ID和WB两个阶段都要访问存储器，<strong>是否存在冲突</strong>？<strong>怎样避免</strong>？</li></ul><h4 id="PC计算问题"><a href="#PC计算问题" class="headerlink" title="PC计算问题"></a>PC计算问题</h4><p>为了能够在每个时钟周期启动一条新的指令，流水线必须在IF段获得下一条指令的地址，并保存在PC中</p><p>但是，分支指令会改变PC的值，而且只有在Mem结束时，这个新的值才会被写入PC，出现矛盾</p><p>对于顺序执行，<strong>可以修改数据通路</strong>在IF段完成PC计算，但是分支指令怎么处理？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918112327.png"                      alt="Pasted image 20230918112327"                ></p><h4 id="合理划分流水段，每段内的操作都必须在一个时钟周期内完成"><a href="#合理划分流水段，每段内的操作都必须在一个时钟周期内完成" class="headerlink" title="合理划分流水段，每段内的操作都必须在一个时钟周期内完成"></a>合理划分流水段，每段内的操作都必须在一个时钟周期内完成</h4><h4 id="流水线寄存器设计"><a href="#流水线寄存器设计" class="headerlink" title="流水线寄存器设计"></a>流水线寄存器设计</h4><ul><li>设置<strong>流水线寄存器文件</strong></li><li>流水线寄存器文件的命名</li><li>段A和段B之间的流水线寄存器称为A&#x2F;B</li><li>[[#流水线寄存器的作用]]</li><li>[[#流水线寄存器文件的构成]]</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918112749.png"                      alt="Pasted image 20230918112749"                ></p><h3 id="MIPS流水线的操作"><a href="#MIPS流水线的操作" class="headerlink" title="MIPS流水线的操作"></a>MIPS流水线的操作</h3><p>在任意时刻，流水中的指令旨在流水线中的某一段内执行操作。</p><p>因此，只要知道了每一个流水段在各个至零下进行何种操作，就知道了整个流水线的操作</p><ul><li>[[#MIPS流水线每个流水段的操作]]</li></ul><h3 id="MIPS流水线中多路选择器的控制"><a href="#MIPS流水线中多路选择器的控制" class="headerlink" title="MIPS流水线中多路选择器的控制"></a>MIPS流水线中多路选择器的控制</h3><p>主要是确定如何 <strong>控制那四个多路选择器</strong></p><p>ALU输入端的两个MUX由ID&#x2F;EX.IR所指出的指令类型限制</p><p>IF段的MUX由EX&#x2F;MEM。Cond域的值控制<br>WB段的MUX由当前指令类型Load&#x2F;ALU控制</p><h2 id="流水线性能分析"><a href="#流水线性能分析" class="headerlink" title="流水线性能分析"></a>流水线性能分析</h2><hr><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h4 id="流水线寄存器的作用"><a href="#流水线寄存器的作用" class="headerlink" title="流水线寄存器的作用"></a>流水线寄存器的作用</h4><p>[[#流水线寄存器设计]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918113024.png"                      alt="Pasted image 20230918113024"                ></p><h4 id="流水线寄存器文件的构成"><a href="#流水线寄存器文件的构成" class="headerlink" title="流水线寄存器文件的构成"></a>流水线寄存器文件的构成</h4><p>[[#流水线寄存器设计]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918113156.png"                      alt="Pasted image 20230918113156"                ></p><h4 id="MIPS流水线每个流水段的操作"><a href="#MIPS流水线每个流水段的操作" class="headerlink" title="MIPS流水线每个流水段的操作"></a>MIPS流水线每个流水段的操作</h4><p>[[#MIPS流水线的操作]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918114008.png"                      alt="Pasted image 20230918114008"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230918113739.png"                      alt="Pasted image 20230918113739"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 流水线技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-改进Cache的性能</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%94%B9%E8%BF%9BCache%E7%9A%84%E6%80%A7%E8%83%BD/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%94%B9%E8%BF%9BCache%E7%9A%84%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><h2 id="改进Cache的性能"><a href="#改进Cache的性能" class="headerlink" title="改进Cache的性能"></a>改进Cache的性能</h2><p>从三个方面改进Cache的措施：</p><ol><li><p>降低失效率</p></li><li><p>减少失效开销</p></li><li><p>减少Cache命中时间</p></li></ol><p>一共有17种Cache优化技术</p><h3 id="降低失效率"><a href="#降低失效率" class="headerlink" title="降低失效率"></a>降低失效率</h3><p>三种失效：</p><ol><li>强制性失效</li><li>容量失效</li><li>冲突失效（碰撞失效，干扰失效）</li></ol><p>相联度越高，冲突失效就越小；<br>强制性失效不受Cache容量的影响，但是容量是小却随着容量的增加而减少；强制失效和容量失效不受相联度的影响</p><h3 id="调节块的大小"><a href="#调节块的大小" class="headerlink" title="调节块的大小"></a>调节块的大小</h3><p>在固定容量的情况下，增加块的大小会降低失效率</p><ul><li>Cache失效率和块大小的关系</li></ul><h3 id="提高相联度"><a href="#提高相联度" class="headerlink" title="提高相联度"></a>提高相联度</h3><h3 id="Victim-Cache"><a href="#Victim-Cache" class="headerlink" title="Victim Cache"></a>Victim Cache</h3><h3 id="硬件预取"><a href="#硬件预取" class="headerlink" title="硬件预取"></a>硬件预取</h3><p>4KB 直接映像Cache,块大小为16字节</p><p>1个块的指令流缓冲器：捕获15%~25%的失效</p><h3 id="编译器控制和预取"><a href="#编译器控制和预取" class="headerlink" title="编译器控制和预取"></a>编译器控制和预取</h3><p><strong>预取指令</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-模块体系</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%A8%A1%E5%9D%97%E4%BD%93%E7%B3%BB/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%A8%A1%E5%9D%97%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><ol><li><p><code>IMEM</code>模块用于指令存储器的读取，将PC地址传递给存储器，读取当前指令到<code>IRin</code>。</p></li><li><p><code>PC</code>模块用于管理程序计数器，包括在时钟上升沿时选择下一条指令的地址，以及处理复位信号。</p></li><li><p><code>ADD</code>模块用于计算下一条指令的地址，将当前PC地址传递给<code>PC</code>模块。</p></li><li><p><code>NPC</code>模块用于存储下一条指令的地址。</p></li><li><p><code>IR</code>模块用于指令寄存器的加载，将当前指令传递给<code>IRout</code>。</p></li></ol><p><strong>ID (Instruction Decode) 模块:</strong></p><ol><li><p><code>Regfile</code>模块用于管理寄存器堆的读和写操作，根据指令选择寄存器读取和写入。</p></li><li><p><code>CU</code>模块用于控制单元，解析指令并生成相应的控制信号，例如ALU操作码、写寄存器使能等。</p></li><li><p><code>A</code>和<code>B</code>模块用于选择和加载寄存器A和B的数据。</p></li><li><p><code>Extender</code>模块用于符号扩展立即数。</p></li><li><p><code>Imm</code>模块用于加载立即数。</p></li></ol><p><strong>EX (Execution) 模块:</strong></p><ol><li><p><code>A_MUX</code>和<code>B_MUX</code>模块用于选择ALU的输入数据，可以选择寄存器数据、NPC、基址或立即数。</p></li><li><p><code>ALU</code>模块执行ALU操作，并生成结果和零标志。</p></li></ol><p><strong>MEM (Memory) 模块:</strong></p><ol><li><p><code>ALU_out</code>模块用于加载ALU的结果。</p></li><li><p><code>PC_MUX</code>模块用于选择下一个PC地址，可以选择NPC、ALU结果或分支指令的目标地址。</p></li><li><p><code>WB_Reg_MUX</code>模块用于选择写回数据，可以选择ALU结果、内存读取结果或寄存器A的数据。</p></li><li><p><code>WB_Reg_Addr_MUX</code>模块用于选择写回寄存器的地址。</p></li><li><p><code>DMEM</code>模块用于数据存储器的读写操作。</p></li><li><p><code>LDM</code>模块用于加载内存数据。</p></li></ol><p><strong>其他：</strong></p><ul><li><code>debug_wb_pc</code>、<code>debug_wb_rf_wen</code>、<code>debug_wb_rf_addr</code>、<code>debug_wb_rf_wdata</code>用于调试目的，输出当前执行指令的信息。</li></ul><p>这个CPU的基本架构是一个五级流水线，包括IF、ID、EX、MEM和WB（写回）阶段。每个阶段由不同的模块负责执行特定的任务，并在时钟上升沿进行数据传递。各个模块之间通过信号进行通信，根据指令的不同，选择不同的数据路径和操作。</p><p>以下是在前面的叙述中添加了原始Verilog代码的版本：</p><p><strong>IF (Instruction Fetch) 模块:</strong></p><ol><li><code>IMEM</code>模块用于指令存储器的读取，将PC地址传递给存储器，读取当前指令到<code>IRin</code>。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMEM U_IMEM (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="variable">.imem_addr</span>(PCout[<span class="number">7</span>:<span class="number">0</span>]),   <span class="comment">// 选定存储地址</span></span><br><span class="line">    <span class="variable">.imem_rdata</span>(IRin)         <span class="comment">// 读出的指令</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="2"><li><code>PC</code>模块用于管理程序计数器，包括在时钟上升沿时选择下一条指令的地址，以及处理复位信号。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PC U_PC (</span><br><span class="line">    <span class="variable">.Reset</span>(!resetn),</span><br><span class="line">    <span class="variable">.Clk</span>(clk),</span><br><span class="line">    <span class="variable">.PCwen</span>(<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.NPC</span>(PC_chosen),          <span class="comment">// 是由选择器给出的</span></span><br><span class="line">    <span class="variable">.PC</span>(PCout)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>ADD</code>模块用于计算下一条指令的地址，将当前PC地址传递给<code>PC</code>模块。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD U_ADD (</span><br><span class="line">    <span class="variable">.PC</span>(PCout),</span><br><span class="line">    <span class="variable">.NextPC</span>(NewPC)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="4"><li><code>NPC</code>模块用于存储下一条指令的地址。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NPC U_NPC (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                 <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),             <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.NPCin</span>(NewPC),</span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),               <span class="comment">// 载入使能</span></span><br><span class="line">    <span class="variable">.NPCout</span>(NPC)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="5"><li><code>IR</code>模块用于指令寄存器的加载，将当前指令传递给<code>IRout</code>。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IR U_IR (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                 <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),             <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.IRin</span>(IRin),</span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),               <span class="comment">// 载入使能</span></span><br><span class="line">    <span class="variable">.IRout</span>(IRout)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p><strong>ID (Instruction Decode) 模块:</strong></p><ol><li><code>Regfile</code>模块用于管理寄存器堆的读和写操作，根据指令选择寄存器读取和写入。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Regfile U_regfile (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="variable">.raddr1</span>(IRout[<span class="number">25</span>:<span class="number">21</span>]),    <span class="comment">// 寄存器堆读地址1</span></span><br><span class="line">    <span class="variable">.rdata1</span>(reg_a_out),       <span class="comment">// 返回数据1</span></span><br><span class="line">    <span class="variable">.raddr2</span>(IRout[<span class="number">20</span>:<span class="number">16</span>]),    <span class="comment">// 寄存器堆读地址2</span></span><br><span class="line">    <span class="variable">.rdata2</span>(reg_b_out),       <span class="comment">// 返回数据2</span></span><br><span class="line">    <span class="variable">.we</span>(reg_w &amp;&amp; IRout),      <span class="comment">// 写使能</span></span><br><span class="line">    <span class="variable">.waddr</span>(reg_addr_choose[<span class="number">4</span>:<span class="number">0</span>]), <span class="comment">// 写地址</span></span><br><span class="line">    <span class="variable">.wdata</span>(reg_mux_out)       <span class="comment">// 写数据</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="2"><li><code>CU</code>模块用于控制单元，解析指令并生成相应的控制信号，例如ALU操作码、写寄存器使能等。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CU U_CU (</span><br><span class="line">    <span class="variable">.Instruct</span>(IRout),          <span class="comment">// 输入指令</span></span><br><span class="line">    <span class="variable">.Zero</span>(zero),               <span class="comment">// 零标志位</span></span><br><span class="line">    <span class="variable">.ram_w</span>(ram_w),             <span class="comment">// 存储器写使能</span></span><br><span class="line">    <span class="variable">.reg_w</span>(reg_w),             <span class="comment">// 寄存器写使能</span></span><br><span class="line">    <span class="variable">.Card</span>(Card),               <span class="comment">// ALU 功能码</span></span><br><span class="line">    <span class="variable">.PC_s</span>(PC_s),               <span class="comment">// PC 数据来源选择</span></span><br><span class="line">    <span class="variable">.regfile_s</span>(regfile_s),     <span class="comment">// 寄存器文件数据来源选择</span></span><br><span class="line">    <span class="variable">.regfile_addr_s</span>(regfile_addr_s), <span class="comment">// 寄存器文件地址来源选择</span></span><br><span class="line">    <span class="variable">.ALU_As</span>(A_s),              <span class="comment">// ALU 输入 A 来源选择</span></span><br><span class="line">    <span class="variable">.ALU_Bs</span>(B_s)               <span class="comment">// ALU 输入 B 来源选择</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>A</code>和<code>B</code>模块用于选择和加载寄存器A和B的数据。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A U_A (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(reg_a_out),            <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(A_out)                <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">B U_B (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(reg_b_out),            <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(B_out)                <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="4"><li><code>Extender</code>模块用于符号扩展立即数。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Extender U_Extender (</span><br><span class="line">    <span class="variable">.Immin</span>(IRout[<span class="number">15</span>:<span class="number">0</span>]),</span><br><span class="line">    <span class="variable">.Immout</span>(Imm)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="5"><li><code>Imm</code>模块用于加载立即数。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Imm U_Imm (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(Imm),                  <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(Imm_out)              <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>这些Verilog模块构成了IF和ID阶段的核心逻辑，负责指令的获取、寄存器堆的读写、控制信号的生成等任务。</p><p><strong>EX (Execution) 模块:</strong></p><ol><li><code>A_MUX</code>和<code>B_MUX</code>模块用于选择ALU的输入数据，可以选择寄存器数据、NPC、基址或立即数。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">A_MUX A_MUX (</span><br><span class="line">    <span class="variable">.A_data1</span>(A_out),                  <span class="comment">// A寄存器的输出</span></span><br><span class="line">    <span class="variable">.A_data2</span>(NPC),                    <span class="comment">// 根据现在的PC产生的NPC值</span></span><br><span class="line">    <span class="variable">.A_data3</span>(A_out),                  <span class="comment">// 代表base的值</span></span><br><span class="line">    <span class="variable">.A_data4</span>(&#123;<span class="number">27&#x27;b0</span>,IRout[<span class="number">10</span>:<span class="number">6</span>]&#125;),    <span class="comment">// 代表左移的偏置量sa</span></span><br><span class="line">    <span class="variable">.A_select</span>(A_s),</span><br><span class="line">    <span class="variable">.A_data_chosen</span>(ALU_A_in)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">B_MUX B_MUX (</span><br><span class="line">    <span class="variable">.B_data1</span>(B_out),              <span class="comment">// B寄存器的输出</span></span><br><span class="line">    <span class="variable">.B_data2</span>(Imm_out),            <span class="comment">// 立即数扩展符号位之后的输出</span></span><br><span class="line">    <span class="variable">.B_data3</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.B_data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.B_select</span>(B_s),</span><br><span class="line">    <span class="variable">.B_data_chosen</span>(ALU_B_in)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ALU U_ALU (</span><br><span class="line">    <span class="variable">.A</span>(ALU_A_in),</span><br><span class="line">    <span class="variable">.B</span>(ALU_B_in),</span><br><span class="line">    <span class="variable">.Cin</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.Card</span>(Card),</span><br><span class="line">    <span class="variable">.F</span>(alu_out),</span><br><span class="line">    <span class="variable">.Cout</span>(cout),</span><br><span class="line">    <span class="variable">.Zero</span>(zero)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>这些模块构成了EX阶段的核心逻辑，负责执行ALU操作、选择ALU输入数据等任务。</p><p><strong>MEM (Memory) 模块:</strong></p><ol><li><code>ALU_out</code>模块用于加载ALU的结果。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ALU_out U_ALU_output (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(alu_out),              <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(result)               <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="2"><li><code>PC_MUX</code>模块用于选择下一个PC地址，可以选择NPC、ALU结果或分支指令的目标地址。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PC_MUX PC_MUX (</span><br><span class="line">    <span class="variable">.data1</span>(NPC),</span><br><span class="line">    <span class="variable">.data2</span>(result),</span><br><span class="line">    <span class="variable">.data3</span>(&#123;NPC[<span class="number">31</span>:<span class="number">28</span>],IRout[<span class="number">25</span>:<span class="number">0</span>],<span class="number">2&#x27;b0</span>&#125;),</span><br><span class="line">    <span class="variable">.data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.select</span>(PC_s),</span><br><span class="line">    <span class="variable">.data_chosen</span>(PC_chosen)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="3"><li><code>WB_Reg_MUX</code>模块用于选择写回数据，可以选择ALU结果、内存读取结果或寄存器A的数据。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WB_DATA_MUX WB_Reg_MUX (</span><br><span class="line">    <span class="variable">.data1</span>(result),</span><br><span class="line">    <span class="variable">.data2</span>(ldm_out),</span><br><span class="line">    <span class="variable">.data3</span>(A_out),</span><br><span class="line">    <span class="variable">.data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.select</span>(regfile_s),</span><br><span class="line">    <span class="variable">.data_chosen</span>(reg_mux_out)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="4"><li><code>WB_Reg_Addr_MUX</code>模块用于选择写回寄存器的地址。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WB_ADDR_MUX WB_Reg_Addr_MUX (</span><br><span class="line">    <span class="variable">.data1</span>(&#123;<span class="number">27&#x27;b0</span>,IRout[<span class="number">15</span>:<span class="number">11</span>]&#125;),</span><br><span class="line">    <span class="variable">.data2</span>(&#123;<span class="number">27&#x27;b0</span>,IRout[<span class="number">20</span>:<span class="number">16</span>]&#125;),</span><br><span class="line">    <span class="variable">.data3</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.data4</span>(<span class="number">32&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.select</span>(regfile_addr_s),</span><br><span class="line">    <span class="variable">.data_chosen</span>(reg_addr_choose)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="5"><li><code>DMEM</code>模块用于数据存储器的读写操作。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DMEM U_DMEM (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟信号</span></span><br><span class="line">    <span class="variable">.dmem_addr</span>(result[<span class="number">7</span>:<span class="number">0</span>]),    <span class="comment">// 选定存储地址</span></span><br><span class="line">    <span class="variable">.dmem_wdata</span>(reg_b_out),     <span class="comment">// 输入的数据</span></span><br><span class="line">    <span class="variable">.dmem_wen</span>(ram_w),           <span class="comment">// 写使能</span></span><br><span class="line">    <span class="variable">.dmem_rdata</span>(ldm_in)         <span class="comment">// 读出的数据</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><ol start="6"><li><code>LDM</code>模块用于加载内存数据。</li></ol><p>verilog</p><div class="highlight-container" data-rel="Verilog"><figure class="iseeu highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LDM LDM (</span><br><span class="line">    <span class="variable">.clk</span>(clk),                  <span class="comment">// 时钟输入</span></span><br><span class="line">    <span class="variable">.rst</span>(!resetn),              <span class="comment">// 复位输入</span></span><br><span class="line">    <span class="variable">.din</span>(ldm_in),               <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="variable">.load</span>(<span class="number">1&#x27;b1</span>),                <span class="comment">// 载入控制输入</span></span><br><span class="line">    <span class="variable">.dout</span>(ldm_out)              <span class="comment">// 数据输出</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div><p>这些模块构成了MEM阶段的核心逻辑，负责执行内存操作、选择写回数据和地址等任务。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> CPU设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-操作类型和大小</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%A7%E5%B0%8F/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%A7%E5%B0%8F/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[../../计算机体系结构课程总括|计算机体系结构课程总括]]<h1 id="操作类型和大小"><a href="#操作类型和大小" class="headerlink" title="操作类型和大小"></a>操作类型和大小</h1><p>确定操作数表示实际上也是软硬件取舍折中的问题</p><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><p>整数：二进制的补码表示；大小可以是字节，半字和单字</p><p>十进制：<strong>压缩十进制</strong>，<strong>二进制编码十进制</strong>，压缩十进制数据表示用四位编码数字0~9，然后将两个十进制数字压缩在一个字节中 </p><p>存储。</p><p>操作数类型的表示主要有如下的两种方法：</p><ul><li>操作数的类型可以以操作码的编码指定，这也是最常见的一种方法</li><li>数据可以附上由<code>硬件解释的标记（tag）</code>,由这些标记指定操作数的类型，从而选择适当的运算。然而有标记数据的机器非常少见</li></ul><p>操作数的表示是所有类型的子集，是一种折衷。</p><h2 id="操作数的大小"><a href="#操作数的大小" class="headerlink" title="操作数的大小"></a>操作数的大小</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911111339574-1694402576165-4.png"                      alt="image-20230911111339574" style="zoom:67%;"                 ><h2 id="指令系统设计的基本原则"><a href="#指令系统设计的基本原则" class="headerlink" title="指令系统设计的基本原则"></a>指令系统设计的基本原则</h2><h3 id="指令系统的设计"><a href="#指令系统的设计" class="headerlink" title="指令系统的设计"></a>指令系统的设计</h3><ul><li>首先考虑应该事先的基本功能，确定哪些功能应该用硬件实现，哪些功能用软件实现</li><li><strong>包括</strong><ul><li>指令的功能设计</li><li>指令格式的设计</li></ul></li></ul><h3 id="指令系统设计的基本原则-1"><a href="#指令系统设计的基本原则-1" class="headerlink" title="指令系统设计的基本原则"></a>指令系统设计的基本原则</h3><p>指令系统的设计</p><p>在确定这些<code>基础功能</code>之后要考虑<code>三个因素</code>：速度、成本、灵活性</p><p>硬件实现的特点：速度快成本高灵活性差</p><p>软件实现的特点：速度慢价格便宜灵活性高</p><h3 id="完整性"><a href="#完整性" class="headerlink" title="完整性"></a>完整性</h3><p>在一个有限可用的存储空间内，对于任何可解的问题，在编制计算程序时，指令系统所提供的指令足够使用。完整性要求指令系统功能全、使用方便。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911112139867-1694402569721-1.png"                      alt="image-20230911112139867" style="zoom:67%;"                 ><h3 id="规整性"><a href="#规整性" class="headerlink" title="规整性"></a>规整性</h3><p>规整性主要包括对称性和均匀性。</p><ul><li><p>对称性：对称性是指所有与指令系统相关的<code>存储单元</code>的使用、<code>操作码的设置</code>等都是<strong>对称</strong>的。例如，在存储单元的使用上，所有通用寄存器都要同等对待。</p></li><li><p>均匀性：指对于各种<code>不同</code>的操作数类型、字长和数据存储单元，指令的设置都要<code>同等对待</code>。**例如，如果某机器有 5 种数据表示，4 种字长，两种存储单元，则要设置 5x4x2&#x3D;40 种同一操作的指令(如加法指令)**。不过，这样做太复杂，也不太现实。所以一般是实现有限的规整性。例如，把上述加法指令的种类减少到 10 种以内。</p></li></ul><h3 id="其他性质"><a href="#其他性质" class="headerlink" title="其他性质"></a>其他性质</h3><ul><li><strong>正交性</strong>：是指在指令中各个不同含义的字段，如操作数类型、数据类型、寻址方式字段等，在编码时应互不相关、相互独立。高效率是指指令的执行速度快、使用频度高。在 RISC 结构中，大多数指令都能在一个节拍内完成(流水)，而且只设置使用频度高的指令。</li><li><strong>高效率</strong>：求指令的向后兼容。</li><li><strong>兼容性</strong>主要是要实现向后兼容，指令系统可以增加新指令，但不能删除指令或更改指令的功能。</li></ul><p>在设计系统时，有两种截然不同的设计策略，因而产生了两类不同的计算机系统，CISC 和 RISC。CISC 是增强指令功能，把越来越多的功能交由硬件来实现，指令的数量也是越来越多。RISC 是尽可能地把指令系统简化，不仅指令的条数少，而且指令的功能也比较简单</p><h1 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h1><p>能够改变控制流的指令有4种:<strong>分支</strong> (<em>branch</em>)、<strong>跳转</strong>(<em>jump</em>)、<strong>过程调用</strong> (<em>call</em>)和<strong>过程返回</strong>(<em>return</em>)。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911113245581.png"                      alt="image-20230911113245581"                ></p><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><p>条件分支的分支条件表示：</p><table><thead><tr><th>分支条件表示</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td><strong>条件码</strong>：在程序的控制下，由ALU的操作设置特殊的位</td><td><em>可以设置自由设置分支条件</em></td><td>必须从一条指令将分支条件信息传送到分支指令，所以CC是额外状态，条件码限制了执行顺序。</td></tr><tr><td><strong>条件寄存器</strong>：比较指令把比较结果放进任何一个寄存器，检测的时候就检测这个寄存器</td><td><em>简单</em></td><td>占用了一个<code>寄存器</code>。</td></tr><tr><td><strong>比较分支</strong>：受到一定限制</td><td><em>一条指令完成两条指令的功能</em></td><td>分支指令的操作<code>增多</code>。</td></tr></tbody></table><p><strong>小于或者等于分支占主导地位</strong>。</p><p>因为大多数时候写的是</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span> ; i&lt;length;i++);</span><br></pre></td></tr></table></figure></div><p>所以才会导致$\leq$的数目增多</p><p><strong>分支地址转移目标的表示</strong>：采用4~8位的偏移量字段（以指令字为单位）就能表</p><p>示大多数控制指令的转移目标地址</p><h2 id="过程调用和返回的状态保存"><a href="#过程调用和返回的状态保存" class="headerlink" title="过程调用和返回的状态保存"></a>过程调用和返回的状态保存</h2><p><strong>“调用者保存”方法 vs “被调用者保存”方法</strong></p><p>调用者保存不知道需要用到什么寄存器，而被调用者知道使用什么寄存器来保存断点。</p><p>所以被调用者保存是更加普遍的方法</p><h1 id="指令操作码的优化"><a href="#指令操作码的优化" class="headerlink" title="指令操作码的优化"></a>指令操作码的优化</h1><ol><li><strong>等长扩展码</strong></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694564098310.png"                      alt="1694564098310"                ></p><p>不是说只有一种方法，按照扩展标识的不同，还有其他的许多种扩展方法。</p><p>👩🏻‍🏫扩展操作码必须遵守短码不能是长码的前缀的规则。扩展操作码的编码不唯一，平均码也不唯一。</p><ol start="2"><li><strong>定长操作码</strong></li></ol><p><code>固定长度的操作码</code>:所有指令的操作码都是同一个长度。</p><p>保证操作码的译码速度、减少译码的复杂度。</p><p>按照程序的存储空间为代价去换取硬件上的简单实现</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-指令系统的发展和改进</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%94%B9%E8%BF%9B/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E6%94%B9%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># CISC指令集功能设计<h2 id="1-面向目标程序增强指令功能"><a href="#1-面向目标程序增强指令功能" class="headerlink" title="1. 面向目标程序增强指令功能"></a>1. 面向目标程序增强指令功能</h2><ul><li><p>对频率高的指令串，用一条<strong>新的指令</strong>来替代</p></li><li><p>既能<strong>减少目标程序的执行时间</strong>，又能有效<strong>缩短程序长度</strong></p></li><li><p><u>改进</u>方面：</p><ul><li><p>增强运算型指令的功能</p></li><li><p>增强数据传送指令的功能</p><ul><li><code>比如说进行数组的搬运等</code></li></ul></li><li><p>增强程序控制指令的功能</p></li></ul></li></ul><hr><h2 id="2-面向高级语言的优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）"><a href="#2-面向高级语言的优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）" class="headerlink" title="2. 面向高级语言的优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）"></a>2. 面向<strong>高级语言的</strong>优化实现来改进指令系统（缩小高级语言和机器语言的语义差距）</h2><ul><li><p><span style="color:#c45a65">高级语言与一般的机器语言的语义差距非常大，为高级语言程序的编译带来了一些问题</span></p></li><li><p>✅编译器本身比较复杂</p></li><li><p>✅编译生成的目标代码比较难达到很好的优化</p><ol><li><p>对高级语言和<strong>编译器</strong>的支持。在高级语言中找一些常用的指令并做一些支持。</p></li><li><p>增强系统结构的规整性，减少系统结构中的各种例外情况。</p></li></ol></li></ul><p><span style="color:#5698c3">“比较简单的系统结构+软件”</span></p><hr><h2 id="3-面向操作系统的优化实现改进指令系统"><a href="#3-面向操作系统的优化实现改进指令系统" class="headerlink" title="3. 面向操作系统的优化实现改进指令系统"></a>3. 面向操作系统的优化实现改进指令系统</h2><ol><li><p>处理机<code>工作状态</code>和<code>访问方式</code>的切换。</p></li><li><p>进程的<code>管理</code>和<code>切换</code>。</p></li><li><p><u>存储管理</u>和<u>信息保护</u></p></li><li><p>进程的同步和排斥，<code>信号灯的管理等</code></p></li></ol><hr><h2 id="CISC结构存在着的缺点"><a href="#CISC结构存在着的缺点" class="headerlink" title="CISC结构存在着的缺点"></a>CISC结构存在着的缺点</h2><ol><li><p>指令出现的频率<code>相差悬殊</code>，很多指令的没办法用到</p></li><li><p>指令系统大，<code>指令条数</code>很多，指令功能复杂</p><ul><li><p>占用<u>大量芯片面积</u></p></li><li><p>增加研制时间和成本，还会造成设计错误</p></li></ul></li><li><p>由于操作繁杂，CPI的值比较大</p></li></ol><hr><h1 id="RISC指令集功能设计原则"><a href="#RISC指令集功能设计原则" class="headerlink" title="RISC指令集功能设计原则"></a>RISC指令集功能设计原则</h1><ol><li><p>指令条数少，<code>指令功能简单</code>。在确定指令系统时，<strong>只选取</strong>使用频度很高的指令，在此基础上<strong>补充一些最有用的指令</strong>(如支持操作系统和高级语言实现的指令)。</p></li><li><p>采用<code>简单而又统一</code>的指令格式，并<code>减少寻址方式</code>。指令字长都为 32 位或64 位。</p></li><li><p>指令的执行在<code>单周期内完成</code>(采用流水线技术后)。</p></li><li><p><u>采用 <em>Load-Store</em> 结构</u>。即只有 Load 和 Store 指令才能访问存储器，<u>其他指令的操作都是在寄存器之间进行的</u>。</p></li><li><p>大多数指令都采用<strong>硬连线逻辑</strong>来实现。</p></li><li><p>强调<span style="color:#5698c3">优化编译器</span>的作用，为高级语言程序生成优化的代码</p></li><li><p>充分利用<strong>流水</strong>技术来<strong>提高性能</strong>。</p></li></ol><hr><h1 id="MIPS指令分析"><a href="#MIPS指令分析" class="headerlink" title="MIPS指令分析"></a><strong>MIPS</strong>指令分析</h1><p>介绍<strong>MIPS</strong>32的一个子集，就称为<strong>MIPS</strong>指令集</p><ol><li><p>32个32位的通用寄存器（<u>GPRs</u>）</p><p> 寄存器R0的内容恒为全0</p></li><li><p>32个32位的浮点寄存器（<u>FPRs</u>）</p><p> 单精度浮点数标识和双精度浮点数表示</p></li></ol><p>💬最重要的是<strong>指令格式</strong></p><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="1-I类指令"><a href="#1-I类指令" class="headerlink" title="1. I类指令"></a>1. I类指令</h3><table><thead><tr><th align="center">op</th><th align="center">rs1</th><th align="center">rs2</th><th align="center">Imm</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">5</td><td align="center">5</td><td align="center">16</td></tr></tbody></table><p>  <strong>Load</strong> &#x2F; <strong>Store</strong></p><p>   <code>寄存器</code>-<code>立即数</code>ALU</p><p>   <code>分支指令</code></p><p>   <em>寄存器跳转 and 链接</em></p><h3 id="2-R类指令"><a href="#2-R类指令" class="headerlink" title="2. R类指令"></a>2. R类指令</h3><table><thead><tr><th align="center">op</th><th align="center">rs1</th><th align="center">rs2</th><th align="center">rd</th><th align="center">Imm</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">5</td><td align="center">5</td><td align="center">5</td><td align="center">11</td></tr></tbody></table><p>  <strong>寄存器-寄存器指令</strong></p><h3 id="3-J类指令"><a href="#3-J类指令" class="headerlink" title="3. J类指令"></a>3. J类指令</h3><table><thead><tr><th align="center">op</th><th align="center">PC的偏移量</th></tr></thead><tbody><tr><td align="center">6</td><td align="center">26</td></tr></tbody></table><p>  <strong>跳转指令</strong></p><h2 id="MIPS效能分析"><a href="#MIPS效能分析" class="headerlink" title="MIPS效能分析"></a>MIPS效能分析</h2><p>指令格式、寻址方式、操作都很简单</p><p>$T_{CPU} &#x3D; IC \times CPI \times T_{CLK}$</p><p>$\frac{T_{CPU-MIPS}}{T_{CPU-VAX}}&#x3D;1.0~2.5 \times \frac{1}{4} * \frac{T_{CLK-MIPS}}{T_{CLK-VAX}}$</p><p><strong>所以性能会更高</strong></p><hr><p>[[CourseNotes&#x2F;计算机体系结构&#x2F;CA-第七讲 流水线技术]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 指令系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-存储层次-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1-1/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]<br>#存储器的层次结构<br>#Cache基本知识</p><p>局部性</p><h2 id="存储器芯片技术"><a href="#存储器芯片技术" class="headerlink" title="存储器芯片技术"></a>存储器芯片技术</h2><ol start="2"><li>DIMM (dual inline memory modules )</li></ol><p>多个DRAM芯片经常被组装在称为条的小型板上构成“双列直插式存储模块”</p><p>一个DIMM通常包含4~16片DRAM芯片，这些芯片常被组织成8字节宽的主存 (带ECC校验</p><p>3.DRAM芯片优化技术</p><blockquote><p>芯片内部优化技术是提高主存系统性能的一个重要方面</p></blockquote><p>SDRAM: Synchronous DRAM，DRAM接口增加一个时钟信号可使DRAM能针对一个请求连续同步地传输多个数据而不需同步开销</p><p>DDR (double data rate) :在DRAM时钟的上沿和下沿都进行数据传输，可把数据传输率提高一倍。</p><p>CDRAM ( Cache DRAM) :带Cache的 DRAMDRAM芯片里集成一个小的SRAM，暂存最后读出行数据。</p><h3 id="虚存和Cache关系的例子"><a href="#虚存和Cache关系的例子" class="headerlink" title="虚存和Cache关系的例子"></a>虚存和Cache关系的例子</h3><h2 id="进程保护和虚存实例"><a href="#进程保护和虚存实例" class="headerlink" title="进程保护和虚存实例"></a>进程保护和虚存实例</h2><p><strong>进程：程序呼吸所需要的空气和生存的空间</strong></p><p>进程保护</p><ol><li><p>界地址寄存器</p><p> 基地址 上界地址<br> 检测条件：（基地址+地址）&lt;&#x3D; 上界地址</p></li><li><p>虚拟存储器</p><p> 给每个页面增加访问权限标识</p></li><li><p>环形保护</p></li><li><p>加锁和隔离</p></li></ol><hr><p>本章小结</p><p>多级存储结构</p><p>性能参数</p><p>两级存储层次</p><p>Cache基本知识</p><p>性能分析</p><p>降低Cache失效率</p><p>提高相联度</p><p>调节块大小</p><p>硬件预取</p><p>编译预取</p><p>编译优化</p><p>减少失效开销</p><p>写缓冲和写合并</p><p>容量小&#x2F;结构简单Cache</p><p>请求字优先</p><p>多级Cache</p><p>非阻塞Cache</p><blockquote><p>T4,T6</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-基本的MIPS流水线（读书）</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%9F%BA%E6%9C%AC%E7%9A%84MIPS%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E8%AF%BB%E4%B9%A6%EF%BC%89/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E5%9F%BA%E6%9C%AC%E7%9A%84MIPS%E6%B5%81%E6%B0%B4%E7%BA%BF%EF%BC%88%E8%AF%BB%E4%B9%A6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<p>在MIPS多周期实现的基础上，将每个周期看作是流水线的时钟周期。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925090513.png"                      alt="image.png"                ></p><p>要保证在指令重叠的时候没有任何流水线资源的冲突问题，如下图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925090621.png"                      alt="image.png"                ></p><p><strong>流水线处理器的带宽必须是非流水实现的5倍</strong></p><p><strong>寄存器的读写都是同时发生的时候怎么办</strong>？</p><p>🤔必须要在操作段就完成PC的取指令执行，也就是IF段要在一个时钟周期时间内确定下一个PC的地址。</p><p>如何重新组织数据通路，在下一个IF段到达之前更改下一个PC的值，也就是如何处理分支指令的问题。</p><p>每个周期都要用到所有的流水段，所以每个流水段的操作必须在一个时钟周期内完成。</p><h3 id="改进前的数据通路"><a href="#改进前的数据通路" class="headerlink" title="改进前的数据通路"></a>改进前的数据通路</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925091503.png"                      alt="image.png"                ></p><h3 id="改进后的数据通路"><a href="#改进后的数据通路" class="headerlink" title="改进后的数据通路"></a>改进后的数据通路</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230925091248.png"                      alt="image.png"                ></p><p>更改的部分：</p><ul><li>讲PC的选择部分更改到IF段来进行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-体系结构试验1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%95%E9%AA%8C1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AF%95%E9%AA%8C1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]][[CourseNotes/计算机体系结构/CA-基本的MIPS流水线（读书）]]<h1 id="1-实验一：流水线处理器-—-CA-Labs-1-0-0-文档"><a href="#1-实验一：流水线处理器-—-CA-Labs-1-0-0-文档" class="headerlink" title="1. 实验一：流水线处理器 — CA-Labs 1.0.0 文档"></a>1. 实验一：流水线处理器 — CA-Labs 1.0.0 文档</h1><p><a class="link"   href="https://hit-coa.gitlab.io/archlab/labs/lab1.html#id2" >https://hit-coa.gitlab.io/archlab/labs/lab1.html#id2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h2 id="1-1-实验目的"><a href="#1-1-实验目的" class="headerlink" title="1.1. 实验目的"></a>1.1. 实验目的</h2><ul><li>掌握 Vivado 集成开发环境</li><li>掌握 Verilog 语言</li><li>掌握 FPGA 编程方法及硬件调试手段</li><li>深刻理解流水线型处理器结构和数据冲突解决技术的工作原理</li></ul><h2 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2. 实验环境"></a>1.2. 实验环境</h2><ul><li>Vivado 集成开发环境和龙芯 Artix-7 实验平台</li></ul><h2 id="1-3-实验内容"><a href="#1-3-实验内容" class="headerlink" title="1.3. 实验内容"></a>1.3. 实验内容</h2><ul><li>根据本课程所讲的设计思想，在单周期 CPU 的基础上，设计并实现一个具有五段流水线处理器，并通过暂停和定向（或者说旁路）技术来解决流水线中出现的数据冲突，要求该处理器可以<strong>通过所提供的自动测试环境</strong>。</li></ul><h3 id="1-3-1-流水线处理器的周期划分"><a href="#1-3-1-流水线处理器的周期划分" class="headerlink" title="1.3.1. 流水线处理器的周期划分"></a>1.3.1. 流水线处理器的周期划分</h3><p>与单周期处理器不同，流水线型处理器将“工作”划分为多个流水段来完成一条指令。每个时钟周期对应于流水线的一个阶段。流水线型处理器结构的主要优点是它可以并行执行多个指令：在同一时刻，多个指令可以同时存在于流水线中不同的阶段。在本实验中，流水线划分为五个周期。每个流水段产生的结果都在相应的时钟周期时传递给下一个流水段。</p><h3 id="1-3-2-数据冲突的处理"><a href="#1-3-2-数据冲突的处理" class="headerlink" title="1.3.2. 数据冲突的处理"></a>1.3.2. 数据冲突的处理</h3><p>参照参考书（王志英等著）第3章的3.3.2小节，采用暂停和定向技术来处理流水线中出现的数据冲突。</p><h3 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h3><p>当检测到数据冲突，通过暂停来阻止即将进入流水线中的指令。本实验中，暂停只能在必要时插入流水线。</p><h3 id="定向"><a href="#定向" class="headerlink" title="定向"></a>定向</h3><p>通过增加定向控制所需要的比较器、多路选择器和相关组合逻辑电路，实现对数据的重定向，解决数据冲突。</p><h2 id="1-4-实验要求"><a href="#1-4-实验要求" class="headerlink" title="1.4. 实验要求"></a>1.4. 实验要求</h2><p>按照以上要求将前置实验中所实现的单周期处理器改进成具有五段流水线处理器，并通过暂停和定向技术解决流水线中产生的数据冲突。</p><h3 id="1-4-1-实验预习"><a href="#1-4-1-实验预习" class="headerlink" title="1.4.1. 实验预习"></a>1.4.1. 实验预习</h3><p>在实验开始前给出处理器的设计方案，设计方案要求包括：</p><ul><li>流水线处理器结构设计框图及各段的寄存器文件描述</li><li>定向控制硬件的设计框图及功能描述</li></ul><h3 id="1-4-2-完成实验内容"><a href="#1-4-2-完成实验内容" class="headerlink" title="1.4.2. 完成实验内容"></a>1.4.2. 完成实验内容</h3><p><strong>Verilog 语言实现</strong>：要求采用结构化设计方法，用 Verilog 语言实现处理器的设计。设计包括：</p><ul><li>各模块的详细设计（包括各模块功能详述，设计方法，Verilog 语言实现等）</li><li>各模块的功能测试（每个模块作为一个部分，包括测试方案、测试过程和测试波形等）</li><li>系统的详细设计（包括系统功能详述，设计方法，Verilog 语言实现等）</li><li>系统的功能测试（包括系统整体功能的测试方案、测试过程和测试波形等）</li></ul><p><strong>FPGA 编程下载</strong>：将比特流下载到 Artix-7 实验板中。然后利用 Vivado 的上板调试功能观察 Artix-7 实验板的 FPGA 芯片中的实际运行，观察处理器内部运行状态，显式输出内部状态运行结果。</p><p><strong>对处理器进行功能测试，记录运行过程和结果，完成实验报告</strong>：对处理器进行功能测试，编写处理器功能测试程序，包括指令缓冲存储器和数据缓冲存储器完成处理器功能测试，并观察记录运行过程和结果，完成实验报告。</p><h2 id="1-5-处理器测试环境"><a href="#1-5-处理器测试环境" class="headerlink" title="1.5. 处理器测试环境"></a>1.5. 处理器测试环境</h2><p>要求同学们遵守实验测试环境的相应要求，不允许修改接口，不允许修改trace文件。</p><h3 id="1-5-1-测试用例"><a href="#1-5-1-测试用例" class="headerlink" title="1.5.1. 测试用例"></a>1.5.1. 测试用例</h3><p>我们提供三个测试用例对 CPU 进行测试：</p><ul><li>基础验收指令：存在数据冲突，需要在分析指令间存在的冲突后，手动向指令缓冲存储器中存在冲突的两条指令之间增加气泡（空指令）以避免冲突。</li><li>附加验收指令1：存在数据冲突，需要使用暂停和定向等技术解决数据冲突，不允许修改指令缓冲存储器文件的内容。</li><li>附加验收指令2：存在数据冲突，需要使用暂停和定向等技术解决数据冲突，不允许修改指令缓冲存储器文件的内容。</li></ul><p>备注</p><ul><li>MIPS的<code>nop</code>编码为全0，对应我们未实现的移位指令<code>sll $0, $0, 0</code>，保证你的设计在执行这条指令时，不写寄存器，PC正常+4即可。</li><li>要求 CPU 设计能够通过全部三个用例的仿真测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 流水线技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-RW-CH4</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH4/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH4/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><p>指令的<strong>静态和动态调度</strong> 解决<strong>控制相关</strong>技术和<strong>多指令流出</strong>等内容</p><p>指令的静态调度 包括循环级并行的处理，寄存器换名和指令调度等等。</p><p>指令的动态调度包括目前最常用的两种硬件策略：计分牌和Tomasulo算法</p><p>解决控制相关的技术，理解分支预测缓冲技术</p><p>多指令流出技术</p><hr><h2 id="指令集并行的概念"><a href="#指令集并行的概念" class="headerlink" title="指令集并行的概念"></a>指令集并行的概念</h2><p>实际的CPI &#x3D; 理想CPI  +  结构相关的停顿 + 先写后读的停顿 + 先读后写的停顿 + 写后写的停顿 + 控制相关的停顿</p><p>本章研究的技术和所克服的停顿：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119151902.png"                      alt="image.png"                ></p><h3 id="循环展开调度的基本方法"><a href="#循环展开调度的基本方法" class="headerlink" title="循环展开调度的基本方法"></a>循环展开调度的基本方法</h3><ol><li>保证正确性</li><li>保证有效性</li><li>使用不同的寄存器</li><li>尽可能地减少循环控制种地测试指令和分支指令</li><li>注意对存储器数据的相关性分析</li><li>注意新的相关性</li></ol><h3 id="相关性"><a href="#相关性" class="headerlink" title="相关性"></a>相关性</h3><ol><li>数据相关</li><li><strong>名相关</strong> 如果两个指令使用同名的寄存器但是之间并没有数据流，就叫做名相关；<ol><li><em>反相关</em> 知道是i先执行，j指令需要写的名字是i要读的名 <strong>先读后写相关</strong></li><li><em>输出相关</em> 输出相关的指令是不能颠倒的。 <strong>写后写相关</strong></li></ol></li><li>控制相关</li></ol><h2 id="指令的动态调度"><a href="#指令的动态调度" class="headerlink" title="指令的动态调度"></a>指令的动态调度</h2><h3 id="动态调度原理"><a href="#动态调度原理" class="headerlink" title="动态调度原理"></a>动态调度原理</h3><p>为了 <strong>乱序执行</strong>  </p><p>流出：指令译码 检查是否存在结构的阻塞</p><p>读操作数：没有数据相关引发的阻塞就读操作数</p><h3 id="记分牌"><a href="#记分牌" class="headerlink" title="记分牌"></a>记分牌</h3><p>在第二阶段的读操作数的时候，只要指令所需要的资源都满足而且没有数据阻塞就允许指令乱序执行</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119160231.png"                      alt="image.png"                ></p><p><strong>流水线指令流出和执行的步骤</strong></p><ol><li><p>流出 IS 如果本质零多需要的功能部件有空闲，并且其他的正在执行的指令使用的目的寄存器和本指令不相同，计分配就向功能部件流出这个指令，并修改记分牌内部的数据记录</p></li><li><p>读操作数 RO 记分牌检测源操作数寄存器种数据的有效性，如果前面已经流出的还在运行的指令不对这个指令的源操作数进行写操作，或者一个正在工作的功能部件已经完成了对这个寄存器的写操作，那么此操作数有效。</p></li><li><p>执行 EX</p></li><li><p>写结果 WR</p></li></ol><p>:luc_battery_charging: 注意还是要考虑到带宽</p><p><strong>记分牌记录的信息要分成三个部分</strong></p><p><em>指令状态表</em>：记录正在执行的个条指令已经进入记分牌MIPS流水段四段种的哪一段</p><p><em>功能部件状态表</em>：记录各个功能部件的状态，每个功能部件在状态表中都以剩下的9个域来记录</p><p><code>Busy</code> : 标识功能部件是不是在工作</p><p><code>Op</code> : 功能部件但钱执行的操作.</p><p><code>Fi</code> : 目的寄存器编号</p><p><code>Fj</code> <code>Fk</code> : 代表源寄存器编号</p><p><code>Qj</code> <code>Qk</code> : 代表向Rj,Rk中写结果的功能部件</p><p><code>Rj</code> <code>Rk</code> : 表示Fj  Fk是否就绪，是否已经被使用</p><p><em>结果寄存器状态表</em>：每个寄存器在表中有一个域，用于记录写入这个寄存器功能部件。</p><p>详细分析：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LD      F6,34(R2)</span><br><span class="line">LD      F2,45(R3)</span><br><span class="line">MULID   FO,F2,F4</span><br><span class="line">SUBD    F8,F6,F2</span><br><span class="line">DIVD    F10,FO,F6</span><br><span class="line">ADDD    F6,F8,F2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119163421.png"                      alt="image.png"                ></p><p>记分牌的流水线控制方式：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119171219.png"                      alt="image.png"                ></p><p><strong>记分牌的性能受限于</strong></p><ul><li><p>程序指令中可以开发的并行性，也就是是不是存在可以并行执行的不相关的指令</p></li><li><p>记分牌的容量</p></li><li><p>功能部件的数目和种类</p></li><li><p>反相关和输出相关。会引起记分牌中的先读后写和写后写阻塞</p></li></ul><p>问题2和3可以通过增加记分牌的容量和功能部件的数量来解决，这会导致处理器的成本增加，并可能影响到系统时钟周期时间。</p><h3 id="Tomasulo算法"><a href="#Tomasulo算法" class="headerlink" title="Tomasulo算法"></a>Tomasulo算法</h3><p>将记分牌的关键部分和寄存器换名技术结合在一起，这样的调度机制实现虽然有很多的变化</p><p>三个阶段 IS EX WB</p><p><strong>核心</strong>： 通过寄存器换名的方式来消除写后写和先读后写的相关而可能造成的流水线阻塞</p><p><strong>主要不同</strong>：</p><ol><li><p>指令流出的逻辑和保留站相结合实现寄存器换名，完全消除了数据写后写和先读后写相关这一类的名相关</p></li><li><p>冲突检测和指令执行控制机制分开</p></li><li><p>计算的结果通过相关专用通路直接从功能部件进入对应的保留站进行缓冲，而不一定是写到寄存器</p></li></ol><p><strong>Tomasulo 保留站结构</strong></p><p><code>Op</code> 部件所进行的操作</p><p><code>Vj</code> <code>Vk</code> : 源操作数的值。Store缓冲区有Vk区域，用于存放要写入存储器的值。V域和Q域不同时有效</p><p><code>A</code> : 存放存储器地址开始存立即数，计算出有效的地址之后，存放有效地址</p><p><code>Busy</code>: 标识保留站Rs或者响应的功能部件FU是否空闲</p><p><em>Register result status</em>  如果存在在对寄存器的写操作，指示对这个寄存器进行写操作的部件</p><p><code>Qi</code> : 保留站的编号</p><p><strong>Tomasulo 算法实现消除阻塞的方法</strong></p><ol><li><p>产生DIVD指令操作数F6的指令(第一个LD)一旦执行完，DIVD指令对应保留站的Vk区域就保存这个结果，这样DIVD和ADDD之间就不再有冠以F6的限度后写相关，ADDD指令就可以执行下去</p></li><li><p>如果第一个LD指令还没有执行完毕，DIVD指令所在的MULT2保留站的Qk域将指向第一条LD指令的保留站LOAD1，从而允许ADDD指令执行并将结果存入结果寄存器而不影响DIVD的执行</p></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LD      F6,34(R2)</span><br><span class="line">LD      F2,45(R3)</span><br><span class="line">MULID   FO,F2,F4</span><br><span class="line">SUBD    F8,F6,F2</span><br><span class="line">DIVD    F10,FO,F6</span><br><span class="line">ADDD    F6,F8,F2</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119193739.png"                      alt="image.png"                ></p><p><strong>Tomasulo 在每个阶段的动作</strong></p><p><strong>IS阶段</strong><br>对于浮点操作，进入条件： <em>有保留空间站r</em></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201115.png"                      alt="image.png"                ></p><p>经历的阶段是：</p><ol><li><p>如果没有就绪就执行换名操作然后进入等待</p></li><li><p>如果数据已经又笑了，就将数据传送给V寄存器，然后标识其有效</p></li><li><p>设置保留站繁忙且设置操作类型和目标寄存器</p></li></ol><p>对于存&#x2F;取操作，进入条件：<em>有空闲缓冲r</em></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201131.png"                      alt="image.png"                ></p><p>这一部分是统一测操作</p><p>取操作不同处:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201335.png"                      alt="image.png"                ></p><p>存操作不同处:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231119201358.png"                      alt="image.png"                ></p><hr><p><strong>EX阶段</strong></p><p>对于浮点操作，进入的条件是：</p><p><em>两个源操作数都就绪</em></p><p>取和存第一步的进入条件是</p><p><em>第一个操作数就绪并且r到达了缓冲队列的头部</em></p><hr><p><strong>基于Tomasulo算法的动态循环展开</strong></p><p><em>一旦有一条指令没有执行完，其后的指令不允许进入执行段</em></p><p>第一次取数LD，由于Cache miss需要8个时钟周期延迟，之后的取数LD，只需要1个时钟周期，<em>存数需要3个时钟周期</em></p><p><em>乘法需要4个时钟周期</em></p><p>现在假设连续两遍的循环的所有指令全部流出，但是所有的浮点存&#x2F;取和运算的操作全部没有完成。给出状态表的信息。</p><p><strong>优点</strong></p><ul><li>分布式件冲突检测。</li><li>利用寄存器换名，彻底消除WAW和WAR这两种名相关</li><li>如果多个保留站等待同一个操作数，当操作数在CDB上广播时，他们可以同时获得所害的数据</li><li>对于存储器访问，动态存储器地址判别技术可解决RAW冲突(取操作数时判断)、WAR和WAW冲突(存操作数的时候判断)</li><li>能够达到很高的性能</li></ul><h2 id="控制相关的动态解决技术"><a href="#控制相关的动态解决技术" class="headerlink" title="控制相关的动态解决技术"></a>控制相关的动态解决技术</h2><h3 id="分支预测缓冲"><a href="#分支预测缓冲" class="headerlink" title="分支预测缓冲"></a>分支预测缓冲</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH2/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><h2 id="指令系统主要内容"><a href="#指令系统主要内容" class="headerlink" title="指令系统主要内容"></a>指令系统主要内容</h2><hr><h3 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h3><p><code>Push</code> &#x2F; <code>Pop</code> <strong>堆栈</strong></p><p><code>Load</code> &#x2F; <code>Store</code> <strong>累加器 （1个操作数）</strong></p><p><code>Load</code> &#x2F; <code>Store</code> <strong>寄存器或者存储器 （2&#x2F;3操作数）</strong></p><hr><h3 id="通用寄存器型结构"><a href="#通用寄存器型结构" class="headerlink" title="通用寄存器型结构"></a>通用寄存器型结构</h3><p><code>R-R</code> <code>R-M</code> <code>M-M</code></p><hr><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png"                      alt="Untitled"                ></p><p>为了保证访问速度现在的计算机一般都是按整数边界存储信息。</p><hr><h3 id="指令系统设计的基本原则"><a href="#指令系统设计的基本原则" class="headerlink" title="指令系统设计的基本原则"></a>指令系统设计的基本原则</h3><p>完整性 规整性 正交性 高效率和兼容性</p><p><code>正交性</code></p><p>编码的时候互不相关互相独立</p><hr><p><strong><strong><strong><strong>定义： 指令是无条件改变控制流的时候称之为跳转指令，控制指令是有条件改变控制流的时候称之为分支指令。</strong></strong></strong></strong></p><h3 id="指令操作码的优化"><a href="#指令操作码的优化" class="headerlink" title="指令操作码的优化"></a>指令操作码的优化</h3><blockquote><p>指的是用最短的位数来表示指令的操作信息和地址信息</p></blockquote><p><code>哈夫曼树设计思想</code></p><p>选用哪种编码取决于使用频率的分析</p><p>当代计算机：RISC 使用定长操作码</p><hr><h3 id="沿CISC方向发展和改进指令系统"><a href="#沿CISC方向发展和改进指令系统" class="headerlink" title="沿CISC方向发展和改进指令系统"></a>沿CISC方向发展和改进指令系统</h3><ol><li><p>面向目标程序增强指令性能</p><ol><li><p>增强运算行指令的功能</p></li><li><p>增强数据传送指令的功能</p></li><li><p>增强程序控制指令的功能</p></li></ol></li><li><p>面向高级语言的优化实现来改进指令系统</p></li><li><p>面向操作系统的优化实现改进指令系统</p><ol><li><p>处理机工作状态和访问方式的切换</p></li><li><p>进程的管理和切换</p></li><li><p>存储管理和信息保护</p></li><li><p>进程的同步和互斥，信号灯的处理等</p></li></ol></li></ol><h3 id="沿RISC方向发展和改进指令系统"><a href="#沿RISC方向发展和改进指令系统" class="headerlink" title="沿RISC方向发展和改进指令系统"></a>沿RISC方向发展和改进指令系统</h3><p>💡 <code>CISC</code> 出现的问题</p><ol><li><p>指令的使用频度存在悬殊</p></li><li><p>指令系统庞大，指令条数太多，指令的功能太复杂</p><ol><li><p>占用芯片面积，增加制造成本</p></li><li><p>增加研制时间和成本，还容易造成设计错误</p></li></ol></li><li><p>许多指令因为操作繁杂，使得CPI比较大</p></li><li><p>由于指令功能复杂，规整性不好，不利于采用流水技术来提高性能</p></li></ol><p><code>RISC</code> 机器的设计</p><ol><li><p>指令条数少，指令功能简单</p></li><li><p>采用简单而又统一的指令格式，并减少寻址方式</p></li><li><p>功能部件流水化，指令的执行能够在单周期完成</p></li><li><p>采用<code>load-store</code> 结构，只有这两个指令可以方寸</p></li><li><p>大多数指令都采用硬件逻辑来实现</p></li><li><p>优化编译器，为高级语言生成高效的代码</p></li><li><p>充分利用流水技术来提高性能</p></li></ol><hr><h3 id="操作数的类型和大小"><a href="#操作数的类型和大小" class="headerlink" title="操作数的类型和大小"></a>操作数的类型和大小</h3><p><strong>表示操作数类型的方法</strong></p><ol><li><p>指定操作数的类型</p></li><li><p>给数据加上标识</p></li></ol><hr><h3 id="MIPS指令系统结构"><a href="#MIPS指令系统结构" class="headerlink" title="MIPS指令系统结构"></a><strong>MIPS指令系统结构</strong></h3><p><strong>寄存器</strong></p><p>32个54位寄存器：<code>R0</code> ~ <code>R31</code> 其中保持<code>R0 = 0</code></p><p>32个单精度浮点寄存器：<code>F1</code> ~ <code>F31</code> 存储32位单精度浮点数和64位双精度浮点数</p><p><strong>MIPS数据表示</strong></p><p>整数：字节 半字 字</p><p>浮点数： 单精度浮点数 双精度浮点数</p><p>字节或者半字装入的时候使用零扩展的方式来进行</p><p><strong><strong><strong><strong>MIPS寻址方式</strong></strong></strong></strong></p><p>只提供：<strong>立即数寻址和偏移量寻址</strong></p><p>间接寻址：当偏移量为0的时候就是寄存器间接寻址</p><p>绝对寻址：当使用<code>R0</code>作为基址的时候就是16位绝对寻址</p><h2 id="👿👿-MIPS指令格式"><a href="#👿👿-MIPS指令格式" class="headerlink" title="👿👿 MIPS指令格式"></a><strong>👿👿 MIPS指令格式</strong></h2><p>三种指令格式</p><p><strong>I类指令</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.png"                      alt="Untitled"                ></p><p>包括 <code>load</code> <code>store</code> 寄存器-立即数型<code>ALU</code>指令 分支指令的转移目标地址 寄存器跳转并链接的转移目标地址</p><p><strong>R类指令</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png"                      alt="Untitled"                ></p><p>R类型指令包括寄存器-寄存器型的<code>ALU</code>指令 专用寄存器读&#x2F;写指令 <code>move</code> 指令等</p><p><code>func</code> 为具体的运算操作编码<br>​<br><strong>J类指令</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%203.png"                      alt="Untitled"                ></p><p>这类指令包括跳转指令&#x2F;跳转并链接指令&#x2F;自陷指令&#x2F;异常返回指令。</p><p>跳转类型是两个</p><hr><h3 id="MIPS浮点操作"><a href="#MIPS浮点操作" class="headerlink" title="MIPS浮点操作"></a>MIPS浮点操作</h3><p>用后缀S标识操作数是单精度浮点数，D标识是双精度浮点数</p><p>例如 <code>MOVD</code> <code>MOVS</code></p><hr><p><strong>某机的指令字长为 16 位,设有单地址指令和两地址指令。若每个地址字段均为6 位，且两地址指令有 A 条，问单地址指令最多可以有多少条?</strong></p><p>单地址段的设计：由于地址字段为6位，所以功能字段为10位，不考虑两个地址指令，那么单地址指令就有$2^{16-6} &#x3D; 2 ^{10}$ 条。<br>两地址段的设计：由于此时只能用四位来作为功能码，由于有A条的两地址指令，所以单地址指令就有：$2^{10} - A \times 2 ^6$ 条。</p><p><strong>某处理机的指令系统要求有三地址指令 4 条、单地址指令 255 条、零地址指令16 条。设指令字长为 12 位,每个地址码长度为 3 位。问能否用扩展编码为其操作码编码?如果要求单地址指令为 254 条能否对其操作码扩展编码? 说明理由。</strong></p><p>但地址指令是255条，采用扩展编码的话操作码位数就是8位，地址码使用3位，指令字长是12位所以就剩下1位来标识其他类型的操作码，能表示零地址的指令只能表示2条，三地址的指令0条。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-RW-CH1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-RW-CH1/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><p>Owner: Slater Tags: CA</p><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png"                      alt="计算机体系结构的发展"                ></p><p>计算机体系结构的发展</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="file:///C:/Users/Slater/Desktop/128fcbb8-924f-4bcc-b57d-402f7bcfdb55_Export-7dec68fe-2fcc-425d-92e8-f7dcff183da4/CA-Chapter1%20f3cabde95d104b2aae105932d2ba3215/Untitled%201.png?lastModify=1700289313"                      alt="系列机和兼容"                ></p><p>系列机和兼容</p><h3 id="量化设计的基本原则"><a href="#量化设计的基本原则" class="headerlink" title="量化设计的基本原则"></a>量化设计的基本原则</h3><ol><li><p>大概率事件优先原则</p></li><li><p>Amdahl定律</p><p> 例 1.1 假设考虑条件分支指令的两种不同设计方法如下</p></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png"                      alt="Untitled"                ></p><p>加快某部件执行速度所获得的系统性能加速比受限于该部件在系统中所占的重要性</p><p>​</p><p><strong>系统加速比依赖于以下两个因素</strong></p><ol><li>可改进部分在原系统计算时间中所占的比例 <code>可改进比例</code></li><li>该部分改进以后的性能提高 <code>部件加速比</code></li></ol><p>$$<br>系统加速比 &#x3D; \frac{1}{(1-可改进比例)+\frac{可改进比例}{部件加速比}}<br>$$</p><ol><li><p>程序的局部性原理</p></li><li><p>CPU的性能</p></li></ol><p><code>IC</code> 代表程序执行过程中的指令数</p><p><code>CPU性能公式</code> 程序执行的CPU时间为：$CPI \times IC &#x2F; 时钟频率 &#x3D; CPI \times IC \times 时钟周期$</p><h3 id="基本可靠性模型"><a href="#基本可靠性模型" class="headerlink" title="基本可靠性模型"></a>基本可靠性模型</h3><p>平均无故障时间（<code>MTTF</code>）</p><p>平均修复时间（<code>MTTR</code>）</p><p>平均故障时间（<code>MTBF</code>）</p><p>关系： <code>MTBF</code> &#x3D; <code>MTTF</code> + <code>MTTR</code></p><p><code>FIT</code> 10亿小时中系统的故障次数</p><p>系统可用性：A &#x3D; \frac{MTTF}{MTBF} \times 100%</p><h2 id="例题重做"><a href="#例题重做" class="headerlink" title="例题重做"></a>例题重做</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a><em>Q1</em></h3><p>(1) CPU_A: 通过比较指令设置条件码，然后测试条件码进行分支。 (2) CPU_B:在分支指令中包括比较过程。</p><p>在两种 CPU 中,条件分支指令都占用2 个时钟周期而所有其他指令占用1 个时钟周期,对于 CPUA,执行的指令中分支指令占 20%;由于每个分支指令之前都需要有比较指令,因此比较指令也占 20%。由于 CPU_A在分支时不需要比较,因此假设它的时钟周期时间比 CPU 快1.25 倍。哪一个 CPU 更快?</p><p><code>CPU性能公式</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.jpeg"                      alt="Untitled"                ></p><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a><em><strong>Q2</strong></em></h3><p>一个由硬盘构成的外部存储系统包括两个部分，一块MTTF为30000小时的ATA硬盘，一套MTTF为300000小时的ATA控制器。请计算这个外存系统的MTTF</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.jpeg"                      alt="Untitled"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Review</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Review/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Review/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Reading for Lab1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Reading%20for%20Lab1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Reading%20for%20Lab1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<p><strong>线性</strong>流水线和<strong>非线性</strong>流水线</p><h2 id="基本MIPS流水线"><a href="#基本MIPS流水线" class="headerlink" title="基本MIPS流水线"></a>基本MIPS流水线</h2><p>保证在指令重叠的时候，不存在任何流水线资源冲突的问题。</p><p>将指令寄存器和数据寄存器分割开是为了避免取指令操作和访问数据操作之间存在访问存储器冲突。</p><p>在MIPS流水线中每个流水段所完成的操作如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231006113206.png"                      alt="image.png"                ></p><p>IF 段完成：</p><ul><li>从指令IMEM中读出IR指令</li><li>选择NPC的值 如果 <code>EX/MEM.cond</code> 为真就选择 <code>EX/MEM.NPC</code> 否则直接更新NPC &#x3D; PC &lt;&lt; 2</li></ul><p>ID 段完成：</p><p>将ID段取出的指令IR分解，给出ID&#x2F;EX.A 和 ID&#x2F;EX.B 分别是IR6……10和IR11……15</p><p>将NPC进行传递，将指令进行传递</p><p>立即数扩展并传入ID&#x2F;EX.Imm</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
            <tag> 流水线技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Lab-3</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Lab-3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Lab-3/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231102222628.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Lab-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Lab-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Lab-1/</url>
      
        <content type="html"><![CDATA[<head> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]<h1 id="在网上搜索到的可以进行参考的流水线操作图"><a href="#在网上搜索到的可以进行参考的流水线操作图" class="headerlink" title="在网上搜索到的可以进行参考的流水线操作图"></a>在网上搜索到的可以进行参考的流水线操作图</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230929223505.png"                      alt="image.png"                ></p><p>[[CourseNotes&#x2F;计算机体系结构&#x2F;CA-Lab-1-Requirements]]</p><p>原某给的图：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231006201800.png"                      alt="image.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231008140956.png"                      alt="image.png"                ></p><p>现在出现的问题是，第一个读取的内容不是我想要的内容或者说是这个01出现的太早了</p><p>另一个问题是再wen的部分里面为什么会有wen&#x3D;0的情况</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Lab-1-Requirements</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Lab-1-Requirements/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Lab-1-Requirements/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机体系结构]]# 1. 实验一：流水线处理器 — CA-Labs 1.0.0 文档<p><a class="link"   href="https://hit-coa.gitlab.io/archlab/labs/lab1.html" >https://hit-coa.gitlab.io/archlab/labs/lab1.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><ul><li>掌握 Vivado 集成开发环境</li><li>掌握 Verilog 语言</li><li>掌握 FPGA 编程方法及硬件调试手段</li><li>深刻理解流水线型处理器结构和数据冲突解决技术的工作原理</li></ul><h2 id="1-2-实验环境"><a href="#1-2-实验环境" class="headerlink" title="1.2. 实验环境"></a>1.2. 实验环境</h2><ul><li>Vivado 集成开发环境和龙芯 Artix-7 实验平台</li></ul><h2 id="1-3-实验内容"><a href="#1-3-实验内容" class="headerlink" title="1.3. 实验内容"></a>1.3. 实验内容</h2><ul><li>根据本课程所讲的设计思想，在单周期 CPU 的基础上，设计并实现一个具有五段流水线处理器，并通过暂停和定向（或者说旁路）技术来解决流水线中出现的数据冲突，要求该处理器可以<strong>通过所提供的自动测试环境</strong>。</li></ul><h3 id="1-3-1-流水线处理器的周期划分"><a href="#1-3-1-流水线处理器的周期划分" class="headerlink" title="1.3.1. 流水线处理器的周期划分"></a>1.3.1. 流水线处理器的周期划分</h3><p>与单周期处理器不同，流水线型处理器将“工作”划分为多个流水段来完成一条指令。每个时钟周期对应于流水线的一个阶段。流水线型处理器结构的主要优点是它可以并行执行多个指令：在同一时刻，多个指令可以同时存在于流水线中不同的阶段。在本实验中，流水线划分为五个周期。每个流水段产生的结果都在相应的时钟周期时传递给下一个流水段。</p><h3 id="1-3-2-数据冲突的处理"><a href="#1-3-2-数据冲突的处理" class="headerlink" title="1.3.2. 数据冲突的处理"></a>1.3.2. 数据冲突的处理</h3><p>参照参考书（王志英等著）第3章的3.3.2小节，采用暂停和定向技术来处理流水线中出现的数据冲突。</p><h3 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h3><p>当检测到数据冲突，通过暂停来阻止即将进入流水线中的指令。本实验中，暂停只能在必要时插入流水线。</p><h3 id="定向"><a href="#定向" class="headerlink" title="定向"></a>定向</h3><p>通过增加定向控制所需要的比较器、多路选择器和相关组合逻辑电路，实现对数据的重定向，解决数据冲突。</p><h2 id="1-4-实验要求"><a href="#1-4-实验要求" class="headerlink" title="1.4. 实验要求"></a>1.4. 实验要求</h2><p>按照以上要求将前置实验中所实现的单周期处理器改进成具有五段流水线处理器，并通过暂停和定向技术解决流水线中产生的数据冲突。</p><h3 id="1-4-1-实验预习"><a href="#1-4-1-实验预习" class="headerlink" title="1.4.1. 实验预习"></a>1.4.1. 实验预习</h3><p>在实验开始前给出处理器的设计方案，设计方案要求包括：</p><ul><li>流水线处理器结构设计框图及各段的寄存器文件描述</li><li>定向控制硬件的设计框图及功能描述</li></ul><h3 id="1-4-2-完成实验内容"><a href="#1-4-2-完成实验内容" class="headerlink" title="1.4.2. 完成实验内容"></a>1.4.2. 完成实验内容</h3><p><strong>Verilog 语言实现</strong>：要求采用结构化设计方法，用 Verilog 语言实现处理器的设计。设计包括：</p><ul><li>各模块的详细设计（包括各模块功能详述，设计方法，Verilog 语言实现等）</li><li>各模块的功能测试（每个模块作为一个部分，包括测试方案、测试过程和测试波形等）</li><li>系统的详细设计（包括系统功能详述，设计方法，Verilog 语言实现等）</li><li>系统的功能测试（包括系统整体功能的测试方案、测试过程和测试波形等）</li></ul><p><strong>FPGA 编程下载</strong>：将比特流下载到 Artix-7 实验板中。然后利用 Vivado 的上板调试功能观察 Artix-7 实验板的 FPGA 芯片中的实际运行，观察处理器内部运行状态，显式输出内部状态运行结果。</p><p><strong>对处理器进行功能测试，记录运行过程和结果，完成实验报告</strong>：对处理器进行功能测试，编写处理器功能测试程序，包括指令缓冲存储器和数据缓冲存储器完成处理器功能测试，并观察记录运行过程和结果，完成实验报告。</p><h2 id="1-5-处理器测试环境"><a href="#1-5-处理器测试环境" class="headerlink" title="1.5. 处理器测试环境"></a>1.5. 处理器测试环境</h2><p>要求同学们遵守实验测试环境的相应要求，不允许修改接口，不允许修改trace文件。</p><h3 id="1-5-1-测试用例"><a href="#1-5-1-测试用例" class="headerlink" title="1.5.1. 测试用例"></a>1.5.1. 测试用例</h3><p>我们提供三个测试用例对 CPU 进行测试：</p><ul><li>基础验收指令：存在数据冲突，需要在分析指令间存在的冲突后，手动向指令缓冲存储器中存在冲突的两条指令之间增加气泡（空指令）以避免冲突。</li><li>附加验收指令1：存在数据冲突，需要使用暂停和定向等技术解决数据冲突，不允许修改指令缓冲存储器文件的内容。</li><li>附加验收指令2：存在数据冲突，需要使用暂停和定向等技术解决数据冲突，不允许修改指令缓冲存储器文件的内容。</li></ul><p>备注</p><ul><li>MIPS的<code>nop</code>编码为全0，对应我们未实现的移位指令<code>sll $0, $0, 0</code>，保证你的设计在执行这条指令时，不写寄存器，PC正常+4即可。</li><li>要求 CPU 设计能够通过全部三个用例的仿真测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Homework6</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Homework6/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Homework6/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><p>1， RAID有哪些分级，各有什么特点？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231113143244577.png"                      alt="image-20231113143244577"                ></p><ol start="2"><li>什么是通道？简述通道完成一次数据传输的主要过程</li></ol><p>通道方式比 DMA 方式功能更强,可以进一步地减轻 CPU 的负担。在大型计算机系统中,外设的台数一般比较多,设备的种类、工作方式和工作速度的差别也比较大,通道技术可以把 CPU 从对外设的管理工作中解放出来。通道可以分担全部或大部分的 I&#x2F;O 工作，这样就能充分地发挥 CPU 的计算潜力。</p><p>(1) 在用户程序中使用访管指令进入管理程序,由管理程序组织一个通道程序,并启动通道。<br>(2) 通道执行 CPU 为它组织的通道程序,完成指定的数据 I&#x2F;O 工作。<br>(3) 通道程序结束后向 CPU 发中断请求。<br>CPU 执行用户程序和管理程序,通道执行通道程序的时间关系如图 6.3 所示。在用户程序中通过调用通道来完成一次数据输入&#x2F;输出的过程如图 6.4 所示。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231113143737652.png"                      alt="image-20231113143737652" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231113143752230.png"                      alt="image-20231113143752230" style="zoom:50%;"                 ><p>当通道程序结束后向 CPU 发中断请求。CPU 响应这个中断请求后,第二次进入管态，调用管理程序对 I&#x2F;0 中断请求进行处理。如果是正常结束,管理程序进行必要的登记等工作;如果是故障、错误等异常情况,则进行异常处理。然后,CPU 返回目态。</p><ol start="3"><li>在有Cache的计算机系统中，进行I&#x2F;O操作的时候，会产生哪些数据不一致的问题？怎么克服？</li></ol><p>数据不一致问题有两个方面。<br>(1) 存储器中可能不是 CPU 产生的最新数据,所以 I&#x2F;0 系统从存储器中取出来使用的是陈旧数据。<br>(2) I&#x2F;0 与存储器交换数据之后,在 Cache 中被 CPU 使用的可能就是陈旧数据</p><p>解决一致性问题的方法列举如下。<br>(1) 写直达 Cache 可以保证存储器和 Cache 有相同的数据<br>(2)写回 Cache 则需操作系统帮助进行数据检查。<br>(3) 根据 I&#x2F;O 使用的存储器地址来清除 Cache 相应的块,确保 I&#x2F;O 使用的数据不在Cache 中。<br>(4) 地址检查过程也可以使用硬件完成。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-IO</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-IO/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-IO/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><h1 id="I-O系统的可靠性-可用性和可信性"><a href="#I-O系统的可靠性-可用性和可信性" class="headerlink" title="I&#x2F;O系统的可靠性&#x2F;可用性和可信性"></a>I&#x2F;O系统的可靠性&#x2F;可用性和可信性</h1><p>容易混淆的术语</p><p>故障 错误和失效</p><p>故障分类</p><p>瞬时性&#x2F;间歇性&#x2F;永久性</p><p>故障产生的原因</p><p>外设可靠性能的参数有： 可靠性，可用性，可信性</p><p><strong>系统的可靠性</strong>：系统从某个初始参考点开始一直连续提供服务的能力</p><p>平均无故障时间MTTF来衡量</p><p>其倒数就是系统的失效率</p><p>系统整体失效率</p><p>系统的可用性: 系统正常工作的时间在连续两次服务间隔中所占的比例</p><p><strong>平均失效间隔时间MTBF</strong> Mean Tume Between Failure</p><p>系统的可用性：服务的质量，也就是在多大程度上可以合理的认为服务是可靠的</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Homework5/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Homework5/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><p>试评估路预测Cache 优化方法的效果。假设 32KB 的2 路组相联单体LI 数据Cache是CPU 中影响主频的关键部件，其失效率为0.56%。现使用一个 16KB 直接映像具有 85%预测成功率的 Cache 来替换它以改进性能，其失效率为 1.59%，路预测 Cache预测失败时需要花费额外的 1 个时钟周期才能命中，比较原 Cache，采用路预测 Cache可使CPU主频提高1倍。失效开销不变，为20个原系统周期。<br>(1)原Cache和路预测 Cache的平均访存时间比值是多少?<br>(2)由于访存取指通常具有更好的局部性，所以路预测经常用于指令Cache 中。假设要将路预测机制用于数据 Cahe，其预测命中率为 85%，且访存的后续指令(其他数据访存、相关操作等) 按照假设预测结果正确的方式流出，若实际预测失败，则需要流水线清空和陷入等操作，需要15个周期。试评估数据 Cache 采用此种机制是否合适?</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231113144812.png"                      alt="image.png"                ></p><p>假设对指令 Cache 的访问占全部访问的 75%，而对数据 Cache 的访问占全部访问的25%。Cache的命中时间为1个时钟周期,失效开销为 50个时钟周期,在混合 Cache中一次 Load或Store操作访问Cache 的命中时间都要增加一个时钟周期，32KB的指令Cache的失效率为0.39%，32KB的数据Cache的失效率为4.82%，64KB的混合Cache的失效率为 1.35%。又假设采用写直达策略，且有一个写缓冲器，并且忽略写缓冲器引起的等待。试问指令Cache 和数据 Cache 容量均为 32KB 的分离 Cache 和容量为64KB的混合 Cache 相比，哪种 Cache 的失效率更低?两种情况下平均访存时间各是多少?</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231113144845.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Chapter4Homework</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Chapter4Homework/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Chapter4Homework/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><ol><li>根据需要展开下面的循环并进行指令调度，直到没有任何延迟。指令的延迟如表4.2所示。</li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOOP:LD    F0,0(R1)</span><br><span class="line"> MULTD F0,F0,F2</span><br><span class="line"> LD    F4,0(R2)</span><br><span class="line"> ADDD  F0,F0,F4</span><br><span class="line"> SD    0(R2),F0</span><br><span class="line"> SUBI  R1,R1,8</span><br><span class="line"> SUBI  R2,R2,8</span><br><span class="line"> BNEQZ R1,LOOP</span><br></pre></td></tr></table></figure></div><ol start="2"><li><p>假设有一个长流水线，仅仅对条件转移指令使用分支指令缓冲。假设分支预测错误的开销为4个周期，缓冲不命中的开销为3个周期。假设：命中率为90%，预测精度为90%，分支频率为15%，没有分支的基本CPI为1.</p><ol><li>求程序执行的CPI</li><li>相对于采用固定的两个周期延迟的分支处理，哪种方法程序执行的速度更快？</li></ol></li><li><p>下面一段 MIPS的汇编程序称为 SAXPY，是计算高斯消去法中的关键一步，用于完成下面公式的计算:<br> $Y &#x3D; aX+ Y$<br> 其浮点指令延迟如表 4.2 所示，整数指令均为1个时钟周期完成，浮点和整数部件均为流水。整数操作之间以及与其他所有浮点操作之间的延迟为0,转移指令的延迟为0</p></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">foo:ld     f2,0(r1) ; load X[i]</span><br><span class="line">multd  f4,f2,f0 ; multiply a*X[i]</span><br><span class="line">ld     f6,0(r2) ; load Y[i]</span><br><span class="line">addd   f6,f4,f6 ; add a*X[i] + Y[i]</span><br><span class="line">sd     0[r2],f6 ; store Y[i]</span><br><span class="line">addi   r1,r1,#8 ; increment X index</span><br><span class="line">addi   r2,r2,#8 ; increment Y index</span><br><span class="line">sgti   r3,r1,done ; test if done</span><br><span class="line">beqz   r3,foo   ; loop if not done</span><br></pre></td></tr></table></figure></div><p>(1)对于标准的MIPS单流水线，SAXPY 循环计算一个Y值需要多少时间?其中有多少空转周期?</p><p>(2)对于标准的 MIPS 单流水线，将 SAXPY 循环顺序展开4 次，不进行任何指令调度，计算一个Y值平均需要多少时间?加速比是多少?其加速是如何获得的?</p><p>(3)对于标准的 MIPS 单流水线，将SAXPY 循环顺序展开4 次，优化和调度指令。使SAXPY 循环处理时间达到最优，计算一个 Y值平均需要多少时间?加速比是多少?<br>(4)对于采用如图4.15 所示的前瞻执行机制的MIPS处理器，处理器中只有一个整数部件。当循环第二次执行到</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beqzr3，foo</span><br></pre></td></tr></table></figure></div><p>时，写出前面所有指令的状态，包括指令使用的保留站、指令起始节拍、执行节拍和写结果节拍，并写出处理器当前的状态。</p><p>(5)对于两路超标量的 MIPS 流水线，设有两个指流出部件，可以流出任意组合的指令，系统中的功能部件数量不受限制。将 SAXPY 循环展开 4 次，优化和调度指令使SAXPY 循环处理时间达到最优。计算一个Y值平均需要多少时间?加速比是多少?</p><p>(6)对于图4.19 结构的超长指令字 MIPS处理器，将SAXPY 循环展开4 次，优化和调度指令，使SAXPY 循环处理时间达到最优。计算一个Y值平均需要多少时间?加速比是多少?</p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-CPU性能公式</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-CPU%E6%80%A7%E8%83%BD%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-CPU%E6%80%A7%E8%83%BD%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head><h2 id="CPU性能公式"><a href="#CPU性能公式" class="headerlink" title="CPU性能公式"></a>CPU性能公式</h2><p>先用比较指令作比较，先用第一条的比较结果来进行分支进行。</p><p>一个分支变成了两个部分去做，这会带来的影响。</p><p>同样的一套程序，指令的设计就是不一样的。</p><h3 id="CPU-A"><a href="#CPU-A" class="headerlink" title="CPU A"></a>CPU A</h3><p>60% 其他指令<br>20% 比较指令<br>20% 测试分支</p><h3 id="CPU-B"><a href="#CPU-B" class="headerlink" title="CPU B"></a>CPU B</h3><p>测试分支更多</p><p>$IC_B&#x3D;0.8IC_A$</p><p>$T_{clkB}&#x3D;1.25T_{clkA}$</p><p>复合计算之后：</p><p>$T_{CPUA} &#x3D; 1.2 \times IC_{A} \times T_{clkA}$</p><p>$T_{CPUB} &#x3D; 1.25 \times IC_{A} \times T_{clkA}$</p><p>就可以用这个公式来表示量化分析的思想</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>讨论体系结构的基本概念</p><ul><li>经典计算机体系结构概念</li><li>计算机系统层次结构概念</li><li>计算机组成和计算机实现技术</li><li>现代计算机体系结构所研究的范围和内容</li></ul><p>计算机体系结构的发展</p><ul><li>大概率事件优先原则</li></ul><p>并行性技术提高计算机性能</p><ul><li>并行性技术的基本概念</li><li>时间重叠等</li></ul><p>影响体系结构设计的成本和价格因素</p><p>定量分析技术</p><ul><li>大概率分析原则</li><li>啊木代尔定律</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CA-Chapter3Homework</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Chapter3Homework/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CA-Chapter3Homework/</url>
      
        <content type="html"><![CDATA[<p>[[CA-NotesView]]</p><ol><li><strong>简述流水线技术的特点</strong></li></ol><p><em>流水线技术的特点是将一个处理过程分解为若干个子过程，并由专门的功能部件来实现。这样可以将一个大的处理功能部件分解为多个独立的功能部件，并依靠它们的并行工作来提高处理的吞吐率。流水线中各个子过程的时间应尽可能相等，以避免引起流水线的堵塞和断流。</em></p><ol start="2"><li><strong>简述通过软件（编译器）来减少分支延迟的三种方法。这些方法的特点是什么？</strong></li></ol><p><em>通过软件（编译器）来减少分支延迟的三种方法是：</em></p><p><em>1. 静态预测：编译器在编译阶段对代码分支进行预测，根据预测的结果进行代码优化。如果预测成功，执行正确的代码路径；如果预测失败，采取紧急措施来最小化预测失败的影响。静态预测的特点是在编译时就确定了分支的走向，适用于分支预测比较简单的情况。</em></p><p><em>2. 动态预测：编译器在运行时根据程序的执行情况动态地预测分支的结果。动态预测可以根据历史的执行情况和统计数据来进行预测，提高预测的准确性。动态预测的特点是能够根据程序的实际执行情况来优化分支，适用于分支预测较为复杂、难以静态确定的情况</em>。</p><p><em>3. 分支延迟：通过将分支的执行延迟到后续代码执行阶段来减少分支延迟。编译器将分支的计算和分支的结果保存到其他寄存器中，延迟执行分支的代码，以便尽可能多地执行其他指令。分支延迟的特点是通过重排指令的执行顺序来减少分支造成的延迟，适用于无法准确预测分支结果的情况。</em><br> <em>这些方法的特点是：静态预测在编译时预测分支走向，动态预测在运行时根据实际情况预测分支走向，分支延迟通过重排指令来减少分支延迟。静态预测适合简单的分支预测，动态预测适合复杂的分支预测，分支延迟适合无法准确预测分支结果的情况。这些方法都旨在减少分支延迟，提高程序的执行效率和性能。</em></p><ol start="3"><li><strong>简述延迟分支方法的三种调度策略的优缺点</strong></li></ol><p><em>三种调度策略包括：静态延迟分支、动态延迟分支和退化延迟分支。</em></p><ol><li>静态延迟分支：</li></ol><p>优点：在编译期间确定分支目标，可以利用编译器的静态分析技术进行优化，减少分支预测错误的概率。</p><p>缺点：无法适应程序运行时动态变化的分支行为，对于复杂的分支结构预测效果不佳。</p><ol start="2"><li>动态延迟分支：</li></ol><p>优点：根据程序在运行时的分支行为动态地进行分支目标的预测，可以适应程序运行时的变化，提高分支预测准确率。</p><p>缺点：预测分支目标需要额外的硬件支持，增加了成本和功耗，并且预测错误时会带来额外的处理开销。</p><ol start="3"><li>退化延迟分支：</li></ol><p>优点：降低了对分支预测的依赖，通过将分支延迟到后面的指令中执行来避免预测失败的开销。</p><p>缺点：不能适应高度动态的分支行为，指令执行顺序被限制，可能导致性能损失，特别是在分支频繁的情况下。</p><ol start="4"><li><strong>在一条流水线多操作部件的处理机上执行下面的程序，取指令、指令译码各自需要一个时钟周期，MOVE&#x2F;ADD&#x2F;MUL操作个需要2个，3个和4个时钟周期。每个操作都在第一个时钟周期从通用寄存器种读取操作数，在最后一个时钟周期把运算的结果写到通用寄存器中。</strong></li></ol><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">K:   MOVE R1,R0 // R1 &lt;- (R0)</span><br><span class="line">K+1: MUL R0,R2,R1 </span><br><span class="line">K+2: ADD R0,R3,R2</span><br></pre></td></tr></table></figure></div><p><strong>画出指令执行的流水线时空图，并计算执行完三条指令共使用了多少个时钟周期</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-随机访问MAC协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="多路访问控制-MAC-协议"><a href="#多路访问控制-MAC-协议" class="headerlink" title="多路访问控制(MAC)协议"></a>多路访问控制(MAC)协议</h2><p>两类的链路：</p><ul><li>点对点链路：<ol><li>拨号接入的PPP</li><li>以太网交换机和主机之间的点对点链路</li></ol></li><li>广播链路（共享介质）<ol><li>早期的总线以太网</li><li>HFC的上行链路</li><li>802.11无线局域网</li></ol></li></ul><p>单一共享广播信道</p><p>两个或者两个以上的结点同时传输：干扰(interface)</p><p><strong>冲突</strong></p><p>结点同时接收到两个或者多个信号 $\to$ 接收失败！</p><h3 id="多路访问控制协议"><a href="#多路访问控制协议" class="headerlink" title="多路访问控制协议"></a>多路访问控制协议</h3><p>采用分布式算法决定结点怎么共享信道，也就是决策结点什么时候可以传输数据</p><p>必须基于信道本身，通信信道共享协调信息！</p><h2 id="理想的MAC协议"><a href="#理想的MAC协议" class="headerlink" title="理想的MAC协议"></a>理想的MAC协议</h2><p><strong>给定</strong>：速率为Rbos的广播信道</p><p><strong>期望</strong>：</p><ol><li>如果只有一个结点：R</li><li>M个结点发送：R&#x2F;M</li><li>完全分散控制：<ol><li>不用特定协调</li><li>不用时钟，时隙同步</li></ol></li><li>简单</li></ol><h2 id="MAC协议的分类"><a href="#MAC协议的分类" class="headerlink" title="MAC协议的分类"></a>MAC协议的分类</h2><p>三大类：</p><h3 id="信道划分MAC协议"><a href="#信道划分MAC协议" class="headerlink" title="信道划分MAC协议"></a>信道划分MAC协议</h3><p>多路复用技术</p><p>TDMA、FDMA、CDMA、WDMA等</p><h3 id="随机访问MAC协议"><a href="#随机访问MAC协议" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h3><p>信道不划分，允许冲突</p><p>冲突的恢复机制</p><h3 id="轮转协议"><a href="#轮转协议" class="headerlink" title="轮转协议"></a>轮转协议</h3><p>结点轮流使用信道</p><h2 id="信道划分MAC协议：TDMA、FDMA"><a href="#信道划分MAC协议：TDMA、FDMA" class="headerlink" title="信道划分MAC协议：TDMA、FDMA"></a>信道划分MAC协议：TDMA、FDMA</h2><p>time division multiple access</p><p>周期性的使用信道</p><p>每个站点在每个周期占用固定长度的时隙</p><p>未用的时隙空间</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101192728.png"                      alt="image.png"                ></p><p>同理：FDMA (frequency division multiple access)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101192815.png"                      alt="image.png"                ></p><p>网络资源</p><h2 id="随机访问MAC协议-1"><a href="#随机访问MAC协议-1" class="headerlink" title="随机访问MAC协议"></a>随机访问MAC协议</h2><p>当结点要发送分组的时候：</p><ul><li>利用信道全部数据速率R发送分组</li><li>没有实现的结点协调</li></ul><p>两个或者多个结点同时传输 ： 冲突</p><p><strong>随机访问MAC协议</strong>需要定义：</p><ul><li><p>如何检测冲突</p></li><li><p>如何从冲突中恢复（延迟重传）</p></li></ul><p>典型的随机访问MAC协议：</p><p>ALOHA CSMA&#x2F;CA 等</p><h2 id="时隙ALOHA协议"><a href="#时隙ALOHA协议" class="headerlink" title="时隙ALOHA协议"></a>时隙ALOHA协议</h2><p><strong>假定</strong>：</p><p>所有帧的大小相同<br>时间被划分为等长度的时隙<br>结点只能在时隙的开始时刻发送帧<br>结点之间时钟同步<br>如果两个或者两个以上的结点在同一个时隙发送帧，节点就检测到冲突</p><p><strong>运行</strong>：</p><p>当结点有新的帧的时候，在下一个时隙(slot)发送<br><u>如果冲突</u> 以概率p重传这个帧</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101193527.png"                      alt="image.png"                ></p><p><strong>优点</strong>:<br>单个结点活动时，可以连续以信道全部速率传输数据<br>高度分散化: 只需同步时隙<br>简单</p><p><strong>缺点</strong>:<br>冲突，浪费时隙<br>空闲时隙<br>结点也许能以远小于分组传输时间检测到冲突</p><p><strong>效率</strong>：成功发送帧的时隙占的比例</p><p>假设：N个结点有很多的帧需要传输，每个结点在每个时隙均以概率p发送数据</p><p><strong>效率</strong>：最大的效率为0.37</p><h3 id="纯ALOHA协议"><a href="#纯ALOHA协议" class="headerlink" title="纯ALOHA协议"></a>纯ALOHA协议</h3><p>更简单，不用时钟同步</p><p>当有新的数据帧构成的时候立刻发送数据帧</p><ul><li>立即发送</li></ul><p>冲突的可能性增大</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101194041.png"                      alt="image.png"                ></p><p>比时隙ALOHA协议更差，效率为0.18</p><h2 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h2><p>载波监听多路访问协议</p><p>发送帧之前，监听信道(载波)：</p><ul><li><p>信道空闲：发送完整帧</p></li><li><p>信道忙：推迟发送</p><ul><li>1-坚持CSMA</li><li>非坚持CSMA</li><li>P-坚持CSMA</li></ul></li></ul><p><strong>冲突可能仍然发生</strong>：信号传播延迟</p><p>继续发送冲突帧：浪费信道资源</p><h2 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h2><p>带有冲突检测的载波多路访问协议</p><p>短时间内内可以检测到冲突</p><p>冲突之后传输中止，减少信道的浪费</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101195328.png"                      alt="image.png"                ></p><p>冲突检测：</p><ul><li>有线局域网易于实现：测量信号强度，比较发送信号和接收信号</li><li>无线局域网很难实现：接收信号强度淹没在本地发射信号强度下</li></ul><p>“边发边听，不发不听”</p><h2 id="CSMA-CD协议-1"><a href="#CSMA-CD协议-1" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101200020.png"                      alt="image.png"                ></p><p>在一个采用CSMA&#x2F;CD协议的网络中，传输介质是一根完整的电缆，传输速率为1 Gbps，电缆中的信号传播速度是200 000 km&#x2F;s。若最小数据帧长度减少800比特，则最远的两个站点之间的距离至少需要减少</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101200343.png"                      alt="image.png"                ></p><p>$T_{prop} &#x3D; LAN中两个结点之间的最大传播延迟$</p><p>$t_{trans} &#x3D; 最长帧传输延迟$</p><p>$效率 &#x3D; \frac{1}{1+5 t_{prop}&#x2F;t_{trans}}$</p><p>远优于ALOHA并且简单分散</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-轮转访问MAC协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%BD%AE%E8%BD%AC%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%BD%AE%E8%BD%AC%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>信道划分MAC协议：</p><ul><li><p>网络负载重的时候，共享信道的效率高，而且公平</p></li><li><p>网络负载轻的时候，信道的效率低！</p></li></ul><p>随机访问MAC协议：</p><ul><li><p>网络负载重的时候产生冲突开销</p></li><li><p>网络负载轻的时候，产生冲突开销</p></li></ul><p>轮转访问MAC协议：</p><ul><li>综合两者的优点！</li></ul><h2 id="轮询-polling"><a href="#轮询-polling" class="headerlink" title="轮询(polling)"></a>轮询(polling)</h2><p>主节点轮流的“邀请”从属结点发送数据</p><p>典型应用：“哑”从属设备</p><p>问题：</p><ul><li>轮询开销</li><li>等待延迟</li><li>单点故障</li></ul><h2 id="令牌传递"><a href="#令牌传递" class="headerlink" title="令牌传递"></a>令牌传递</h2><p>控制令牌依次从一个结点传递到下一个结点</p><p>令牌：<strong>特殊帧</strong></p><p>令牌网络会构成环形网络</p><p>问题：</p><ul><li><p>令牌的开销</p></li><li><p>等待延迟</p></li><li><p>单点故障问题</p></li></ul><h2 id="MAC协议总结"><a href="#MAC协议总结" class="headerlink" title="MAC协议总结"></a>MAC协议总结</h2><p>信道划分MAC协议：TDMA、FDMA、CDMA<br>随机访问MAC协议：ALOHA,S-ALOHA，CSMA&#x2F;CD,CSMA&#x2F;CA<br>轮转访问MAC协议：<br>主结点轮询：令牌传递<br>蓝牙&#x2F;FDDI</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-链路状态路由算法</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>链路状态路由算法</p><h2 id="网络抽象：图"><a href="#网络抽象：图" class="headerlink" title="网络抽象：图"></a>网络抽象：图</h2><p>图： G &#x3D; （N，E）</p><h2 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h2><p><em><strong>Dijstra算法</strong></em></p><p>所有节点（路由器）掌握网络拓扑和链路费用</p><p>要求每一个路由器都构造一个链路状态分组，并广播出去</p><ul><li>通过“链路状态广播”</li></ul><p>链路状态路由算法里面利用扩散或者泛洪的方法来进行发送</p><p>任何一个路由器都会收集全了所有路由器的链路状态分组</p><ul><li>所有节点拥有相同信息</li></ul><p>计算从一个节点（“源”）到达所有其他节点的最短路径</p><ul><li>获得该节点的传发表</li></ul><p>迭代：k次迭代之后，得到到达k个目的节点的最短路径</p><p><em><strong>符号</strong></em></p><p>c(x,y):结点x到结点y链路费用；如果x和y不直接相连，则为无穷大</p><p>D(v): 从源到目的v的当前路径费用值</p><p>p(v): 沿从源到v的当前路径，v的前序节点</p><p>N‘ ：已经找到费用最小路径的结点集合</p><p>Dijstra 算法：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化</span><br><span class="line">N’ = &#123;u&#125;</span><br><span class="line">for 所有结点</span><br><span class="line">if v和u相邻</span><br><span class="line">then D(v) = c(u,v)</span><br><span class="line">else D(v) = 无穷</span><br><span class="line"></span><br><span class="line">Loop </span><br><span class="line">找出不再N’中的w，满足D（w）最小</span><br><span class="line">将w加入N‘</span><br><span class="line">更新w的所有不在N’中的邻居v的D（v）:</span><br><span class="line">D(v) = min(D(v),D(w) + c(w,v))</span><br><span class="line">//已知的到达w的最短路径费用加上w到v的费用</span><br><span class="line">until 所有的结点都在N‘中了</span><br></pre></td></tr></table></figure></div><p>u 的最终最短路径树：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022143149.png"                      alt="image.png"                ></p><p>u 的最终转发表：</p><p>根据上面的内容进行计算最终转发表</p><h2 id="Dijstra-算法"><a href="#Dijstra-算法" class="headerlink" title="Dijstra 算法"></a>Dijstra 算法</h2><p>算法复杂性： O($n^2$)</p><p>每一次迭代：需要检测所有不在结合N’中的结点<br>n(n+1)&#x2F;2次的比较：O($n^2$)<br>更高效的实现：O(nlogn)</p><p>存在震荡的可能：<br>假设链路费用是该链路承载的通信量</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022143800.png"                      alt="image.png"                ></p><p>很有可能导致数据包在DCB之间反复震荡无法传送到A，最终会因为TTL被丢弃。</p><p>所以会使用一些机制来避免这样的情况</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-路由器的工作原理</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>网络层的<strong>转发功能</strong></p><p>简要的转发问题：编址和&#x3D;&#x3D;最长前缀匹配问题&#x3D;&#x3D;</p><p>关键术语： 转发、交换</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231012120717.png"                      alt="image.png" style="zoom:67%;"                 >转发功能通常称为**路由器转发平面**<p>数据报流水线必须以N倍速率运行</p><p><strong>路由器控制平面</strong>通常用软件实现并在路由选择处理器上执行</p><p>最重要的路由器部件：入口路和入口站 $\to$ 输入端口</p><p>环形交叉路 $\to$ 交换结构</p><p>环状交叉路出口 $\to$ 输出端口</p><p>Q：</p><ol><li>车站服务人员很慢会发生什么情况？（查询速度慢）</li><li>服务人员必须要多快才能确保在入口路上没有车辆拥堵？（查询速度的最低值）</li><li>对于极快的服务人员，如果汽车在环状交叉路上开的很慢将会发生什么情况？（交换结构内数据传输慢）</li><li>如果大多数进入的汽车都要在相同的出口离开会发生什么情况？（拥塞控制）</li><li>如果要为不同的汽车分配优先权，或者阻挡某些汽车进入环状交叉路，应该怎么运行？（如何让数据报有控制的进行转发）</li></ol><h2 id="路由器的输入端口"><a href="#路由器的输入端口" class="headerlink" title="路由器的输入端口"></a>路由器的输入端口</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231012123351.png"                      alt="image.png" style="zoom: 80%;"                 >查找 **根据转发表**<p>TCAM <strong>三态内容可寻址存储器</strong></p><p>确定了输出端口之后分组就能够发送进入交换结构。如果正在使用交换结构就会被阻塞。因此需要在输入端口的位置排队。</p><p>必须采取的动作：</p><ol><li>物理层和链路层处理</li><li>检查分组的版本号、检验和</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-路由和转发</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%92%8C%E8%BD%AC%E5%8F%91/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%92%8C%E8%BD%AC%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h2><p>路由算法（协议）确定去往目的网络的最佳路径</p><p>转发表确定在本路由器如何转发分组</p><h2 id="网络抽象：图"><a href="#网络抽象：图" class="headerlink" title="网络抽象：图"></a>网络抽象：图</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022135040.png"                      alt="image.png"                ></p><p>图：G &#x3D; （N,E）<br>N &#x3D; 路由器集合 &#x3D; {u,v,w,x,y,z}<br>E &#x3D; 链路集合 &#x3D; {(u,v),(u,x)}</p><p>图的抽象在网络领域很广泛</p><p>N是peers集合，E是TCP的集合</p><h2 id="图抽象：费用（Costs）"><a href="#图抽象：费用（Costs）" class="headerlink" title="图抽象：费用（Costs）"></a>图抽象：费用（Costs）</h2><p>c(x,x’)链路(x,x’)的费用</p><p>e.g c(w,z) &#x3D; 5</p><p>每段链路的费用可以总是1，描述一个链路或者路径的大小的时候称为段数；或者是，带宽的倒数、拥塞程度等。</p><p>路径费用：(x1,x2,x3,,,xp) &#x3D; c(x1,x2) + c(x2,x3) + … + c(xp-1,xp)</p><blockquote><p>[!关键问题]<br>源到目的的最小费用的路径是什么？</p></blockquote><p><strong>路由算法</strong>：在网络的抽象图中寻找最小路径的算法</p><h2 id="路由算法分类"><a href="#路由算法分类" class="headerlink" title="路由算法分类"></a>路由算法分类</h2><h3 id="静态路由-vs-动态路由？"><a href="#静态路由-vs-动态路由？" class="headerlink" title="静态路由 vs 动态路由？"></a>静态路由 vs 动态路由？</h3><p>静态路由：</p><ul><li><p>手工配置</p></li><li><p>路由更新的速度慢</p></li><li><p>优先级高（<strong>在路由信息中同等条件下首选</strong>）</p></li></ul><p>动态路由：</p><ul><li><p>路由更新快</p><ul><li><p>定期更新</p></li><li><p>及时响应链路费用或者网络拓扑变化</p></li></ul></li></ul><h3 id="全局信息-vs-分散信息？"><a href="#全局信息-vs-分散信息？" class="headerlink" title="全局信息 vs 分散信息？"></a>全局信息 vs 分散信息？</h3><p>全局信息：所有路由器掌握完整的网络拓扑和链路费用信息</p><p>e.g. 链路状态(LS)路由算法</p><p>分散信息（decentralized）:</p><p>路由器只掌握物理项链的邻居以及链路费用</p><p>链路之间信息交换、运算的迭代过程</p><p>e.g. 距离向量9(DV)路由算法</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-距离向量路由算法</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="距离向量-Distance-Vector-路由算法"><a href="#距离向量-Distance-Vector-路由算法" class="headerlink" title="距离向量(Distance Vector)路由算法"></a>距离向量(Distance Vector)路由算法</h2><p>Bellman-Ford方程(动态规划)</p><p>令：dx(y):从x到y最短路径的费用(距离)</p><p>dx(y) &#x3D; min {c(x,y) + dv(y)}</p><p><code>c(x,y)</code> 代表的是x到邻居v的费用</p><p><code>dv(y)</code> 代表从邻居v到达目的y的费用（距离）</p><p>在x的所有邻居v中取最小值</p><h2 id="Bellman-Ford举例"><a href="#Bellman-Ford举例" class="headerlink" title="Bellman-Ford举例"></a>Bellman-Ford举例</h2><p><strong>重点</strong>结点获得最短路径的下一跳，该信息用于转发表中。</p><h2 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h2><p>$D_x(y)$ &#x3D; 从节点x到结点y的最小费用估计</p><ul><li>维护距离向量（DV) : $D_x &#x3D; [D_x(y): y \in N]$</li></ul><p>结点x：</p><ul><li>已知到达每个邻居的费用：c(x,y)</li><li>维护其所有邻居的距离向量: $D_v$ &#x3D; $D_v(y) : y \in N$</li></ul><p>核心思想：</p><ul><li>每个结点不定时的将其自身的DV估计发送给其邻居</li><li>x当收到另据的新的DV估计的时候，根据B-F方程来更新自身的距离向量估计</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022144901.png"                      alt="image.png"                ></p><p>将最终收敛于实际的最小费用</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h3><p>引发每次局部迭代的因素</p><ul><li>局部链路费用改变</li><li>来自邻居的DV更新</li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>每个结点只当DV变化的时候才通告给邻居</p><p>邻居在必要的时候（其DV更新后发生改变）</p><ul><li>邻居在必要的时候(其DV更新后发生改变)再通告它们的邻居</li></ul><h3 id="每个节点："><a href="#每个节点：" class="headerlink" title="每个节点："></a>每个节点：</h3><p><strong>等待</strong>本地局部链路费用变化或者收到邻居的DV的更新</p><p><strong>重新计算</strong>DV估计</p><p>如果DV中到达任一目的的距离发生改变，<strong>通告</strong>所有邻居</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022145726.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-距离向量链路算法2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%952/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%952/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>Bellman-Ford方程（动态规划）</p><p>令：</p><p>$d_x(y) &#x3D; min_distance(x \to y) &#x3D; min{c(x,v) + d_v(y)}$</p><p><code>c(x,v)</code> 代表的是x到v的费用</p><p><code>$dv(y)$</code> 从邻居v到目的y的费用</p><h2 id="Bellman-Ford举例"><a href="#Bellman-Ford举例" class="headerlink" title="Bellman-Ford举例"></a>Bellman-Ford举例</h2><p>显然：$d_v(z) &#x3D; 5,\ \ \ d_x &#x3D; 3,\ \ \ d_w(z)&#x3D;3$</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029203659.png"                      alt="image.png"                ></p><p>根据B-F方程：</p><p>$d_u(z) &#x3D; min {c(u,v) + d_v(z), \ \ c(u,x) + d_x(z), \ \ c(u,w) + d_w (z)} \ &#x3D; min{\ 2+5,\ 1+3,\ 5+3} &#x3D; 4$</p><p>重点: 结点获得最短路径的下一跳,该信息用于转发表中</p><h2 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h2><p>$D_x(y) &#x3D;$ 从结点x到结点y的最小费用估计</p><ul><li>x 维护距离向量(DV) ： $D_x &#x3D; [D_x(y): y \in N]$</li></ul><p>结点x:</p><ul><li>已知到达每个邻居的费用: c(x,y)</li><li>维护其所有邻居的距离向量：$D_v &#x3D; [D_v(y): y \in N]$</li></ul><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>每个结点不定时的把其自身的DV估计发送给其邻居</p><p>当接收到邻居的新的DV估计的时候，也就是根据B-F更新其自身的路由向量估计：</p><p>$D_x(y) \leftarrow min{c(x,y) \ + \ D_v(y)} \ for \ each \ node\  y \in N$</p><p>最后$D_x(y)$将会收敛到最小值。</p><h3 id="异步迭代"><a href="#异步迭代" class="headerlink" title="异步迭代"></a>异步迭代</h3><p>引发每次局部迭代的因素</p><ul><li>局部链路费用改变</li><li>来自邻居的DV更新</li></ul><h3 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h3><p>每个结点只有当DV变化的时候才通告邻居</p><ul><li>邻居在必要的时候再通告它们的邻居</li></ul><h3 id="每个节点的阶段："><a href="#每个节点的阶段：" class="headerlink" title="每个节点的阶段："></a>每个节点的阶段：</h3><p><strong>等待</strong>：每个路由器在没有发生变化的时候就保持这种状态（邻居DV没有发生更新）</p><p><strong>重新计算</strong> DV估计</p><p>如果DV中到达任一一个目的距离发生改变，<strong>通告</strong>所有的邻居</p><p>然后再次进入<strong>等待</strong>状态</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>初始的距离向量为：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029205246.png"                      alt="image.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029205707.png"                      alt="image.png"                ></p><h2 id="距离向量DV：链路费用变化"><a href="#距离向量DV：链路费用变化" class="headerlink" title="距离向量DV：链路费用变化"></a>距离向量DV：链路费用变化</h2><p><strong>链路费用的变化</strong>：</p><ul><li><p>结点检测本地链路费用的变化</p></li><li><p>更新路由信息，重新计算距离向量</p></li><li><p>如果DV改变，通告所有的邻居</p></li></ul><p>$t_0$ : y检测到链路费用的改变，更新DV，通告其邻居</p><p>$t_1$ : z收到y的DV更新，更新其距离向量表，计算到达x的最新最小费用，更新其DV，并发送其所有的邻居。</p><p>$t_2$ ：y收到z的DV更新，更新其距离向量表，重新计算y的DV，未发生改变，不再像z发送DV</p><p>“<strong>好消息传播的快</strong>”</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029214707.png"                      alt="image.png"                ></p><p>但是可能出现无穷计数问题（如上所示）</p><h3 id="毒性逆转"><a href="#毒性逆转" class="headerlink" title="毒性逆转"></a>毒性逆转</h3><p>如果一个结点(e.g.z)到达某目的(e.g.X)的最小费用路径是通过某个邻居(e.g.Y)，则:</p><ul><li>通告给该邻居结点到达该目的的距离为无穷大</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/d94597c651cb7c7656f0260d56b858d.jpg"                      alt="d94597c651cb7c7656f0260d56b858d.jpg"                ></p><p>毒性逆转是不是能够彻底的消除无穷计数问题？</p><p>简单的环路是可以消除的，更复杂的环境其实未必可以满足。</p><p><strong>定义最大的一个距离度量值(maximum metric)</strong></p><p>定义一个最大的有效费用值，比如15跳步，16跳步标识无穷</p><p>如果一直不可达，就会在有效费用值耗尽的时候结束传输</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-计算机网络分层结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>在计算机网络体系结构的各个层次里面，每个报文都分为两个部分：一是数据部分，SDU； 二是控制信息部分，即PCI；它们共同构成<code>PDU</code></p><p>数据服务单元（SDU）：为完成用户所要求的功能二应该传送的数据<br>协议控制单元（PCI）：控制协议操作的信息，第n层的协议控制信息记为n-PCI<br>协议数据单元（PDU）：对等层次之间传送的数据单位就是PDU。</p><p>物理层的PDU是<em>比特</em>，数据链路层的PDU是<em>帧</em>，网络层的PDU称为<em>分组</em>，传输层的PDU称为<em>报文段</em></p><h3 id="计算机网络协议、接口、服务的概念"><a href="#计算机网络协议、接口、服务的概念" class="headerlink" title="计算机网络协议、接口、服务的概念"></a>计算机网络协议、接口、服务的概念</h3><p>为进行网络中的数据交换而建立的规则、标准或者约定就成为<em>网络协议</em></p><p>同一结点内相邻两层之间的交换信息的连接点叫做<em>接口</em></p><p>SAP（服务访问点）是一个逻辑接口而不是物理接口</p><p><em>服务</em>是指下层为紧邻的上层提供的功能调用，它是垂直的。</p><p>协议和服务的概念是不一样的，协议的实现保证了服务，上层通过调用下层的服务构造协议。</p><p>并非在一层内完成的全部功能都称为服务，只有那些看得见的功能才能叫做服务。</p><p>提供的服务可以分为三类：</p><ol><li>面向连接服务和无连接服务<ol><li><strong>面向连接服务</strong>：必须先建立连接，分配相应的资源，传输结束之后会释放连接和所占用的资源。</li><li><strong>无连接服务</strong>：不需要先建立连接，发送数据的时候可以直接发送。</li></ol></li><li>可靠服务和不可靠服务<ol><li><strong>可靠服务</strong>：指的是网络具有纠错、检错、应答机制，能够保证数据正确、可靠的传送到目的地</li><li><strong>不可靠服务</strong>：尽量准确的可靠的传输，但是不能保证数据正确，是一种尽力而为的服务。</li></ol></li><li>有应答服务和无应答服务<ol><li><strong>有应答服务</strong>：接收方在收到数据后向发送方给出的应答</li><li><strong>无应答服务</strong>：指的是接收方收到数据之后不自动给出应答，如果要应答就用高层实现。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-计算机网络传输层</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 计算机网络传输层<h2 id="传输层服务概述"><a href="#传输层服务概述" class="headerlink" title="传输层服务概述"></a>传输层服务概述</h2><h3 id="传输层服务和协议"><a href="#传输层服务和协议" class="headerlink" title="传输层服务和协议"></a>传输层服务和协议</h3><p>传输层协议为运行在不同的host上的进程提供了一种<strong>逻辑通信机制</strong></p><p>端系统运行传输层协议</p><ul><li><p><strong>发送方</strong>：将应用递交的消息分成一个或者多个的Segment,并向下传递给网络层</p></li><li><p><strong>接收方</strong>：将接收到的Segment组装成消息，并上交给应用层</p></li></ul><p>传输层可以为应用提供<em><strong>多种协议</strong></em></p><ul><li><p>Internet上的TCP</p></li><li><p>Internet上的UDP</p></li></ul><h3 id="传输层-vs-网络层"><a href="#传输层-vs-网络层" class="headerlink" title="传输层 vs 网络层"></a>传输层 vs 网络层</h3><p><strong>网络层</strong>： 提供主机之间的逻辑通信机制</p><p><strong>传输层</strong>：提供应用进程之间的逻辑通信机制</p><ul><li><p>位于网络层之上</p></li><li><p>依赖于网络服务</p></li><li><p>对网络层服务进行（可能的）增强</p></li></ul><p><u>家庭类比</u></p><ul><li>12个孩子给12个孩子写信</li><li>应用进程 &#x3D; 孩子</li><li>应用消息 &#x3D; 信封里面的信</li><li>主机 &#x3D; 房子</li><li>传输层协议 &#x3D; 李雷和韩梅梅</li><li>网络层协议 &#x3D; 邮政服务</li></ul><h3 id="Internet传输层协议"><a href="#Internet传输层协议" class="headerlink" title="Internet传输层协议"></a>Internet传输层协议</h3><ul><li><p><code>可靠</code>、<code>按序</code>的交付服务(TCP)</p><ul><li>拥塞控制</li><li>流量控制</li><li>连接建立</li></ul></li><li><p><code>不可靠的</code>交付服务(UDP)</p><ul><li>基于 <em>“尽力而为(Best-effort)”</em> 的网路，没有做可靠性方面的拓展</li></ul></li><li><p>两种服务均不保证</p><ul><li>延迟</li><li>带宽</li></ul></li></ul><hr><h2 id="多路复用和多路分用"><a href="#多路复用和多路分用" class="headerlink" title="多路复用和多路分用"></a>多路复用和多路分用</h2><p>Why? $\rightarrow$ 如果<strong>某层的一个协议对应直接上层的多个协议&#x2F;实体</strong>，那么就需要<code>复用/分用</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694605856597.png"                      alt="1694605856597" style="zoom:67%;"                 ><p><u>接收端进行多路分用</u></p><p>传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程</p><p><u>发送端进行多路复用</u></p><p>从多个Socket接受数据，为每块数据封装上头部信息，交给网络层</p><h3 id="分用如何工作"><a href="#分用如何工作" class="headerlink" title="分用如何工作"></a>分用如何工作</h3><ul><li><p>主机接收到<code>IP数据报（datagram）</code></p><ul><li><p>每个数据报携带<code>源IP地址</code>、<code>目的IP地址</code></p></li><li><p>每个数据报携带一个<u>传输层的端</u>（Segment）</p></li><li><p>每个段携带<code>源端口号</code>和<code>目的端口号</code></p></li></ul></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694607845406.png"                      alt="1694607845406" style="zoom:67%;"                 ></p><ul><li>主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694606950930.png"                      alt="1694606950930" style="zoom:67%;"                 ><h3 id="无连接分用"><a href="#无连接分用" class="headerlink" title="无连接分用"></a>无连接分用</h3><ul><li><input checked="" disabled="" type="checkbox"> 利用端口号创建Socket  [completion:: 2023-09-26]</li></ul><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket mySocket1 = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">99111</span>);</span><br><span class="line">DatagramSocket mySocket2 = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">99222</span>);</span><br></pre></td></tr></table></figure></div><ul><li><input disabled="" type="checkbox"> UDP的Socket用二元组标识<ul><li>UDP的Socket用二元组标识</li></ul></li></ul><p>主机收到UDP段之后</p><ul><li><p>检查段中的目的端口号</p></li><li><p>将UDP段导向绑定在该端口号的Socket</p></li></ul><p>来自不同源IP地址和&#x2F;或源端口号的IP数据包被导向同一个<code>Socket</code></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket serverSocket = <span class="keyword">new</span> <span class="built_in">DatagramSocket</span>(<span class="number">6428</span>);</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694607649470.png"                      alt="1694607649470" style="zoom:67%;"                 ><p><strong>SP</strong>提供<code>返回地址</code></p><h3 id="面向连接的分用"><a href="#面向连接的分用" class="headerlink" title="面向连接的分用"></a>面向连接的分用</h3><p> <code>TCP</code>的Socket用四元组标识<br>    - 源IP地址<br>    - 源端口号<br>    - 目的IP地址<br>    - 目的端口号</p><p> 接收端利用所有的四个值将Segment导向合适的Socket</p><p> 服务器可能同时支持多个TCPSocket<br>    - 每个人Socket用自己的四元组标识</p><p><strong>Web服务器</strong>为每个客户端开不同的<code>Socket</code></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694609096055.png"                      alt="1694609096055" style="zoom:67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694609108885.png"                      alt="1694609108885" style="zoom:67%;"                 ><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP-User-Datagram-Protocol-RFC-768"><a href="#UDP-User-Datagram-Protocol-RFC-768" class="headerlink" title="UDP :User Datagram Protocol [RFC 768]"></a>UDP :User Datagram Protocol [RFC 768]</h3><ul><li><p>基于Internet IP协议</p><ul><li><p>复用&#x2F;分用</p></li><li><p>简单的错误校验</p></li></ul></li><li><p>“Best effort”服务，UDP段可能</p><ul><li><p><strong>丢失</strong></p></li><li><p><strong>非按序到达</strong></p></li></ul></li><li><p><code>无连接</code></p><ul><li><p>UDP发送方和接收方之间不需要握手</p></li><li><p>每个UDP段的处理独立于其他段</p></li></ul></li><li><p>常用于<strong>流媒体应用</strong></p><ul><li><p>容忍丢失</p></li><li><p>速率敏感</p></li></ul></li><li><p>UDP还用于</p><ul><li><p>DNS</p></li><li><p>SNMP</p></li></ul></li><li><p>在UDP上实现<code>可靠数据传输</code></p><ul><li><p>在应用层增加可靠性机制</p></li><li><p>应用特定的错误恢复机制</p></li></ul></li></ul><h3 id="UDP检验和-Checksum"><a href="#UDP检验和-Checksum" class="headerlink" title="UDP检验和(Checksum)"></a>UDP检验和(Checksum)</h3><p>目的:<strong>检测UDP段是否发生错误,比如位翻转</strong></p><ul><li><p><strong>发送方</strong></p><ul><li><p>将段的内容视为16-bit整数</p></li><li><p><strong>检验和计算</strong>:计算所有整数的和,进位加在和的后面,将得到得知安慰囚犯,得到校验和</p></li><li><p>发送方将校验和放入校验和字段</p></li></ul></li><li><p><strong>接收方</strong></p><ul><li>计算所受到段的校验和</li><li>将其与校验和字段进行对比<ul><li>不相等:<strong>检测出错误</strong></li><li>相等:<strong>没有检测出错误</strong></li></ul></li></ul></li></ul><h3 id="校验和计算实例"><a href="#校验和计算实例" class="headerlink" title="校验和计算实例"></a>校验和计算实例</h3><p>注意: <strong>最高位必须被加进去</strong></p><p>示例:</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694611617018.png"                      alt="1694611617018" style="zoom:67%;"                 ><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>❓什么是可靠<br>    - 不错,不乱,不丢</p><p><strong>可靠数据传输协议</strong></p><ul><li>可靠数据传输对应用层&#x2F;传输层&#x2F;链路层都很重要</li><li>网络的Top10问题</li><li>信道的不可靠特性决定了可靠数据传输协议(rdt)的复杂性</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612237418.png"                      alt="1694612237418" style="zoom: 80%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612260649.png"                      alt="1694612260649" style="zoom: 80%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612273475.png"                      alt="1694612273475" style="zoom:80%;"                 ><h3 id="可靠数据传输协议基本结构-接口"><a href="#可靠数据传输协议基本结构-接口" class="headerlink" title="可靠数据传输协议基本结构:接口"></a>可靠数据传输协议基本结构:接口</h3><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612283387.png"                      alt="1694612283387" style="zoom:80%;"                 ><h3 id="可靠数据传输协议"><a href="#可靠数据传输协议" class="headerlink" title="可靠数据传输协议"></a>可靠数据传输协议</h3><ul><li>渐进的设计可靠数据传输协议的<strong>发送方</strong>和<strong>接收方</strong></li><li>只考虑单项数据传输</li><li>但是控制信息双向流动</li><li>利用状态机(Fnite State Machine,FSM)刻画传输协议</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612449445.png"                      alt="1694612449445"                ></p><p>Rdt1.0:可靠信道上的可靠数据传输</p><p>底层信道<strong>完全可靠</strong></p><ul><li>不会发生错误(bit error)</li><li>不会丢弃分组<br>发送方和接收方的FSM独立</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694612519572.png"                      alt="1694612519572"                ></p><h2 id="Rdt-2-0"><a href="#Rdt-2-0" class="headerlink" title="Rdt 2.0"></a>Rdt 2.0</h2><h4 id="Rdt-2-0-产生位错误的信道"><a href="#Rdt-2-0-产生位错误的信道" class="headerlink" title="Rdt 2.0: 产生位错误的信道"></a>Rdt 2.0: 产生位错误的信道</h4><p>底层信道可能反转分组中的位</p><ul><li>利用<strong>校验</strong>和检测为错误</li></ul><p>如何从错误中回复？</p><ul><li><p>**确认机制(Acknowledgements,ACK):**接收方<code>显式的</code>告知发送方分组已经正确接收</p></li><li><p>NAK：接收方<code>显式的</code>告知发送方的分组有错误</p></li><li><p>发送方收到NAK之后，<code>重发</code>分组</p></li></ul><p>基于这种重传机制的rdt协议称为<em>ARQ(Automatic Repeat reQuest)</em> 协议</p><p>Rdt 2.0中引入的新机制</p><ul><li><p>差错检测(校验和的方式)</p></li><li><p>接收方反馈控制信息：<strong>ACK&#x2F;NAK</strong></p></li><li><p>重传</p></li></ul><p>Rdt 2.0:<code>FSM规约</code></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694736520687.png"                      alt="1694736520687"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694736529915.png"                      alt="1694736529915"                ></p><h2 id="Rdt-2-1-和-2-2"><a href="#Rdt-2-1-和-2-2" class="headerlink" title="Rdt 2.1 和 2.2"></a>Rdt 2.1 和 2.2</h2><p>对Rst 2.0的改进，先要知道Rdt 2.0有什么缺陷？</p><p><strong>如果ACK和NAK消息发生错误了怎么办</strong>？</p><p><code>Solution 1</code>:为NAK和NCK增加校验和，检错并纠错</p><p><code>Solution 2</code>:发送方收到被破坏的ACK&#x2F;NAK的时候不知道接收方发生了什么，添加额外的<code>控制消息</code> </p><p><code>Solution 3</code>:如果ACK&#x2F;NAK坏掉，就重传。但是不能简单的重传，因为会产生重复分组。</p><p><strong>怎么解决重复分组问题</strong>？</p><p><strong>序列号(Sequance number)</strong>:发送方给每个分组增加序列号</p><p>接收方丢弃重复分组</p><p><strong>stop and wait</strong>:<br>  Sender sends one packet, then waits for reciever response.</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694764764860.png"                      alt="1694764764860"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694764776396.png"                      alt="1694764776396"                ></p><h3 id="Rdt-2-1-vs-Rdt-2-0"><a href="#Rdt-2-1-vs-Rdt-2-0" class="headerlink" title="Rdt 2.1 vs Rdt 2.0"></a>Rdt 2.1 vs Rdt 2.0</h3><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p>为每个分组增加了序列号</p><p>两个序号（0，1）就够用，为什么？</p><p>需要检验ACK&#x2F;NAK消息是否发生错误</p><p>状态数量翻倍<br>  状态必须<strong>记住</strong>当前的分组序列号</p><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p>需要判断分组<code>是不是重复</code><br>  当前所处的状态提供了<u><em>期望收到分组的序列号</em></u></p><p>注意：接收方无法知道ACK&#x2F;NAK是否被正确接收到</p><h4 id="Rdt-2-2-无NAK消息协议"><a href="#Rdt-2-2-无NAK消息协议" class="headerlink" title="Rdt 2.2: 无NAK消息协议"></a>Rdt 2.2: 无NAK消息协议</h4><p>我们真的需要两种确认消息(<code>ACK</code>+<code>NAK</code>)?</p><p>和rdt2.1 的功能相同，但是只使用NAK</p><p>🧐怎么实现？</p><ul><li><p>接收方通过ACK告知最后一个被正确接收的分组</p></li><li><p>在<strong>ACK</strong>消息中<strong>显式的加入被确认分组的序列号</strong></p></li></ul><p>发送方收到重复的ACK之后，采取与收到NAK消息相同的动作</p><ul><li>重传当前的分组</li></ul><h3 id="Rdt-2-2-FSM片段"><a href="#Rdt-2-2-FSM片段" class="headerlink" title="Rdt 2.2 FSM片段"></a>Rdt 2.2 FSM片段</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694765185191.png"                      alt="1694765185191"                ></p><h2 id="Rdt-3-0"><a href="#Rdt-3-0" class="headerlink" title="Rdt 3.0"></a>Rdt 3.0</h2><p>如果信道极可能发生错误，也可能丢失分组，怎么办</p><p>“校验和+序列号+ACK+重传”<strong>够用吗</strong>？</p><p>方法：发送方等待”<code>合理</code>“时间</p><p>如果timeout，有没有收到ACK就可以采取动作了 $\rightarrow$ <strong>重传</strong></p><p>☹但是时间是很难设定的，如果只是延迟了，就会引起重复的问题</p><ul><li>但是序列号能够处理</li><li>接收方需要在ACK中显式的告知所确认的分组</li><li>需要<strong>定时器</strong></li></ul><h3 id="Rdt-3-0-发送方FSM"><a href="#Rdt-3-0-发送方FSM" class="headerlink" title="Rdt 3.0 发送方FSM"></a>Rdt 3.0 <strong>发送方FSM</strong></h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766165886.png"                      alt="1694766165886"                ></p><h3 id="Rdt-3-0-运行实例"><a href="#Rdt-3-0-运行实例" class="headerlink" title="Rdt 3.0 运行实例"></a>Rdt 3.0 运行实例</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766219749.png"                      alt="1694766219749"                ></p><p>⬆ 发送方和接收方在传输过程中没有丢包的存在</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766226555.png"                      alt="1694766226555"                ></p><p>⬆ 在发送过程当中发生丢失的情况，执行停-等协议，造成超时，所以重新传输分组</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766471113.png"                      alt="1694766471113"                ></p><p>⬆ 标识收到了两个分组（相同序列号），那就丢掉一个然后进行传输ACK</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694766548272.png"                      alt="1694766548272"                ></p><p>⬆ 标识两次都发送了，表明第一次正确接收了，但是返回ACK的过程当中触发执行停等协议然后重新发送了一次。收到了ACK1之后会传换成发送pkt0，第二次发的ACK1到达的时候正好有了ACK0。<br>称之为<code>计时器时间过短</code>、<code>timeout早熟</code></p><h3 id="Rdt-3-0-性能分析"><a href="#Rdt-3-0-性能分析" class="headerlink" title="Rdt 3.0 性能分析"></a>Rdt 3.0 性能分析</h3><p>Rdt 3.0能够正常工作，但是性能很差</p><p>示例：1Gbps链路，15ms端到端传输延迟，1kB分组</p><p>$T_{transmit}&#x3D;\frac{L(packet \ length \ in \ bits)}{R(transmission \  rate, \ bps)}&#x3D;\frac{8kb&#x2F;pkt}{10^9b&#x2F;sec}&#x3D;8 ms$</p><p>发送方的利用率：发送方发送时间百分比</p><p>$U_{sender}&#x3D;\frac{L&#x2F;R}{RTT+L&#x2F;R}&#x3D;0.008&#x2F;30.008&#x3D;0.00027$</p><p>在1Gbps链路上每30毫秒才能发送一个分组 $\Rightarrow$ 33KB&#x2F;s</p><p><strong>网络协议限制了物理资源的利用</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694767041067.png"                      alt="1694767041067"                ></p><p>$U_{sender}&#x3D;\frac{L&#x2F;R}{RTT+L&#x2F;R}&#x3D;0.008&#x2F;30.008&#x3D;0.00027$</p><h2 id="流水线的机制和滑动窗口协议"><a href="#流水线的机制和滑动窗口协议" class="headerlink" title="流水线的机制和滑动窗口协议"></a>流水线的机制和滑动窗口协议</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768215316.png"                      alt="1694768215316"                ></p><p>回顾最初的Rdt 3.0操作</p><p>可以更改为同时发多个分组，这样就能有更好的性能</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768312234.png"                      alt="1694768312234"                ></p><p>$U_{sender}&#x3D;\frac{3*L&#x2F;R}{RTT+L&#x2F;R}&#x3D;\frac{0.024}{30.008}&#x3D; 0.0008$</p><p>允许发送方在收到ACK之前连续发送多个分组</p><ul><li><p>更大的序列号范围</p></li><li><p>发送方和&#x2F;或接收方需要更大的存储空间以<strong>缓存分组</strong></p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768451060.png"                      alt="1694768451060"                ></p><p>很明显可以看出效率有明显提高</p><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p><strong>滑动窗口协议</strong>：Sliding-window protocol</p><ul><li><p>窗口</p><ul><li>允许使用的序列号范围      </li><li>窗口尺寸为N：最多有N个等待确认的消息</li></ul></li><li><p><strong>滑动窗口</strong></p><ul><li>随着协议的运行，窗口在序列号空间内向前滑动</li></ul></li></ul><p><strong>滑动窗口协议</strong>：GBN，SR</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768609208.png"                      alt="1694768609208"                ></p><h2 id="GBN-Go-Back-N"><a href="#GBN-Go-Back-N" class="headerlink" title="GBN(Go-Back-N)"></a>GBN(Go-Back-N)</h2><h3 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h3><ul><li>分组头部包含k-bit序列号</li><li>窗口尺寸为<strong>N</strong>，最多允许<strong>N</strong>个分组未确认</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694768789786.png"                      alt="1694768789786"                ></p><ul><li><p>ACK(n):确认到序列号n(包含n)的分组<code>均已经被正确接收</code></p><ul><li>可能收到重复的ACK</li></ul></li><li><p>为空中的分组设置计时器</p></li><li><p>超时<strong>Timeout</strong>事件：重传序列号<strong>大于等于n</strong>，还没有收到ACK的所有分组</p></li></ul><h3 id="GBN：发送方扩展FSM"><a href="#GBN：发送方扩展FSM" class="headerlink" title="GBN：发送方扩展FSM"></a>GBN：发送方扩展FSM</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694769021950.png"                      alt="1694769021950"                ></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nextseqnum &lt; base + N)&#123; <span class="comment">//意味着还有可用的seqnum意味着还可以接着发送分组</span></span><br><span class="line">  sndpkt[nextseqnum]=<span class="built_in">make_pkt</span>(nextseqnum.data.chksum);</span><br><span class="line">  <span class="built_in">udt_send</span>(sndpkt[nextseqnum]);</span><br><span class="line">  <span class="keyword">if</span> (base == nextseqnum)&#123;<span class="comment">//如果base和nextseqnum相等的话，就启动定时器</span></span><br><span class="line">    <span class="built_in">start_timer</span>();</span><br><span class="line">    nextseqnum++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">refuse_data</span>(data);<span class="comment">//如果窗口里面的序列号已经用光了，就可以refuse掉当前的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="Timeout事件出现的操作"><a href="#Timeout事件出现的操作" class="headerlink" title="Timeout事件出现的操作"></a>Timeout事件出现的操作</h4><p>Timeout $\rightarrow$ start_timer()<br>udt_send(sndpkt[base])<br>……<br>udt_send(sndpkt[nextseqsum-1])</p><h3 id="GBN：接收方扩展FSM"><a href="#GBN：接收方扩展FSM" class="headerlink" title="GBN：接收方扩展FSM"></a>GBN：接收方扩展FSM</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694769484914.png"                      alt="1694769484914"                ></p><ul><li>ACK机制：发送拥有最高序列号的、已经被正确的接收的分组的ACK<ul><li>可能产生重复的ACK</li><li>只需要记住唯一的expectedseqnum</li></ul></li><li>乱序到达的分组：<ul><li>直接丢弃 $\rightarrow$ 接收方<code>没有缓存</code></li><li>重新确认<code>序列号最大</code>的<code>按照序列到达</code>的分组</li></ul></li></ul><h3 id="GBN的实例"><a href="#GBN的实例" class="headerlink" title="GBN的实例"></a>GBN的实例</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694769749622.png"                      alt="1694769749622"                ></p><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>数据量链路层采用后退N帧的协议，发送方已经发送了编号为0~7的帧，当计时器超市的时候，如果发送方只收到了0，2，3号帧的确认，那么发送方需要重发的帧数是多少，分别是哪几个帧？</p><blockquote><p>根据GBN的工作原理，GBN协议的确认是累计确认，所以此时发送端需要重发的帧数是4个，依次次分别是4、5、6、7</p></blockquote><h2 id="SR协议"><a href="#SR协议" class="headerlink" title="SR协议"></a>SR协议</h2><h3 id="Select-Repeat协议"><a href="#Select-Repeat协议" class="headerlink" title="Select Repeat协议"></a>Select Repeat协议</h3><p>GBN有什么缺陷？</p><ul><li>不使用累积确认机制，接收方对每个分组单独进行确认<ul><li><strong>设置缓存机制</strong>，缓存乱序到达的分组</li></ul></li><li>发送方只用重传哪些没收到ACK的分组<ul><li>为每个分组设置计时器</li></ul></li><li><strong>发送方窗口</strong><ul><li>N个连续的序列号</li><li>限制已经发送且未发送的分组</li></ul></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694770256143.png"                      alt="1694770256143"                ></p><p><strong>分布式系统的网络</strong></p><h4 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h4><ul><li><strong>data from above</strong>:<ul><li>if next available seq # in window, send pkt</li></ul></li><li><strong>timeout (n)</strong>:<ul><li>resend pkt n, restart timer</li></ul></li><li><strong>ACK(n) in [sendbase,sendBase+N]</strong>:<ul><li>mark pkt n as recieved</li><li>if n smallest unACKed pkt, advanced window base to next unACKed seq #</li></ul></li></ul><h4 id="recevier"><a href="#recevier" class="headerlink" title="recevier"></a>recevier</h4><ul><li><strong>pkt n in [revbase, revbase+N-1]</strong><ul><li>send ACK(n)</li><li>out-of-order:buffer</li><li>in-order:deliver(also deliver buffered, in-order pkts), advance window to next not-yet-recieved pkt</li></ul></li><li><strong>pkt n in [rcvbase-N,rcvbase-1]</strong><ul><li>ACK(n)</li></ul></li><li><strong>otherwise:</strong><ul><li>ignore</li></ul></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694770984071.png"                      alt="1694770984071"                ></p><h3 id="SR协议：困境"><a href="#SR协议：困境" class="headerlink" title="SR协议：困境"></a>SR协议：困境</h3><ul><li>序列号：0，1，2，3</li><li>窗口尺寸：3</li><li>接收方能够区分开两种不同的场景吗？<ul><li>(a)中发送方重发<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694771172608.png"                      alt="1694771172608"                ></li><li>(b)中发送了第五个分组<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694771259880.png"                      alt="1694771259880"                ></li></ul></li></ul><h4 id="问题：序列号空间大小和窗口尺寸需要满足什么关系？"><a href="#问题：序列号空间大小和窗口尺寸需要满足什么关系？" class="headerlink" title="问题：序列号空间大小和窗口尺寸需要满足什么关系？"></a>问题：序列号空间大小和窗口尺寸需要满足什么关系？</h4><blockquote><p>$N_S+N_R \leq 2^k$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-虚电路网络</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E7%94%B5%E8%B7%AF%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E7%94%B5%E8%B7%AF%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="连接服务和无连接服务"><a href="#连接服务和无连接服务" class="headerlink" title="连接服务和无连接服务"></a>连接服务和无连接服务</h2><p>数据报网络和虚电路网络是典型两类 <strong>分组交换网络</strong></p><p>数据报网络提供网络层无连接服务</p><p>虚电路网络日工网络层的连接服务</p><p>类似于传输层的无连接服务(<code>UDP</code>)和面向连接服务(<code>TCP</code>)，但是网络层服务：</p><ol><li>主机到主机服务(而前者是端到端的连接)</li><li>网络核心实现</li></ol><h2 id="虚电路-Virtual-circuits-VC"><a href="#虚电路-Virtual-circuits-VC" class="headerlink" title="虚电路(Virtual circuits) VC"></a>虚电路(Virtual circuits) VC</h2><p><strong>虚电路</strong>：一条从源主机到目的主机， <em>类似于电路</em>的路径(逻辑链接)</p><ul><li><p>分组交换 （和电路交换的建立的电路网络不相同）</p></li><li><p>每个分组的传输利用链路的全部带宽</p></li><li><p>源到目的路径经过的网络层设备共同完成虚电路的功能</p></li></ul><p><strong>通信过程：</strong></p><ul><li>呼叫建立（call setup） $\to$ 数据传输 $\to$ 拆除呼叫</li></ul><p><code>VCID</code> 每个分组携带虚电路标识<code>VCID</code>, 而不是目的主机地址</p><p>虚电路经过的每个网络设备(如路由器)，维护 <strong>每条</strong> 经过它的虚电路连接状态</p><p>链路、网络设备资源（如带宽、缓存等）可以面向VC进行预分配</p><ul><li>预分配资源 &#x3D; 可预期服务性能</li><li>如ATM 的电路仿真</li></ul><h2 id="VC的具体实现"><a href="#VC的具体实现" class="headerlink" title="VC的具体实现"></a>VC的具体实现</h2><h3 id="每条虚电路包括"><a href="#每条虚电路包括" class="headerlink" title="每条虚电路包括"></a>每条虚电路包括</h3><ol><li>源主机到目的主机的<strong>一条路径</strong></li><li>虚电路号（VCID），沿路每段链路的一个编号，有多少的链路就表现出网络的性能</li><li>沿路每个网络层设备（路由器等），<strong>利用转发表记录经过的每条虚电路</strong></li></ol><p><strong>沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址</strong></p><p>同一条VC，在每段链路上的VCID通常不同</p><ul><li>路由器转发分组的时候根据转发表改写&#x2F;替换虚电路号</li></ul><h2 id="VC转发表"><a href="#VC转发表" class="headerlink" title="VC转发表"></a>VC转发表</h2><p>每一个网络设备都要参与记录转发表</p><p>路由器R1的VC转发表</p><table><thead><tr><th>输入接口</th><th>输入VC #</th><th>输出接口</th><th>输出VC #</th></tr></thead><tbody><tr><td>1</td><td>12</td><td>3</td><td>22</td></tr><tr><td>2</td><td>63</td><td>1</td><td>18</td></tr><tr><td>……</td><td>……</td><td>……</td><td>……</td></tr></tbody></table><p><strong>VC路径上每个路由器都需要维护VC连接的状态信息</strong></p><h2 id="虚电路信令协议（signal-protocols）"><a href="#虚电路信令协议（signal-protocols）" class="headerlink" title="虚电路信令协议（signal protocols）"></a>虚电路信令协议（signal protocols）</h2><p>用于VC的建立维护和拆除</p><ul><li>路径选择</li></ul><p>应用于虚电路网络</p><ul><li>如ATM、帧中继网络等</li></ul><p><strong>目前的Internet不再采用</strong></p><ol><li>初始呼叫(通过路由)</li><li>呼叫到达</li></ol><p><strong>虚电路俩连接之后，就开始下一段的行动，进行连接的建立和数据的传输</strong></p><ol start="3"><li><p>接收呼叫</p></li><li><p>呼叫建立</p></li><li><p>数据流开始</p></li><li><p>接收数据</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-计算机网络传输层-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>可靠数据传输原理 -&gt; TCP</p><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP是面向连接的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，两个进程必须先相互握手。</p><p>连接的双方都将初始化和TCP连接相关的许多TCP状态变量</p><p><strong>全双工服务（full-duplex service）</strong></p><p><strong>点对点(point-to-point)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络应用进程通信</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]# 网络应用进程通信<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a><strong><code>进程</code></strong></h2><ul><li>主机上运行的程序</li></ul><h2 id="同一主机上运行的进程之间如何进行通信"><a href="#同一主机上运行的进程之间如何进行通信" class="headerlink" title="同一主机上运行的进程之间如何进行通信"></a>同一主机上运行的进程之间如何进行通信</h2><ul><li>进程间的<code>**通讯机制**</code></li><li>操作系统来提供</li></ul><h2 id="不同主机上运行的进程之间如何通信"><a href="#不同主机上运行的进程之间如何通信" class="headerlink" title="不同主机上运行的进程之间如何通信"></a>不同主机上运行的进程之间如何通信</h2><ul><li><strong><code>消息交换</code></strong></li></ul><p><strong>客户机进程：发起通信的进程</strong></p><p><strong>服务器进程：等待通信请求的进程</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png"                      alt="Untitled"                ></p><h2 id="套接字：Socket"><a href="#套接字：Socket" class="headerlink" title="套接字：Socket"></a>套接字：<em>Socket</em></h2><p>进程之间通信利用Socket发送和接受消息实现</p><h3 id="类似于寄信"><a href="#类似于寄信" class="headerlink" title="类似于寄信"></a>类似于寄信</h3><ul><li><strong>发送方</strong>将消息送到<strong>门外的邮箱</strong></li><li><strong>发送方</strong>以来（门外的）传输基础设施将消息传输到<strong>接收方所在的主机</strong>，并且送到<strong>接受方的门外</strong></li><li><strong>接收方从门外获取消息</strong></li></ul><h3 id="传输基础设施向进程提供API"><a href="#传输基础设施向进程提供API" class="headerlink" title="传输基础设施向进程提供API"></a>传输基础设施向进程提供API</h3><ul><li>传输协议的选择</li><li>参数的设置</li></ul><p>很自然的问题，底层的设施怎么就能正确无误的接收到传输到的进程呢？</p><h2 id="如何寻址进程"><a href="#如何寻址进程" class="headerlink" title="如何寻址进程"></a>如何寻址进程</h2><h3 id="不同主机上的进程之间通信，那么每个进程都必须拥有标识符"><a href="#不同主机上的进程之间通信，那么每个进程都必须拥有标识符" class="headerlink" title="不同主机上的进程之间通信，那么每个进程都必须拥有标识符"></a>不同主机上的进程之间通信，那么每个进程都必须拥有标识符</h3><h3 id="如何寻址主机？——IP地址"><a href="#如何寻址主机？——IP地址" class="headerlink" title="如何寻址主机？——IP地址"></a>如何寻址主机？——IP地址</h3><ul><li>Q：主机有了IP地址之后，是否<code>**足以</code> 定位进程？**</li><li>A：不是，同一个主机可能同时有多个进程需要通信</li></ul><p><strong>端口号&#x2F;<em>Port Number</em></strong></p><ul><li>是主机上每个需要通信的进程都分配一个端口号</li><li>HTTP Server：80</li><li>Mail Server：25</li></ul><h3 id="进程的标识符"><a href="#进程的标识符" class="headerlink" title="进程的标识符"></a>进程的标识符</h3><ul><li>IP地址+端口号</li></ul><h2 id="应用层的协议"><a href="#应用层的协议" class="headerlink" title="应用层的协议"></a>应用层的协议</h2><h3 id="网络应用都应该需要遵循应用层协议"><a href="#网络应用都应该需要遵循应用层协议" class="headerlink" title="网络应用都应该需要遵循应用层协议"></a>网络应用都应该需要遵循应用层协议</h3><h3 id="公开协议"><a href="#公开协议" class="headerlink" title="公开协议"></a>公开协议</h3><ul><li>由RFC（<em><strong>Request For Comments</strong></em>）定义</li><li>允许互相操作</li><li>HTTP，SMTP，……</li></ul><h3 id="私有协议"><a href="#私有协议" class="headerlink" title="私有协议"></a>私有协议</h3><ul><li>多数P2P文件共享应用</li></ul><h2 id="应用层协议的内容"><a href="#应用层协议的内容" class="headerlink" title="应用层协议的内容"></a>应用层协议的内容</h2><h3 id="消息的类型（type）"><a href="#消息的类型（type）" class="headerlink" title="消息的类型（type）"></a>消息的类型（type）</h3><ul><li>请求消息</li><li>响应消息</li></ul><h3 id="消息的语法（syntax）格式"><a href="#消息的语法（syntax）格式" class="headerlink" title="消息的语法（syntax）格式"></a>消息的语法（syntax）格式</h3><ul><li>消息中由哪些字段</li><li>每个字段如何描述</li></ul><h3 id="字段的语义（semantics）"><a href="#字段的语义（semantics）" class="headerlink" title="字段的语义（semantics）"></a>字段的语义（semantics）</h3><ul><li>字段中信息的含义</li></ul><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>进程应该何时、如何发送消息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-虚拟局域网</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="VLANs：动机"><a href="#VLANs：动机" class="headerlink" title="VLANs：动机"></a>VLANs：动机</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101220617.png"                      alt="image.png"                ></p><p>考虑一下情形:CS用户迁移到EE，但是希望连接至CS交换机，怎么办?</p><p>单一广播域:</p><p>所有第2层广播流量(ARPDHCP,未知目的MAC地址位置)必须穿越整个LAN</p><p>安全&#x2F;隐私，效率问题</p><h3 id="虚拟局域网-VirtualLocal-Area-Network"><a href="#虚拟局域网-VirtualLocal-Area-Network" class="headerlink" title="虚拟局域网(VirtualLocal Area Network)"></a>虚拟局域网(VirtualLocal Area Network)</h3><p>支持VLAN划分的交换机，可以在一个物理LAN架构上配置定义多个VLAN</p><p>基于端口的VLAN: 分组交换机端口(通过交换机管理软件)，于是，单一的物理交换机 …..</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101220735.png"                      alt="image.png"                ></p><p><strong>流量隔离(traffic isolation)</strong>:去往&#x2F;来自端口1-8的倾只到达端口1-8</p><ul><li>也可以基于MAC地址定义VLAN,而不是交换端口</li></ul><p><strong>动态成员</strong>: 端口可以动态分配给不同VLAN</p><p><strong>在VLAN间转发: 通过路由(就像在独立的交换机之间)</strong></p><p>实践中，厂家会将交换机与路由器集成在一起</p><h2 id="跨越多交换机的VLAN"><a href="#跨越多交换机的VLAN" class="headerlink" title="跨越多交换机的VLAN"></a>跨越多交换机的VLAN</h2><p><strong>多线缆连接</strong></p><ul><li>每个线缆连接一个VLAN</li></ul><p><strong>中继端口(trunk port)</strong>: 在跨越多个物理交换机定义的VLAN承载帧</p><ul><li><p>为多VLAN转发802.1顿容易产生歧义(必须携带VLAN ID信息)</p></li><li><p>802.1q协议为经过中继端口转发的顿增加&#x2F;去除额外的首部域</p></li></ul><h2 id="802-1Q-VLAN帧格式"><a href="#802-1Q-VLAN帧格式" class="headerlink" title="802.1Q VLAN帧格式"></a>802.1Q VLAN帧格式</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101221243.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络应用的体系结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 网络应用的体系结构<h1 id="你使用过哪些网络应用？"><a href="#你使用过哪些网络应用？" class="headerlink" title="你使用过哪些网络应用？"></a>你使用过哪些网络应用？</h1><p>百度 QQ alipay weixin ……</p><h1 id="网络应用有哪些特点呢？"><a href="#网络应用有哪些特点呢？" class="headerlink" title="网络应用有哪些特点呢？"></a>网络应用有哪些特点呢？</h1><p><strong>🤔和单机应用有什么不同？</strong></p><p><strong>🤔网络应用应该有什么样的结构呢？</strong></p><h1 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h1><p><code>**客户机、服务器**</code>结构（Client-Server,C）</p><p><code>**点对点**</code>结构（Peer-to-peer,P2P）</p><p><code>**混合**</code>结构</p><h2 id="客户机-服务器结构"><a href="#客户机-服务器结构" class="headerlink" title="客户机&#x2F;服务器结构"></a>客户机&#x2F;服务器结构</h2><p><strong><strong><strong>客户机：</strong></strong></strong></p><ul><li>和服务器通信</li><li><strong>间歇性</strong>接入网络</li><li>可能有<strong>动态的IP地址</strong></li><li>不会和其他的客户机通信</li></ul><p><strong>服务器：</strong></p><ul><li>需要不断提供服务</li><li><code>永久性</code>的访问地址</li><li>利用<strong>大量服务器</strong>实现可扩展性</li></ul><p><strong>例子</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png"                      alt="Untitled"                ></p><h2 id="纯P2P结构"><a href="#纯P2P结构" class="headerlink" title="纯P2P结构"></a>纯P2P结构</h2><p>基本上看不出来明显的服务器和客户机的差别了</p><aside>🪶 **特点**<p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.png"                      alt="Untitled"                ></p><ul><li>没有永远在线的服务器</li><li>任意端或者节点之间都可以直接通讯</li><li>节点间歇性的接入网络</li><li>节点可能改变IP地址</li></ul><p><strong>优点</strong></p><p><strong>高度可伸缩的</strong></p><p><strong>缺点</strong></p><p><strong>难以管理</strong></p></aside><h2 id="混合结构"><a href="#混合结构" class="headerlink" title="混合结构"></a>混合结构</h2><p>🤔<strong>能否将两种结构混合在一起呢？并能够结合两者的优点？</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png"                      alt="可以避免服务器的资源过度使用"                ></p><p>可以避免服务器的资源过度使用</p><ul><li><em><strong>Napster应用</strong></em><ul><li><strong>文件传输</strong>使用P2P结构</li><li><strong>文件的搜索</strong>采用C&#x2F;S结构——<code>**集中式**</code><ul><li>每个节点<em>向中央服务器登记自己的内容</em></li><li>每个节点向中央服务器<em>提交查询要求</em>，查找感兴趣的内容</li></ul></li></ul></li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p><strong>每种网络体系结构找出5种以上的网络应用</strong></p><p><strong>从多个方面&#x2F;角度对比三种体系结构的优缺点</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络应用层概述</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 网络应用层概述<h2 id="本讲内容"><a href="#本讲内容" class="headerlink" title="本讲内容"></a>本讲内容</h2><h2 id="网络应用的体系结构"><a href="#网络应用的体系结构" class="headerlink" title="网络应用的体系结构"></a>网络应用的体系结构</h2><ul><li>客户机和服务器</li><li>P2P</li><li>混合结构</li></ul><table><thead><tr><th>application</th></tr></thead><tbody><tr><td>transport</td></tr><tr><td>network</td></tr><tr><td>link</td></tr><tr><td>physical</td></tr></tbody></table><h2 id="网络应用的服务需求"><a href="#网络应用的服务需求" class="headerlink" title="网络应用的服务需求"></a>网络应用的服务需求</h2><ul><li>可靠性</li><li>带宽</li><li>时延</li></ul><h2 id="Internet传输层服务模型"><a href="#Internet传输层服务模型" class="headerlink" title="Internet传输层服务模型"></a>Internet传输层服务模型</h2><ul><li>TCP</li><li>UDP</li></ul><h2 id="特定协议网络模型"><a href="#特定协议网络模型" class="headerlink" title="特定协议网络模型"></a>特定协议网络模型</h2><ul><li>HTTP</li><li>SMTP POP IMAP</li><li>DNS</li><li>P2P应用</li></ul><h2 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h2><ul><li>TCP</li><li>UDP</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络层例题讲解</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>某网络拓扑如下图所示，路由器R1通过接口E1、E2分别连接局域网1、局域网2，通过接口LO连接路由器R2，并通过路由器R2连接域名服务器与互联网。R1的LO接口的IP地址是202.118.2.1;R2的LO接口的IP地址是202.118.2.2，L1接口的IP地址是130.11.120.1，EO接口的IP地址是202.118.3.1;域名服务器的IP地址是202.118.3.2。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030134252.png"                      alt="image.png"                ></p><p>R1和R2的路由表结构为：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030134326.png"                      alt="image.png"                ></p><p>(1)将IP地址空间202.118.1.0&#x2F;24划分为2个子网，分别分配给局域网1、局域网2，每个局域网需分配的IP地址数不少于120个。请给出子网划分结果，说明理由或给出必要的计算过程</p><blockquote><p>可以看出是标准的C网，202.118.1.0 ~ 202.118.1.254<br>划分结果为：<br>子网1：202.118.1.0，子网掩码为255.255.255.128<br>（202.118.1.0&#x2F;25）<br>子网2：202.118.1.128，子网掩码为255.255.255.128<br>（202.118.1.128&#x2F;25）</p></blockquote><p>(2)请给出R1的路由表，使其明确包括到局域网1的路由、局域网2的路由、域名服务器的主机路由和互联网的路由。</p><table><thead><tr><th align="center">目的网络IP地址</th><th align="center">子网掩码</th><th align="center">下一跳IP地址</th><th align="center">接口</th></tr></thead><tbody><tr><td align="center">202.118.1.0</td><td align="center">255.255.255.128</td><td align="center">-</td><td align="center">E1</td></tr><tr><td align="center">202.118.1.128</td><td align="center">255.255.255.128</td><td align="center">-</td><td align="center">E2</td></tr><tr><td align="center"><div>202.118.3.2</div></td><td align="center"><div>255.255.255.255</div></td><td align="center">202.118.2.2</td><td align="center">L0</td></tr><tr><td align="center">0.0.0.0</td><td align="center">0.0.0.0</td><td align="center">202.118.2.2</td><td align="center">L0</td></tr></tbody></table><p>(3)请采用路由聚合技术，给出R2到局域网1和局域网2的路由。</p><table><thead><tr><th align="center">目的IP地址</th><th align="center">子网掩码</th><th align="center">下一跳IP地址</th><th align="center">L0</th></tr></thead><tbody><tr><td align="center">202.118.1.0</td><td align="center">255.255.255.0</td><td align="center">202.118.2.1</td><td align="center">L0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-网络层服务</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>从发送主机像接受主机传送数据段</p><p><strong>发送主机</strong>： 将数据段封装到数据报中</p><p><strong>接收主机</strong>：向传输层交付数据段</p><p><em><strong>每个</strong></em>主机和路由器都运行网络层协议</p><p>路由器检验所有穿越它的IP数据报的头部域</p><h2 id="网络层的核心功能-——-转发和路由"><a href="#网络层的核心功能-——-转发和路由" class="headerlink" title="网络层的核心功能 —— 转发和路由"></a>网络层的核心功能 —— 转发和路由</h2><p>路由器怎么把数据包转发到数据端口上最终送到目的地？</p><blockquote><p>[!转发（forwarding）]<br>将分组从路由器的输入端口转移到合适的输出端口</p></blockquote><p>转发表： 转发表确定在本路由器如何转发分组</p><p>每一个地址来对应一个输出链路，通过转发表来进行寻找路线。</p><p>必须事先建立起转发表，才能进行传输数据。</p><blockquote><p>[!路由(routing)]<br>确定分组从源到目的经过的路径</p></blockquote><p><strong>路由算法</strong> （routing algorithms）</p><ul><li><em>确定通过网络的端到端路径</em></li></ul><h2 id="网络层核心功能-——-连接建立"><a href="#网络层核心功能-——-连接建立" class="headerlink" title="网络层核心功能 —— 连接建立"></a>网络层核心功能 —— 连接建立</h2><p>某些网络的重要功能：</p><ul><li>ATM 帧中继 X.25</li></ul><p>数据分组传输之前两端主机需要<strong>首先</strong>建立虚拟&#x2F;逻辑连接</p><ul><li>网络设备（如路由器）参与连接的建立</li></ul><p>网络层连接和传输层连接的<strong>对比</strong></p><ul><li>网络层连接：两个主机之间（<em>路径上的路由器等网络设备参与其中</em>）</li><li>传输层连接：两个应用进程之间（<em>对中间网络设备透明</em>）</li></ul><h2 id="网络层服务模型"><a href="#网络层服务模型" class="headerlink" title="网络层服务模型"></a>网络层服务模型</h2><p>Q： 网络层为发送端到接收端的数据包传送通道( channel )提供什么样的服务模型(service model)？</p><p>Internet 网络层中提供的模型 Best effort model <code>尽力服务</code></p><p>作为网络层，不需要进行拥塞控制或者拥塞信息的处理</p><p><em>通过是否发生数据丢失来确定是否发生了数据的拥塞</em></p><p>ATM 网络 :</p><ul><li>CBR  constant rate 固定比特率 所以带宽是保障的，不会出现拥塞。</li><li>VBR  guaranteed rate 再拥塞的时候只能提供最低的传输数据带宽</li><li>ABR</li></ul><h3 id="无连接服务-connection-less-service"><a href="#无连接服务-connection-less-service" class="headerlink" title="无连接服务 (connection-less service)"></a>无连接服务 (connection-less service)</h3><ul><li>不事先为系列分组的传输确定传输路径</li><li>每个分组独立确定传输路径（根据网络状况来动态的选择）</li><li>不同的分组可能传输路径不相同<ul><li>所以发到的数据顺序可能是不一样的</li></ul></li><li><strong>数据报网络(datagram network)</strong></li></ul><h3 id="连接服务-connection-service"><a href="#连接服务-connection-service" class="headerlink" title="连接服务(connection service)"></a>连接服务(connection service)</h3><ul><li>首先 为系列分组传输确定从源到目的的经过的路径(建立连接)</li><li>然后沿该路径(连接)传输系列分组</li><li>系列分组传输路径相同</li><li>传输结束之后拆除连接</li><li><strong>虚电路网络(virtual-sircuit network)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-有类IP地址</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%9C%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%9C%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>IP子网 [[CourseNotes&#x2F;计算机体系结构&#x2F;CN-IP编址|CN-IP编址]]</p><h2 id="IP地址（Addresses"><a href="#IP地址（Addresses" class="headerlink" title="IP地址（Addresses)"></a>IP地址（Addresses)</h2><p>“有类”编址</p><p><strong>A类地址</strong>：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015202955.png"                      alt="image.png"                ></p><p>0.0.0.0 ~ 127.255.255.255</p><p><strong>B类地址</strong>：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015203137.png"                      alt="image.png"                ><br>128.0.0.0 ~ 191.255.255.255.255</p><p><strong>C类地址</strong>：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015203302.png"                      alt="image.png"                ><br>192.0.0.0 ~ 233.255.255.255</p><p>定义C类地址前八位用于网络号，后面八位用于主机号</p><p>对于剩余的八分之一的地址空间进行最后一次的二分，D类地址不再确认网络号和主机号，用于特殊的目的：</p><p>用于标识一组主机，理论上可以在互联网中的所有地方。称为<strong>多播地址</strong>。</p><p>E类地址保留作为研究使用</p><h2 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h2><table><thead><tr><th align="center">NetID</th><th align="center">HostID</th><th align="center">作为IP分组源地址</th><th align="center">作为IP分组目的地址</th><th>用途</th></tr></thead><tbody><tr><td align="center">全0</td><td align="center">全0</td><td align="center">可以</td><td align="center">不可以</td><td>在本网范围内表示本机; 在路由表中用于表示默认路由相当于表示整个Internet网络</td></tr><tr><td align="center">全0</td><td align="center">特定值</td><td align="center">不可以</td><td align="center">可以</td><td>标识本网内某个特定的主机</td></tr><tr><td align="center">全1</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td>本网的广播地址（路由器不转发）  <strong>受限网络地址</strong></td></tr><tr><td align="center">特定值</td><td align="center">全0</td><td align="center">不可以</td><td align="center">可以</td><td>网络地址，表示一个网络</td></tr><tr><td align="center">特定值</td><td align="center">全1</td><td align="center">不可以</td><td align="center">可以</td><td>直接广播地址，对特定网络上的所有主机进行广播</td></tr><tr><td align="center">127</td><td align="center">非全0或者非全1的任何数</td><td align="center">可以</td><td align="center">可以</td><td>用于本地软件环回测试</td></tr></tbody></table><h2 id="私有（pivate）IP地址"><a href="#私有（pivate）IP地址" class="headerlink" title="私有（pivate）IP地址"></a>私有（pivate）IP地址</h2><p>只用于私有网络，在公共网络上这种地址是无效的</p><table><thead><tr><th align="center">Class</th><th align="center">NetIDs</th><th align="center">Blocks</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">10</td><td align="center">1</td></tr><tr><td align="center">B</td><td align="center">172.16 to 172.31</td><td align="center">16</td></tr><tr><td align="center">C</td><td align="center">192.168.0 to 192.168.255</td><td align="center">256</td></tr></tbody></table><p>这部分的私有地址使得IPv4的网络还能正常运行</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-数据链路层服务</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>术语：</p><ul><li><p>主机和路由器：结点（nodes）</p></li><li><p>连接相邻结点的通信信道：链路(links)</p><ul><li>有线链路(wired links)</li><li>无线链路(wireless links)</li><li>局域网(LANs)</li></ul></li><li><p>链路层(第2层)数据分组：帧(frame),封装网络层数据报</p></li></ul><blockquote><p><strong>数据链路层</strong>负责实现通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传输数据报</p></blockquote><h2 id="链路层服务"><a href="#链路层服务" class="headerlink" title="链路层服务"></a>链路层服务</h2><p>组帧(framing)</p><ul><li><p>封装数据报文构成数据帧，加上首部和尾部</p></li><li><p>帧同步</p></li></ul><p>在数据帧的首位加上特殊的字符</p><p>链路接入(link access)</p><p>如果是共享介质，需要解决信道接入(channel access)</p><p>帧首部中的”MAC”地址，用于标识帧的源和目的</p><ul><li>不同于IP地址！</li></ul><p>相邻结点之间可靠交付</p><p>无线链路: 误码率高，需要可靠交付</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-应用层学习笔记</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 应用层 [[计算机网络]]<h2 id="章节分段"><a href="#章节分段" class="headerlink" title="章节分段"></a>章节分段</h2><ol><li><p>C&#x2F;S模式，P2P模式</p></li><li><p>讨论客户-服务器模式的概念以及这个模式是如何为英特网用户提供服务的</p></li><li><p>讨论客户-服务器模式的预定义和标准应用。（万维网、文件传输、电子邮件）</p></li><li><p>对等模式中的概念以及协议。以及协议的流行应用</p></li><li><p>给出在客户-服务器模式下怎么通过C语言编写两个程序创建一个新的应用</p></li></ol><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可以把应用层的功能看作是两个应用层之间假设存在一个<code>假想的直接连接</code>，通过这个链接可以发送和接收报文。</p><p>因特网为全世界用户提供服务。<code>层次结构</code>使得因特网比其他网络更加灵活，在一层增加协议的时候要观察是不是使用了底层提供的服务；在一层删去协议的时候要关注上层是不是使用了该协议，并改写上一层的协议。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-数据报网络</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h2><p>数据报网络和虚电路网络的最大区别就是有连接和无连接</p><p>网络层无连接</p><p>每个分组携带目的地址</p><h3 id="路由器根据分组的目的地址转发分组"><a href="#路由器根据分组的目的地址转发分组" class="headerlink" title="路由器根据分组的目的地址转发分组"></a><strong>路由器根据分组的目的地址转发分组</strong></h3><ul><li>基于路由协议&#x2F;算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路<ol><li>发送数据报</li><li>接收数据报</li></ol></li></ul><h2 id="数据报转发表"><a href="#数据报转发表" class="headerlink" title="数据报转发表"></a>数据报转发表</h2><p>路由算法（协议）<strong>确定通过网络的端到端路径</strong></p><p>转发表确定在本路由器如何转发分组</p><p>:question: 但是有一个问题:question:</p><p>IP地址是一个32位的2进制的数，所以可能的IP地址有40多亿</p><p><strong>针对地址范围</strong></p><p>意味着之在一个地址范围内的数据报在一个输出链路上进行展示，将列表的地址进行了聚合</p><p>不同的IP地址通过不同的范围来确定不同的链路接口</p><p><strong>在实际的网络中地址的划分其实并不完美</strong></p><h2 id="最长前缀匹配优先"><a href="#最长前缀匹配优先" class="headerlink" title="最长前缀匹配优先"></a>最长前缀匹配优先</h2><p>例如</p><table><thead><tr><th align="center">目的地址范围</th><th align="center">链路接口</th></tr></thead><tbody><tr><td align="center">11001000 00010111 00010### #########</td><td align="center">0</td></tr><tr><td align="center">11001000 00010111 00011000 #########</td><td align="center">1</td></tr><tr><td align="center">11001000 00010111 00011### #########</td><td align="center">2</td></tr><tr><td align="center">其他</td><td align="center">3</td></tr></tbody></table><p>DA： 11001000 00010111 00010&#x3D;&#x3D;110 10100001&#x3D;&#x3D; <strong>从哪个接口转发？</strong>&#x3D;&#x3D;A : 0&#x3D;&#x3D;</p><p>只有所有的入口都匹配不成功的时候才会进入默认路径  </p><p>DA:   11001000 00010111 00011&#x3D;&#x3D;000 10101010&#x3D;&#x3D; <strong>从哪个接口转发？</strong> &#x3D;&#x3D;A ：1&#x3D;&#x3D;</p><p>匹配前面的前缀越多，越长，描述的范围就越小，网络就越小；匹配前面的前缀越短，网络就越大。所以我们应该将数据报送到更具体的端口上。<strong>所以就应该选择1号接口进行转发</strong>。</p><p>称之为： <strong>最长前缀匹配优先原则</strong></p><blockquote><p>[!最长前缀匹配优先原则]</p><p>在检索转发表的时候，优先选择和分组目的地址匹配前缀最长的入口(entry)</p></blockquote><h2 id="数据报网络-or-VC网络"><a href="#数据报网络-or-VC网络" class="headerlink" title="数据报网络 or VC网络"></a>数据报网络 or VC网络</h2><h3 id="Internet-数据报网络"><a href="#Internet-数据报网络" class="headerlink" title="Internet 数据报网络"></a>Internet 数据报网络</h3><h4 id="简化网络-复杂“边缘”"><a href="#简化网络-复杂“边缘”" class="headerlink" title="简化网络 复杂“边缘”"></a>简化网络 复杂“边缘”</h4><p><strong>计算机之间的数据交换</strong></p><p>“弹性”服务，没有严格的时间需求</p><p>链路类型众多</p><ul><li><p>特点性能各异</p></li><li><p>统一服务比较困难</p></li></ul><p></p><hr><h3 id="ATM-VC网络"><a href="#ATM-VC网络" class="headerlink" title="ATM VC网络"></a>ATM VC网络</h3><h4 id="简化“边缘”，复杂网络"><a href="#简化“边缘”，复杂网络" class="headerlink" title="简化“边缘”，复杂网络"></a>简化“边缘”，复杂网络</h4><p><strong>电话网络演变而来</strong></p><p>核心业务是实时对话：</p><ul><li>严格的时间、可靠性需求</li><li>需要有保障的服务</li></ul><p>“哑（dumb）”端系统（非智能）</p><ul><li>电话机</li><li>传真机</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-差错编码</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B7%AE%E9%94%99%E7%BC%96%E7%A0%81/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B7%AE%E9%94%99%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="差错检测：差错编码"><a href="#差错检测：差错编码" class="headerlink" title="差错检测：差错编码"></a>差错检测：差错编码</h2><p>差错编码基本原理：</p><p>$D \to DR$ 其中R为差错检测和纠正bit（冗余bit）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030135954.png"                      alt="image.png"                ></p><p>如果是没有出错的就直接还原就好</p><p>但是即便判断出当前的R一致，也不能保证一定可靠</p><h3 id="差错编码的检错能力"><a href="#差错编码的检错能力" class="headerlink" title="差错编码的检错能力"></a>差错编码的检错能力</h3><p>差错编码可以分为检错码和纠错码</p><p>对于检错码，如果编码集的汉明距离$d_s &#x3D; r+1$ 那么差错编码可以检测r位的差错。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030141008.png"                      alt="image.png"                ></p><p>例如，编码集{0000,0101,1010,1111}的汉明距离$d_s$&#x3D;2，可以100%检测1比特差错</p><p>对于纠错码，如果编码集的汉明距离$d_s$&#x3D;2r+1，则该差错编码可以纠正r位的差错</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030141157.png"                      alt="image.png"                ><br>例如，编码集{000000,010101,101010,111111} 的汉明距离$d_s$&#x3D;3可以纠正1比特差错，如100010纠正为101010。</p><h2 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h2><p>1bit校验位：</p><ul><li>检测奇数位差错</li></ul><p>编码的效率很高</p><p>二维奇偶校验</p><p>检测奇数位的差错：部分偶数位的差错</p><p>纠正同一行&#x2F;列的奇数位错误</p><h2 id="Internet校验和"><a href="#Internet校验和" class="headerlink" title="Internet校验和"></a>Internet校验和</h2><h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端:"></a>发送端:</h3><p>将数据（校验内容）划分为16位的二进制整数序列</p><p>求和</p><p>校验和</p><p>放入分组</p><h3 id="接收端："><a href="#接收端：" class="headerlink" title="接收端："></a>接收端：</h3><p>和发送端相同的算法进行计算</p><p>计算得到checksum</p><h2 id="循环冗余校验码"><a href="#循环冗余校验码" class="headerlink" title="循环冗余校验码"></a>循环冗余校验码</h2><p>检错能力更强大的校验编码</p><p>将数据bit，D，视为一个二进制数</p><p>选择一个r+1位的比特模式（生成bit模式）</p><p>目标：选择r位的CRCbit，R，满足</p><ul><li><p>&lt;D,R&gt; 刚好可以被G整除</p></li><li><p>接收端检错：利用G除&lt;D,R&gt;,余式全为0，无错；否则，有错！</p></li><li><p>可以检测所有突发长度小于r+1位差错</p></li></ul><h3 id="广泛应用于实际网络-以太网，802-11-WIFI，ATM"><a href="#广泛应用于实际网络-以太网，802-11-WIFI，ATM" class="headerlink" title="广泛应用于实际网络(以太网，802.11 WIFI，ATM)"></a>广泛应用于实际网络(以太网，802.11 WIFI，ATM)</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030142849.png"                      alt="image.png"                ></p><p>期望：</p><p>$D \cdot 2^r \ XOR &#x3D; \ nG$</p><p>相当于如果利用G去去除$D \cdot 2^r$，则余式即为R：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231030143054.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 数据链路层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-分组交换网络中的时延、丢包和吞吐量</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>分组交换网络的时延最重要的是 <strong>节点处理时延</strong>，<strong>排队时延</strong>，<strong>传输时延</strong>，<strong>传播时延</strong></p><p>这些时延加起来的总和就是 <strong>节点总时延</strong></p><h2 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h2><p>检查分组首部和决定该分组到向何处所需要的时间是处理时延的一部分。<br>也包括其他因素，比如检查 <strong>比特级别的差错</strong><br>高速路由器的处理时延通常是微秒或者更低的数量级。</p><h2 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h2><p>在队列中，分组在链路上等待传输的时候，它经受排队时延。</p><p>一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量</p><p>到达分组期待发现的返祖数量是到达该队列的流量的强度和性质的函数。实际的排队时延可以是毫秒到微妙量级</p><h2 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h2><p>假定分组以先到先服务的方式传输——这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输之后，才能传输刚到到达的分组。</p><h2 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h2><p>传播时延是信号通过的路程的长度，为$d&#x2F;s$</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-层次化路由</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B1%82%E6%AC%A1%E5%8C%96%E8%B7%AF%E7%94%B1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B1%82%E6%AC%A1%E5%8C%96%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>将任意规模的网络抽象为一个图计算路由-过于理想化</p><ul><li><p>表示所有的路由器</p></li><li><p>“扁平”网络</p></li></ul><p>——在实际的网络中不可行！</p><p>网络规模：考虑6个亿的结点的网络</p><p>路由表几乎无法存储</p><p>路由计算过程的信息</p><p>链路状态分组，交换量巨大，会淹没链路</p><p><strong>管理自治</strong>：每个网络的管理可能都期望自主控制其网内的路由。</p><p>互联网（internet）&#x3D; 网络之网络</p><h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>聚合路由器为每一个区域：自治系统AS(autonomous systems)</p><p>同一AS内的路由器运行相同的路由算法</p><p><strong>自治系统内部路由协议</strong></p><p>不同的额自治系统内的路由器可以运行不同的AS内部路由协议</p><h3 id="网关路由器"><a href="#网关路由器" class="headerlink" title="网关路由器"></a>网关路由器</h3><p>位于AS边缘</p><p>通过链路连接其他AS网关路由器 可以和其他的网关路由器之间交换信息</p><h3 id="互联的AS"><a href="#互联的AS" class="headerlink" title="互联的AS"></a>互联的AS</h3><p>一方面要通过自治系统来决定AS间的路由算法来共同配置</p><ul><li>AS内部的路由算法设置AS内部目的网络路由入口(entries) </li><li>AS内部路由算法和AS间的路由算法共同设置AS外部网络路由入口</li></ul><h2 id="自治系统内的路由任务"><a href="#自治系统内的路由任务" class="headerlink" title="自治系统内的路由任务"></a>自治系统内的路由任务</h2><p>假设AS1内部的某个路由器收到一个目的地址在AS1之外的数据报：</p><ul><li>路由器应该将该数据包转发给哪个网关路由器呢？</li></ul><h3 id="AS1（其中一个自治系统）必须："><a href="#AS1（其中一个自治系统）必须：" class="headerlink" title="AS1（其中一个自治系统）必须："></a>AS1（其中一个自治系统）必须：</h3><ol><li><p>学习到哪些目的网络可以通过AS2到达，哪些可以通过AS3到达</p></li><li><p>将这些网络可达性信息传播给AS1内部路由器</p></li><li><p>自治系统间的路由任务！</p></li></ol><p>路由器1d的转发表设置</p><p>假设AS1学习到(通过AS间的路由协议)：子网X可以通过AS3（网关1C）到达，但是不呢个通过AS2到达</p><ul><li>AS间路由协议向所有内部路由器传播可达性信息</li></ul><p>路由器1d：利用AS内部路由信息，确定其到达1c的最小费用路径接口</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029222810.png"                      alt="image.png"                ></p><h2 id="在多个AS之间选择"><a href="#在多个AS之间选择" class="headerlink" title="在多个AS之间选择"></a>在多个AS之间选择</h2><p>假设AS1通过AS间的路由协议学习到：子网X通过AS3和AS2均可以到达</p><p>为了配置转发表，路由器1d必须确定应该将去往子网X的数据包转发给哪个网关？</p><ul><li>这个任务也是由AS之间的路由协议完成！</li></ul><p><strong>热土豆路由</strong>：将分组发送给最近的网关路由器</p><blockquote><p>[!过程]</p><ol><li>通过AS间的路由协议学习到：子网X可以通过多个网关到达</li><li>利用通过AS内路由协议获得的路悠悠喜喜确定到达每个网关的最小费用的费用</li><li>热土豆路由：选择最小费用路径的费用最小的网关</li><li>通过转发表，确定去往最小费用网关的接口&#x2F;.在转发表中增加入口：（x,l）</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-传输层学习笔记</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>传输层位于应用层和网络层之间。在两个<code>应用层之间</code>提供进程到进程服务，一个进程在<strong>本地主机</strong>，另一个在<strong>远程主机</strong>，使用逻辑链接提供通信。</p><h3 id="传输层服务"><a href="#传输层服务" class="headerlink" title="传输层服务"></a>传输层服务</h3><p><strong>传输层负责向应用层提供服务</strong></p><h4 id="进程到进程通信"><a href="#进程到进程通信" class="headerlink" title="进程到进程通信"></a>进程到进程通信</h4><p><strong>首要任务</strong>：进程到进程通信（process-to-process communicaiton）</p><p><strong>进程</strong>：使用传输层服务的应用层实体（运行的程序）</p><p><strong>主机到主机 vs 进程到进程</strong>：</p><ul><li><code>网络层</code>可以负责主机到主机的通信。网络层协议只把报文传递给目的计算机，但是这不是完整的传输。</li><li>报文要递交给正确的进程  $\rightarrow$ <em><u>传输层接管的部分</u></em></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694499016606.png"                      alt="1694499016606" style="zoom:67%;"                 ><h4 id="寻址：端口号"><a href="#寻址：端口号" class="headerlink" title="寻址：端口号"></a>寻址：端口号</h4><p>最常用的方式实现进程到进程通信：<strong>客户-服务器模式</strong></p><p>两个进程有相同的名字: </p><p>ex. (client)Daytime $\iff$ (remote)Daytime </p><p>远程计算机可以<code>运行多个服务器程序</code>，就像许多本地计算机可以在同一时间运行一个或者多个客户应用程序一样。</p><p>通信：需要 <strong>本地主机</strong>、<strong>本地进程</strong>、<strong>远程主机</strong>、<strong>远程进程</strong></p><p><em>Chapter 4 mention</em>: 用<code>IP地址</code>来定义本地主机和远程主机</p><p>服务器进程必须用一个<code>端口号</code>定义自己。端口号 &#x3D; 0~65535之间的16位整数</p><p>客户程序用端口号来定义自己，称为<strong>临时端口号</strong>。临时是因为客户的生命周期通常很短。临时端口号大于1023。</p><p><strong>熟知端口号</strong>：全局端口号</p><p>每一个客户进程都知道相应服务器进程的数值端口号。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694500506986.png"                      alt="1694500506986"                ></p><h4 id="ICANN范围"><a href="#ICANN范围" class="headerlink" title="ICANN范围"></a>ICANN范围</h4><p>把端口号划分成为三种范围：熟知的、注册的、动态的（或者私有的）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694502306396.png"                      alt="1694502306396"                ></p><p><strong>熟知端口</strong>：端口号范围是1~1023，<strong>由ICANN分配和控制</strong>，这些事熟知的端口号</p><p><strong>注册端口</strong>：端口号的范围是1024~49151。<strong>ICANN不分配也不控制</strong>，它们可以在ICANN注册以免重复。</p><p><strong>动态端口</strong>：可以由任何进程使用，是临时或者私有端口号。</p><p><em>套接字地址</em></p><p>TCP协议簇中的传输层协议需要IP地址和端口号，它们各在一端建立一条连接。一个IP地址和一个端口号结合起来就称为<strong>套接字地址</strong>（socket address），<strong>客户套接字地址</strong><code>唯一</code>定义了<code>客户的进程</code>，而<strong>服务器套接字地址</strong>唯一的定义了<code>服务器进程</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/1694502647464.png"                      alt="1694502647464"                ></p><p><strong>一对套接字地址</strong>：客户套接字地址和服务器套接字地址。这四条信息是网络层分组头部和传输层分组头部的组成部分。</p><p>这四条信息是网络层分组头部和传输层分组头部的组成部分。第一个头部包含IP地址，第二个头部包含端口号。</p><h3 id="封装和解封装"><a href="#封装和解封装" class="headerlink" title="封装和解封装"></a>封装和解封装</h3><p>将报文从一个进程发送到另一个进程，传输层协议负责封装报文。</p><p>传输层的分组称为<code>用户数据报</code>、<code>段</code>、<code>分组</code></p><p>在一般讨论中，将传输层有效载荷称为分组。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-以太网</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BB%A5%E5%A4%AA%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>”统治地位“的有线LAN技术</p><p>造价低廉</p><p>应用最广泛的LAN技术</p><p>比令牌局域网和ATM等更简单、便宜</p><p>满足网络速率需求：10Mbps ~ 10Gbps</p><h2 id="以太网：物理拓扑"><a href="#以太网：物理拓扑" class="headerlink" title="以太网：物理拓扑"></a>以太网：物理拓扑</h2><h3 id="总线（bus）"><a href="#总线（bus）" class="headerlink" title="总线（bus）"></a>总线（bus）</h3><p>总线：上世纪90奶奶带中期之前流行</p><p>所有节点在同一个冲突域内（可能产生冲突）</p><h3 id="星型（star）"><a href="#星型（star）" class="headerlink" title="星型（star）"></a>星型（star）</h3><p>中心交换机</p><p>每个节点一个单独的冲突域（结点之间彼此不冲突）</p><h2 id="以太网：不可靠无连接服务"><a href="#以太网：不可靠无连接服务" class="headerlink" title="以太网：不可靠无连接服务"></a>以太网：不可靠无连接服务</h2><p><strong>无连接</strong>：发送帧的网课和接收帧的网卡之间没有”握手“过程</p><p><strong>不可靠</strong>：接收网课不向发送网卡进行确认</p><ul><li>差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议（TCP），否则，发生数据丢失</li></ul><p>以太网的MAC协议：采用二进制指数退避算法的CSMA&#x2F;CD</p><h2 id="以太网的CSMA-CD算法"><a href="#以太网的CSMA-CD算法" class="headerlink" title="以太网的CSMA&#x2F;CD算法"></a>以太网的CSMA&#x2F;CD算法</h2><ol><li>NIC从网络层接收数据报，创建数据帧；</li><li>监听信道：<br>如果NIC监听到信道空闲，就开始发送数据帧</li><li>NIC发送完整个帧，而没有检测到其他结点的数据发送，则NIC确认帧发送成功</li><li>如果NIC检测到其他结点传输数据，则中止发送并发送堵塞信号 (jamsignal)</li><li>中止发送后，NIC进入二进制指数退避:<ul><li>第m次连续冲突之后：<ul><li>n &#x3D; Max(m,10)</li><li>NIC 从{}0，1，2，……，$2^n$-1}中随机的选择一个数K</li><li>NIC等待K·512比特的传输延迟时间，再返回第2步</li></ul></li><li>连续冲突次数越多，平均等待时间越长。</li></ul></li></ol><p>发送端</p><h2 id="以太网的帧结构"><a href="#以太网的帧结构" class="headerlink" title="以太网的帧结构"></a>以太网的帧结构</h2><p>发送端网卡将IP数据报(或其他网络层协议分组)封装到以太网帧中：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101213538.png"                      alt="image.png"                ></p><h3 id="前导码-Preamble-8B"><a href="#前导码-Preamble-8B" class="headerlink" title="前导码(Preamble)(8B)"></a>前导码(Preamble)(8B)</h3><p>7个字节的10101010，第8字节为10101011<br>用于发送端与接收端的时钟同步</p><h3 id="目的MAC地址、源MAC地址-各6B"><a href="#目的MAC地址、源MAC地址-各6B" class="headerlink" title="目的MAC地址、源MAC地址(各6B)"></a>目的MAC地址、源MAC地址(各6B)</h3><p>如果网卡的MAC地址与收到的倾的目的MAC地址匹配，或者顿的目的MAC地址为广播地址(FF-FF-FF-FF-FF-FF)，则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议。</p><h3 id="类型-Type-2B"><a href="#类型-Type-2B" class="headerlink" title="类型(Type)(2B)"></a>类型(Type)(2B)</h3><p>指示中封装的是哪种高层协议的分组(如，IP数据报、Novell IPX数据报、AppleTalk数据报等)</p><h3 id="数据-Data-46-1500B-指上层协议载荷"><a href="#数据-Data-46-1500B-指上层协议载荷" class="headerlink" title="数据(Data)(46-1500B): 指上层协议载荷"></a>数据(Data)(46-1500B): 指上层协议载荷</h3><p>R&#x3D;10Mbps，RTTmax&#x3D;512$\mu s$，Lmin &#x2F; R &#x3D; RTTmax<br>in&#x3D;512bits&#x3D;64B，Datamin&#x3D;Lmin-18&#x3D;46B</p><h3 id="CRC-4B-循环余校验码"><a href="#CRC-4B-循环余校验码" class="headerlink" title="CRC(4B): 循环余校验码"></a>CRC(4B): 循环余校验码</h3><p>丢弃差错帧</p><h2 id="802-3以太网标准：链路和物理层"><a href="#802-3以太网标准：链路和物理层" class="headerlink" title="802.3以太网标准：链路和物理层"></a>802.3以太网标准：链路和物理层</h2><p>许多不同的以太网标准</p><ul><li>相同的MAC协议和帧格式</li><li>不同速率: 2 Mbps,10 Mbps,100 Mbps，1 Gbps, 10 Gbps</li><li>不同物理介质: 光纤,线缆</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-交换机</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BA%A4%E6%8D%A2%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>链路层设备</p><ul><li>存储-转发以太网帧</li><li>检验到达帧的目的MAC地址，选择性(selectively) 向一个或多个输出链路转发帧</li><li>利用CSMA&#x2F;CD访问链路，发送帧</li></ul><p>透明(transparent)</p><ul><li>主机感知不到交换机的存在</li></ul><p>即插即用(plug-and-play)</p><p>自学习(self-learning)</p><ul><li>交换机无需配置</li></ul><h2 id="交换机：多端口之间同时传输"><a href="#交换机：多端口之间同时传输" class="headerlink" title="交换机：多端口之间同时传输"></a>交换机：多端口之间同时传输</h2><p>主机利用独享(dedicated)链路直接连接交换机</p><p>交换机缓存帧</p><p>交换机在每段链路上利用CSMA&#x2F;CD收发帧，但无冲突，且可以全双工</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101214415.png"                      alt="image.png"                ></p><p><strong>交换(switching)</strong>:A-A’与B-B’的传输可以同时进行，没有冲突</p><h2 id="交换机转发表：交换表"><a href="#交换机转发表：交换表" class="headerlink" title="交换机转发表：交换表"></a>交换机转发表：交换表</h2><p>Q: 交换机怎么知道A’可以通过接口4到达，而B’可以通过接口5到达?</p><p>A: 每个交换机有一个交换表(switch table), 每个入口(entry):</p><ol><li>(主机的MAC地址，到达主机的接口,时间戳)</li><li>看起来很像路由表!</li></ol><p>Q: 交换表入口信息如何创建和维护的?类似于路由协议?</p><h2 id="交换机：自学习"><a href="#交换机：自学习" class="headerlink" title="交换机：自学习"></a>交换机：自学习</h2><p>交换机通过自学习，获知到达主机的接口信息</p><ul><li><p>当收到顿时，交换机“学习”到发送顿的主机(通过顿的源MAC地址)，位于收到该顿的接口所连接的LAN网段</p></li><li><p>将发送主机MAC地址&#x2F;接口信息记录到交换表中</p></li></ul><h2 id="交换机：帧过滤-转发"><a href="#交换机：帧过滤-转发" class="headerlink" title="交换机：帧过滤&#x2F;转发"></a>交换机：帧过滤&#x2F;转发</h2><p>当交换机收到帧:</p><ol><li><p>记录帧的源MAC地址与输入链路接口</p></li><li><p>利用目的MAC地址检索交换表</p></li><li><p>if 在交换表中检索到与目的MAC地址匹配的入口(entry)<br>then {<br>if 目的主机位于收到帧的网段<br>then 丢弃帧<br>else 将帧转发到该入口指向的接口<br>}<br> else 泛洪(flood)</p></li></ol><h2 id="自学习和转发过程举例"><a href="#自学习和转发过程举例" class="headerlink" title="自学习和转发过程举例"></a>自学习和转发过程举例</h2><p>假设交换表初始的时候为空。</p><p>目的MAC地址A’，位置未知:泛洪</p><p>目的MAC地址A，位置已知:选择性转发</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101215158.png"                      alt="image.png"                ></p><h2 id="交换机互联"><a href="#交换机互联" class="headerlink" title="交换机互联"></a>交换机互联</h2><p>交换机可以互联</p><p>层级结构</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101215252.png"                      alt="image.png"                ></p><p>交换机可以互联</p><p>Q: 当A向G发送帧时，S1怎么知道通过S4转发?S4又怎么知道通过S3,转发?</p><p>A：自学习!(工作过程与单一交换机情形相同!)</p><p>Q: 请给出S,S,S,S的交换表，并说明帧的转发过程?</p><h2 id="组织机构-Institutional-网络"><a href="#组织机构-Institutional-网络" class="headerlink" title="组织机构(Institutional)网络"></a>组织机构(Institutional)网络</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101215459.png"                      alt="image.png"                ></p><p>称这个IP子网为广播域</p><h2 id="交换机-vs-路由器"><a href="#交换机-vs-路由器" class="headerlink" title="交换机 vs 路由器"></a>交换机 vs 路由器</h2><p>两者均为存储-转发设备：<br>路由器: 网络层设备(检测网络层分组首部)<br>交换机: 链路层设备(检测链路层帧的首部)</p><p>二者均使用转发表:<br>路由器: 利用路由算法(路由协议)计算(设置), 依据IP地址<br>交换机: 利用自学习、泛洪构建转发表，依据MAC地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101220011.png"                      alt="image.png"                ></p><h2 id="网络设备对比"><a href="#网络设备对比" class="headerlink" title="网络设备对比"></a>网络设备对比</h2><table><thead><tr><th align="left"></th><th align="left">集线器</th><th align="left">交换机</th><th align="left">网桥</th><th align="left">路由器</th></tr></thead><tbody><tr><td align="left">层次</td><td align="left">1</td><td align="left">2</td><td align="left">3</td><td align="left">4</td></tr><tr><td align="left">流量</td><td align="left">no</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">广播域隔离</td><td align="left">no</td><td align="left">no</td><td align="left">no</td><td align="left">yes</td></tr><tr><td align="left">即插即用</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">优化路由</td><td align="left">no</td><td align="left">no</td><td align="left">no</td><td align="left">yes</td></tr><tr><td align="left">直通传输</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left">no</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week9-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week9-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week9-Class/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>以太网中采用二进制指数后推算法处理冲突问题。</p><p>链路层能够提供的可能服务有哪些？其中可靠传输服务，在传输层也同样提供，那么链路层的可靠传输服务是不是必要？传输层的可靠传输理论以及方法是否适用于链路层？ </p><p>链路层能够提供的可能服务包括以下几个方面：</p><ol><li><p>提供透明可靠的数据传输服务：链路层向网络层提供了透明可靠的数据传输服务，确保数据能够从发送方传输到接收方。</p></li><li><p>差错检测和纠正：链路层通过使用差错检测和纠正方法，对传输过程中可能出现的错误进行检测和纠正，从而保证数据传输的可靠性。</p></li><li><p>帧同步和流量控制：链路层在数据传输过程中能够进行帧同步和流量控制，确保数据的顺序和速率统一。</p></li></ol><p>传输层也可以提供可靠传输服务，但链路层的可靠传输服务并不是必要的。传输层的可靠传输服务更加高级和复杂，可以处理端到端的可靠传输问题。</p><p>传输层的可靠传输理论和方法并不一定适用于链路层。链路层的可靠传输服务更加专注于在链路层中处理数据传输的可靠性，与传输层的可靠传输服务有所不同。链路层使用的纠错方法和协议可能与传输层不同，具体取决于传输介质和网络需求。</p><p>为什么同时使用MAC地址和IP地址？为什么不止使用MAC地址或者只使用IP地址？</p><p>如何实现差错控制(差错纠正策略)？可以采用哪些协议？ </p><p>差错控制是为了处理在数据传输过程中可能发生的差错，包括差错检测和差错纠正。可以采用以下策略实现差错控制：</p><ol><li><p>差错检测：通过添加冗余信息来判断数据是否遭到损坏。</p><ul><li><p>校验和：将数据划分为多个块，并计算每个块的和，将和值附加到数据中。</p></li><li><p>循环冗余检验 (CRC)：使用多项式除法来计算校验码，并将其附加到数据中。</p></li></ul></li><li><p>差错纠正：不仅能检测出差错，还能进行纠正。</p><ul><li><p>汉明码：通过在数据中添加冗余位来纠正错误，并检测出多位错误。</p></li><li><p>奇偶校验：通过添加一个奇偶位来检测和纠正单个比特错误。</p></li></ul></li></ol><p>差错控制可以应用于不同的协议和通信网络中，包括：</p><ul><li><p>TCP (传输控制协议)：在数据通信过程中通过使用序列号、确认应答和重传机制来实现差错控制。</p></li><li><p>UDP (用户数据报协议)：提供差错检测功能，但不支持差错纠正。</p></li><li><p>ARQ (自动重传请求)：一种协议，通过请求重传错误的数据包来实现差错控制。</p></li></ul><p>来源：</p><ul><li><p><a class="link"   href="https://baike.baidu.com/item/%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF/16382947" >TCP、UDP与ARQ错误控制 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p><a class="link"   href="https://blog.csdn.net/abbcdc/article/details/108737703#pn%EF%BC%81M" >差错控制的方法与技术 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ul><p>随机访问MAC怎么检测冲突？ </p><p>要检测随机访问MAC的冲突，可以采取以下方法：</p><ol><li><p>使用MAC地址检测工具：可以使用专门的MAC地址检测工具来检测MAC冲突。这些工具可以扫描局域网上的设备，并检查是否有重复的MAC地址。一旦发现重复的MAC地址，就可以确定发生了冲突。</p></li><li><p>查看网络设备日志：路由器或交换机上的日志记录可能会显示有关MAC地址冲突的信息。通过查看日志，可以了解到是否发生了冲突以及冲突的具体信息。</p></li><li><p>使用网络分析工具：可以使用网络分析工具来监测网络流量和活动。这些工具可以检测到连续的MAC冲突，通过分析网络流量，可以确定冲突的设备和触发冲突的原因。</p></li></ol><p>以上是一些常见的检测随机访问MAC冲突的方法，可以根据具体的需求和网络环境选择合适的方法进行检测。</p><p>总结两个轮转访问MAC协议，轮询和令牌传递的共同点和不同点，并设计一个轮转访问的MAC协议？ </p><p>轮询和令牌传递是两种常见的轮转访问MAC协议。它们的共同点是都采用了轮流访问的方式来协调多个设备之间的数据传输。然而，它们在实现细节和工作原理上有一些区别。</p><p>共同点：</p><ol><li><p>轮询和令牌传递都是使用轮流访问的方式，按照特定的顺序依次控制设备的访问，使每个设备都能有机会传输数据。</p></li><li><p>两种协议都能避免设备之间的冲突和碰撞，提高网络的效率。</p></li></ol><p>不同点：</p><ol><li><p>轮询协议是由一个中心设备（通常是主机或主控器）负责控制访问顺序，按照预定的顺序对每个设备进行轮询。而令牌传递协议则是通过传递令牌的方式来控制设备的访问顺序，只有拥有令牌的设备才能传输数据。</p></li><li><p>在轮询协议中，当一个设备完成数据传输后，控制权会立即转移到下一个设备。而在令牌传递协议中，只有拥有令牌的设备才能传输数据，其他设备需要等待令牌传递到自己才能进行传输。</p></li><li><p>轮询协议可以更灵活地控制设备的访问顺序，可以根据设备的优先级或其他因素来调整轮询顺序。而令牌传递协议的访问顺序是固定的，由令牌的传递顺序决定。</p></li></ol><p>设计一个轮转访问的MAC协议：</p><p>以下是一个简单的轮转访问的MAC协议设计示例：</p><ol><li><p>定义一个主控设备，负责控制轮询顺序。</p></li><li><p>所有参与传输的设备按照预定顺序排列，每个设备分配一个唯一的标识符。</p></li><li><p>主控设备按照设备的顺序轮询，依次给每个设备分配传输时间窗口。</p></li><li><p>在每个时间窗口内，设备可以传输数据或请求传输数据。</p></li><li><p>设备根据自己的需求在分配的时间窗口内进行数据传输。</p></li><li><p>主控设备根据轮询顺序不断循环，确保每个设备都有机会传输数据。</p></li><li><p>如果有新设备接入或有设备离开，主控设备需要更新轮询顺序。</p></li></ol><p>这个设计示例基于轮询的方式，通过主控设备控</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week8-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week8-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week8-Class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p><strong>通过DHCP动态分配IP地址过程中需要交换哪些DHCP报文？这些报文直接封装到哪个协议的数据包中？封装这些报文的IP数据包的目的IP是什么？为什么？</strong> </p><p>在DHCP动态分配IP地址过程中，需要交换以下几种DHCP报文：</p><ol><li>DHCP发现报文（DHCP Discover）：客户端发送此报文以发现可用的DHCP服务器。</li><li>DHCP提供报文（DHCP Offer）：DHCP服务器在收到DHCP发现报文后，向客户端发送此报文，提供可用的IP地址租约。</li><li>DHCP请求报文（DHCP Request）：客户端在收到DHCP提供报文后，向选定的DHCP服务器发送此报文，请求分配给自己的IP地址。</li><li>DHCP确认报文（DHCP Acknowledgement）：DHCP服务器在收到DHCP请求报文后，向客户端发送此报文，确认分配给客户端的IP地址租约。<br>这些DHCP报文被封装在IP数据包中，使用的是UDP协议。UDP协议位于IP协议之上，为DHCP报文提供可靠的数据传输。<br>封装这些DHCP报文的IP数据包的目的IP是广播地址（255.255.255.255），因为客户端在初始化阶段没有分配的IP地址，所以只能使用广播地址发送DHCP报文，以便DHCP服务器能够接收并回复。通过使用广播地址，确保DHCP服务器能够接收到相应的报文，进而进行IP地址的分配和交换。</li></ol><p><strong>一个路由器在转发IP分组的时候IP分组的哪些字段会发生修改？如何修改？</strong> </p><p>在转发IP分组时，路由器会根据目标IP地址和路由表进行转发决策，并且可能会修改IP分组的一些字段。被修改的字段包括：</p><ol><li>TTL字段：TTL（Time to Live）字段表示IP分组在网络中能够经过的最大跳数，每经过一个路由器，TTL字段的值会减一。路由器在转发IP分组时，会将TTL减一，并重新计算校验和。</li><li>源IP地址字段：通常情况下，路由器不会修改源IP地址字段，它会保留原始的源IP地址。</li><li>目标IP地址字段：路由器会根据目标IP地址进行转发决策，并将目标IP地址字段更新为下一跳路由器的IP地址。</li><li>校验和字段：路由器在转发IP分组时，会重新计算校验和字段，以保证数据完整性。<br>以上是常见的修改字段的情况，实际上，路由器在转发IP分组时可能还会修改其他字段，具体修改方式取决于路由器的配置和网络环境。</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231019110039.png"                      alt="image.png" style="zoom:50%;"                 ><p><strong>如果两个均使用私有IP地址的主机需要进行P2P通信？可能会遇到什么问题？怎么解决？</strong> </p><p>如果两个均使用私有IP地址的主机需要进行P2P通信，可能会遇到以下问题：</p><ol><li>NAT（网络地址转换）阻止了直接的通信：私有IP地址不能在Internet上直接路由。当两个主机试图通过NAT网关进行通信时，通常会被NAT阻止。</li><li>防火墙阻塞了P2P连接：防火墙可能会屏蔽P2P连接，以保护网络的安全性。</li></ol><p>为了解决这些问题，可以采取以下方法：</p><ol><li>使用UPnP（通用即插即用）：通过启用UPnP功能，可以自动配置NAT设备，允许P2P通信。</li><li>使用端口映射：将P2P应用程序使用的端口映射到NAT设备上。这样，P2P通信的数据包就可以正确地路由到私有IP地址的主机。</li><li>使用中继服务器：如果两个主机无法直接通信，可以借助第三方中继服务器来中转通信。中继服务器将两个主机之间的数据包进行转发，使得通信得以建立。</li><li>穿越防火墙：使用一些特殊技术和协议，如STUN、TURN和ICE等，可以在防火墙后建立P2P连接，使得私有IP地址的主机能够直接通信。</li></ol><p>请注意，每种方法的适用性和实施方式可能因网络环境和设备配置而异。具体的实施需要根据实际情况进行调整。</p><h2 id="NAT穿透问题"><a href="#NAT穿透问题" class="headerlink" title="NAT穿透问题"></a>NAT穿透问题</h2><p>一定会有在外面有公网地址，在支持NAT的另一端，这时候需要转换。但是这是一个一对多的问题，因为私网IP是可以重复的，所以需要端口来辅助完成区别。静态配置：端口映射。</p><p>某校园网有两个局域网，通过路由器R1&#x2F;R2&#x2F;R3互联之后接入Internet,S1和S2为以太网交换机，局域网采用静态IP地址配置。</p><ol><li>为了让H2和H3能够访问Web服务器，R2需要进行什么配置？</li></ol><p><strong>可以利用ICMP协议实现哪些网络监测功能？怎么实现？</strong> </p><p>ICMP协议可以实现以下网络监测功能：</p><ol><li><p><strong>Ping（网络连通性测试）</strong>：使用ICMP Echo请求消息来检测目标主机是否在线。Ping命令发送ICMP Echo请求消息到目标主机，目标主机接收到请求后返回ICMP Echo应答消息。</p></li><li><p><strong>Traceroute（路径追踪）</strong>：通过使用ICMP的Time-to-Live（TTL）字段，从源主机向目标主机发送一系列的UDP数据包。每个数据包在传输过程中的路由器都会将TTL减少，直到它达到0并被丢弃。源主机通过检测收到的ICMP TTL超时消息来确定数据包传输路径。</p></li><li><p><strong>ICMP Jitter（延迟测量）</strong>：利用ICMP消息的传输延迟来测量网络性能。通过发送ICMP Echo请求消息并记录请求发送和接收之间的时间差来获取延迟信息。</p></li></ol><p>实现上述功能的方法如下：</p><ul><li><p>Ping：使用ping命令或编写程序发送ICMP Echo请求消息，并接收目标主机的ICMP Echo应答消息。</p></li><li><p>Traceroute：使用traceroute命令或编写程序发送一系列的UDP数据包，并监听接收到的ICMP TTL超时消息，记录路由路径。</p></li><li><p>ICMP Jitter：通过编写程序发送ICMP Echo请求消息，并记录请求发送和接收之间的时间差，计算延迟值。</p></li></ul><p>参考来源：</p><ul><li><p><a class="link"   href="https://info.support.huawei.com/info-finder/encyclopedia/zh/ICMP.html" >ICMP协议简介 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p><a class="link"   href="https://zhuanlan.zhihu.com/p/369623317" >ICMP协议的应用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ul><p>距离向量路由算法可能产生什么问题，怎么会发生这样的问题？怎么消除这个问题？  </p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week7-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week7-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week7-Class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>Q1: 虚电路的VCID如何取值？在每段物理链路上都相同吗？为什么？ </p><p>VCID的取值方式是由ATM网络设备或协议规范来定义的。通常，VCID的取值范围是0到65535，但具体取值范围可以根据设备和网络配置而有所不同。在同一段物理链路上，不同虚电路的VCID通常是不同的。这是因为VCID的主要作用是用来区分不同的虚电路，如果在同一物理链路上有多个虚电路，它们需要具有不同的VCID，以便网络设备能够正确地路由和交换数据。</p><p>Q2: IP分片在哪里重组？为什么？ </p><p>IP分片是在网络层（第三层）上实现的。当一个IP数据报的大小超过了网络的最大传输单元（MTU）时，它会被分割成更小的片段，以适应网络的限制。每个分片都会被独立地发送到目标主机。IP分片是为了解决不同网络链路上的最大传输单元（MTU）不一致的问题。如果一个IP数据报的大小超过了链路上的MTU，它将被分割成更小的片段进行传输。这样可以确保数据能够通过链路传输，并且在目标主机上进行重组，还原为原始的数据报。</p><p>Q3: 请将192.168.1.0&#x2F;24剩余IP地址分配给局域网1<del>3，其中局域网1需要IP地址数不少于60个，局域网2、3需要IP地址不少于30个。说明局域网1</del>3的子网地址、广播地址、子网掩码、可分配的IP地址数和范围。</p><p>Q4：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231012111929.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week5-Class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week5-Class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week5-Class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<blockquote><p>[!QUEATION]<br>TCP如何进行流量控制，可能存在什么问题？</p><ul><li><strong>糊涂窗口综合症</strong>（ <em>Sillly Window Syndrome</em> ）<ul><li>是发送方引起的</li><li>telnet 远程登陆，执行一种远程的终端，过程当中计算机只是作为终端来给远程的服务器交换数据。</li><li>Nagle算法：报文段一定长度之后再发送</li></ul></li></ul></blockquote><p><strong>TCP协议为什么要用三次握手建立连接？四次挥手断开连接？连接建立和断开的过程的序号怎么变化？</strong> </p><p>TCP协议使用三次握手建立连接的主要原因是为了确保双方能够正常通信并同步序号和确认号。三次握手的过程包括：</p><ol><li><p>客户端发送一个SYN包到服务器，其中包含一个初始化的序号（ISN）。</p></li><li><p>服务器收到SYN包后，回复一个SYN-ACK包给客户端，确认连接请求，并为自己建立连接。</p></li><li><p>客户端收到SYN-ACK包后，再发送一个ACK包给服务器，确认收到服务器的确认，并建立连接。</p></li></ol><p>四次挥手用于断开连接时，是因为在客户端请求断开时，服务器可能还有数据未发完，所以需要分开操作：</p><ol><li><p>客户端发送一个FIN包到服务器，请求关闭连接。</p></li><li><p>服务器收到FIN包后，回复一个ACK包给客户端，表示同意对方关闭连接，但服务器可能还有数据需要发送。</p></li><li><p>服务器发送完未发送的数据后，发送一个FIN包给客户端，表示自己也请求关闭连接。</p></li><li><p>客户端收到FIN包后，回复一个ACK包给服务器，确认关闭连接。</p></li></ol><p>在连接建立和断开的过程中，序号的变化如下：</p><ul><li><p>连接建立时，客户端和服务器分别使用随机的初始序号（ISN）作为起始序号。</p></li><li><p>在数据传输过程中，序号根据发送和接收的数据包数量以及数据包的长度进行递增。</p></li><li><p>在连接断开时，通过发送和确认FIN包，最后一个的确认号（ACK）将成为下一个会话的初始序号。</p></li></ul><p>来源：<a class="link"   href="https://zhuanlan.zhihu.com/p/108504297" >TCP三次握手，四次挥手的原理及过程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p><strong>网络拥塞控制可以有哪些策略？</strong> </p><p>网络拥塞控制可以采用以下策略：</p><ol><li><p>慢开始：慢开始算法的思路是当主机开始发送数据时，先试探一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。<a class="link"   href="https://blog.csdn.net/qq_27198345/article/details/107848405#:~:text=1%20%E6%85%A2%E5%BC%80%E5%A7%8B%20%EF%BC%9A%E6%85%A2%E5%BC%80%E5%A7%8B%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF%E6%98%AF%E5%BD%93%E4%B8%BB%E6%9C%BA%E5%BC%80%E5%A7%8B%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%AB%8B%E5%8D%B3%E6%8A%8A%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E5%88%B0%E7%BD%91%E7%BB%9C%EF%BC%8C%E9%82%A3%E4%B9%88%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BC%95%E8%B5%B7%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%EF%BC%8C%E5%9B%A0%E4%B8%BA%E7%8E%B0%E5%9C%A8%E8%BF%98%E4%B8%8D%E7%9F%A5%E9%81%93%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5%E3%80%82%E7%BB%8F%E9%AA%8C%E8%A1%A8%E6%98%8E%EF%BC%8C%E8%BE%83%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E5%85%88%E8%AF%95%E6%8E%A2%E7%B4%A2%EF%BC%8C%E5%8D%B3%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E9%80%90%E6%AC%A1%E5%A2%9E%E5%A4%A7%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%E6%95%B0%E5%80%BC%E3%80%82" >来源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。<a class="link"   href="https://zhuanlan.zhihu.com/p/97709686" >来源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>快重传与快恢复：快重传（Fast Retransmit）是一种拥塞控制算法，能够快速恢复丢失的数据包。快恢复（Fast Recovery）算法用于在拥塞控制时快速恢复拥塞窗口的值。<a class="link"   href="https://blog.csdn.net/qq_27198345/article/details/107848405#:~:text=4%20%E5%BF%AB%E5%8E%9F%E5%A4%8D%E5%8E%9F%EF%BC%88Fast%20Recovery%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%8C%E5%AE%83%E8%83%BD%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E3%80%82" >来源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li><li><p>拥塞检测与拥塞通知：拥塞检测与拥塞通知算法用于检测网络中的拥塞和通知相关主机降低数据发送速率。这可以通过网络设备或协议来实现。<a class="link"   href="https://zhuanlan.zhihu.com/p/28593966" >来源 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ol><p>请注意，以上策略不是所有的拥塞控制算法都会使用，具体的具体拥塞控制算法有不同的实现方式和策略。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Week3-class</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week3-class/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week3-class/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>RDT数据是可能出错的，如何判断出错，所以需要校验机制；使用校验和机制。</p><p>RDT实际上是一种停等协议</p><p>GBN 出错全部重传</p><p>SR 选择重传</p><p>**** 如何理解传输层复用和分用？复用和分用只在传输层进行嘛？可能通过其他方式实现复用和分用嘛？  </p><blockquote><p>传输层的复用和分用是指在传输层中将多个应用程序的数据流进行合并和拆分的过程。复用是指将多个应用程序的数据流合并在一起，使用传输层提供的协议或端口标识符将这些数据流区分开。分用是指将传输层接收到的数据流拆分成多个应用程序的数据流，并将其传递给相应的应用程序。</p><p>传输层复用和分用并不仅限于传输层，还可以通过其他方式实现复用和分用。例如，在应用层中可以使用多路复用技术将多个应用程序的数据流合并在一起，并在传输层使用单个传输层连接进行传输。同样，分用也可以在应用层或其他网络层进行，以将接收到的数据流分发给相应的应用程序或网络节点。</p><p>总结起来，传输层是最常见的实现复用和分用的层次，但复用和分用也可以在其他层次进行实现，以实现合并和拆分数据流的目的。</p></blockquote><h2 id="复用和分用"><a href="#复用和分用" class="headerlink" title="复用和分用"></a>复用和分用</h2><p>FDM 收音机 </p><p><strong>如何理解滑动窗口协议？都会有哪些因素会影响窗口大小的确定？</strong> </p><blockquote><p>滑动窗口协议是一种用于在通信中进行流量控制和可靠数据传输的机制。它通过在发送方和接收方之间维护一个固定大小的窗口来实现流量控制。发送方将数据分割成适当大小的数据块，并通过网络发送给接收方。接收方使用确认应答来告知发送方已经成功接收数据。同时，接收方也会告知发送方当前可接收新数据的窗口大小。</p><p>影响窗口大小确定的因素包括：</p><ol><li><p>网络的带宽和延迟：如果网络带宽较大或延迟较小，窗口大小可以设置得较大，以更高效地利用网络资源。</p></li><li><p>接收方的处理能力：如果接收方处理能力有限，窗口大小应适当减小以防止数据堆积。</p></li><li><p>发送方与接收方之间的网络状况：如果网络不稳定或丢包较多，窗口大小可能需要减小以降低丢包率并提高可靠性。</p></li><li><p>应用程序需求：根据应用程序的特点和需求，可能需要调整窗口大小来达到更好的性能和吞吐量。</p></li></ol></blockquote><p><strong>因素</strong></p><p>缓存</p><p>流量控制</p><p>拥塞控制</p><p><strong>GBN发送窗口</strong></p><ul><li>时延带宽积</li></ul><p><strong>滑动窗口协议大小和序列号比特位数有什么关系？为什么？</strong> </p><p>滑动窗口协议的窗口大小应该小于序列号比特位数的幂，这是为了避免发生溢出情况，确保序列号可以正确的循环使用。如果窗口大小大于序列号比特位数的幂，可能会导致序列号的重叠和混淆，从而引发错误。</p><p>来源：<a class="link"   href="https://zhuanlan.zhihu.com/p/361966436" >https://zhuanlan.zhihu.com/p/361966436 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>$W_s+W_r \leq 2^n$</p><p>$W_s$和$W_r$分别代表的是发送窗口和接收窗口，n代表的是传输位数。</p><p>对于GBN协议 $W_s \leq 2^n-1$</p><p><strong>如何极端停等协议的信道利用率？如何计算滑动窗口协议的信道利用率？怎么理解信道利用率？请给出表达式</strong> </p><p>极端停等协议的信道利用率可以通过以下表达式计算：</p><p>信道利用率 &#x3D; 数据传输时间 &#x2F; (数据传输时间 + 2 * 往返时间)</p><p>滑动窗口协议的信道利用率可以通过以下表达式计算：</p><p>信道利用率 &#x3D; 数据传输时间 &#x2F; (数据传输时间 + 窗口大小 * 往返时间)</p><p>信道利用率是指在一定时间内，实际传输的数据占总传输时间的比例。它是衡量通信系统中信道利用程度的指标。信道利用率越高，表示信道被更有效地利用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Web缓存</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Web%E7%BC%93%E5%AD%98/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Web%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## Web缓存/代理服务器技术<p>功能<br>    - 能够在不访问服务器的前提下满足客户端的HTTP请求</p><p><strong>为什么要发明这种技术</strong></p><p><span style="color:#61ac85">缩短客户请求的响应时间</span><br><span style="color:#61ac85">减少机构&#x2F;组织的流量</span><br><span style="color:#61ac85">在大范围内(Internet)实现有效的内容分发</span></p><p>Web缓存&#x2F;代理服务器**</p><ul><li>用户设定浏览器通过缓存进行Web访问</li><li>浏览器向缓存&#x2F;代理服务器发送所有的HTTP请求<ul><li>如果锁清秋的对象在缓存中给，缓存返回对象</li><li>否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象<br>缓存既充当客户端，也充当服务器<br>一般由ISP(Internet服务提供商架设)</li></ul></li></ul><h2 id="Web缓存示例"><a href="#Web缓存示例" class="headerlink" title="Web缓存示例"></a><strong>Web缓存示例</strong></h2><p><em>假定：</em></p><ul><li>对象的平均大小是1000，000 bit</li><li>机构网络中的浏览器平均每秒有15个到原始服务器的请求</li><li>从机构路由器到原始服务器的往返延迟&#x3D;2s</li></ul><p><em>网络性能分析</em>：<br>局域网（LAN）的利用率&#x3D; (15个请求&#x2F;s) * (1Mb&#x2F;请求) &#x2F; (100Mbps) &#x3D; 15%<br>然而接入链路上的流量强度为 1<br>接入互联网的链路的利用率 &#x3D; 100%<br>总的延迟 &#x3D; 互联网上的延迟 + 访问延迟 +局域网延迟</p><p><strong>$延迟&#x3D; 2s + n \ min+ m \ ms$</strong></p><p>由于局域网上的强度为0.15的通信量最多导致数毫秒的实验，<strong>我们可以忽略局域网的时延</strong>。</p><p>[[CourseNotes&#x2F;计算机网络&#x2F;CN-分组交换网络中的时延、丢包和吞吐量]]</p><p>由于链路上的时延因为利用率的原因会趋于无穷大，所系选哟改进事件响应特性</p><h3 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h3><p>将链路的速率提高，从15Mbps增加到100Mbps。这样可以将介入链路上的流量强度减少到0.15</p><p><strong>缺点</strong>：代价很高</p><h3 id="解决方案2"><a href="#解决方案2" class="headerlink" title="解决方案2"></a>解决方案2</h3><p>安装Web缓存</p><p>假定缓存命中率是0.4</p><h4 id="网络性能分析"><a href="#网络性能分析" class="headerlink" title="网络性能分析"></a>网络性能分析</h4><p>有40%的请求立即得到满足<br>剩下的60%通过原始服务器满足</p><p>接入互联网的链路的利用率下降到 **60%**，从而其延迟可以忽略不计，例如10微秒</p><p><strong>总的平均延迟</strong>：$互联网上的延迟+访问延迟+局域网延迟 &#x3D; 0.6 \times 2.01s +0.4 \times n \ ms &lt;1.4 s$</p><p><strong>内容分发网络</strong>（Content Distribution Network,CDN）</p><h2 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h2><p>景观高速缓存能够减少用户感受到的响应时间，但是也引入了一个新的问题</p><p><strong>数据一致性问题</strong></p><p>HTTP协议有一种机制，允许缓存器确定它的对象是最新的。</p><h3 id="条件Get方法（Conditional-GET）"><a href="#条件Get方法（Conditional-GET）" class="headerlink" title="条件Get方法（Conditional GET）"></a>条件Get方法（Conditional GET）</h3><p>如果：</p><ol><li>请求报文使用的是GET方法</li><li>请求报文中包含一个<code>if-Modified-Since</code>的首部行</li></ol><p>那么这个HTTP报文就是一个条件GET报文</p><h3 id="条件GET方法的操作方式"><a href="#条件GET方法的操作方式" class="headerlink" title="条件GET方法的操作方式"></a>条件GET方法的操作方式</h3><p>一个代理缓存我器代表一个请求浏览器</p><p>向某Web服务器发送一个请求报文：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTP/1.1</span><br><span class="line">Bost: www.exotiquecuisine.com</span><br></pre></td></tr></table></figure></div><p>其次，改web服务器像缓存器发送具有被请求对象的响应报文</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 CR</span><br><span class="line">DATA: Sat,8 Oct 2011 15:39:29</span><br><span class="line">Server : Apache/1.3.0 (Unix)</span><br><span class="line">Last-Modified :Wed, 7 Sep 2011 09:23:24</span><br><span class="line">Content-Type: image/gif</span><br><span class="line"></span><br><span class="line">(data ……)</span><br></pre></td></tr></table></figure></div><p>该缓存器在将该对象转发到请求的浏览器的同时，也在本地缓存了这个对象。<br><strong>更重要的是</strong>缓存器在存储这个对象的时候也存储了最后的修改日期</p><hr><p>一星期之后，另一个用户经过该缓存器上请求同一个对象</p><p>该对象仍然在这个缓存器里面，由于可能被修改，所以缓存器会发送一个条件GET执行最新检查</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /fruit/kiwi.gif HTTP/1.1</span><br><span class="line">Bost: www.exotiquecuisine.com</span><br><span class="line">If-Midified-Since: Wed, 7 Sep 2011 09:23:24</span><br></pre></td></tr></table></figure></div><p>值得注意的是<code>If-Modified-Since</code>刚好等于上个星期的<code>Last-Modified</code>值<br>假设没有被修改，那么Web服务器向该缓存器发送一个响应报文：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 304 Not Modified</span><br><span class="line">DATA: Sat, 15 Oct 2011 15:39:29</span><br><span class="line">Server : Apache/1.3.0 (Unix)</span><br><span class="line"></span><br><span class="line">(EMPTY ENTITY BODY)</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917163130.png"                      alt="Pasted image 20230917163130"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-ReadingComplement</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>TCP发送方必须处理的第三个主要事件：接受方确认的报文段的到达</p><p>当时间发生的时候将ACK y的值和变量SendBase相比较，如果y大于SendBase,也就是说ACK在确认先前没有被确认的报文段，所以更新SendBase为y。</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926144429.png"                      alt="image.png" style="zoom:50%;"                 ><p>A向B发送了序号为92的8字节数据，主机B向A返回ACK&#x3D;100但是在过程中丢失，在超时之后将会进行重传，N再重新传回ACK&#x3D;100</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926144754.png"                      alt="image.png" style="zoom:50%;"                 ><p>可以看出第一次超时两个ACK都没有收到，之后第二次超时重新发送了Seq&#x3D;92,在第二个超时时间内收到ACK&#x3D;120，这样第二个报文段就不会被重传</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926145021.png"                      alt="image.png" style="zoom:50%;"                 ><p>这就和第二种情况中一样，但是ACK在第一次的超时间隔内就就收到了，虽然ACK 100没有正确接收，但是ACK 120正确接收了，说明119之前的所有数据都正确接收了，也就不用重新传输第一段报文</p><p><strong>超时间隔加倍</strong></p><p>每当超时时间发生，重传具有序号最小的还没有被确认的报文段</p><p><code>将超时时间间隔设为先前值的两倍</code></p><p>超时间隔在每次重传之后会呈现指数型增长</p><p>提供了<code>形式受限的拥塞控制</code></p><p><strong>定时器过期很可能是由网络拥塞引起的</strong></p><blockquote><p>[!TIP] 太多的分组到达源和目的地之间路径上的一台（或者多台）路由器的队列中，造成分组丢失或者长时间的排队时延</p></blockquote><p>拥塞的时候，如果源持续重传分组，会让拥塞 <strong>更加严重</strong></p><h2 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a><em><strong>快速重传</strong></em></h2><p>超时周期因为每次的指数形式增长会让超市周期可能相对较长</p><p><strong>增加了端到端的时延</strong></p><p>注意到<strong>冗余ACK</strong>来检测丢包情况</p><blockquote><p>[!TIP] <strong>冗余ACK</strong>代表的是在其确认某个报文段的ACK</p></blockquote><p>当接受方检测到了数据流中的一个间隔，这样就是报文段的丢失。</p><p>TCP不使用否定确认，所以接收方不能向发送方发送一个显示的否定确认（NAK），所以TCP对接收到的最后一个按序字符进行<strong>重复确认</strong></p><p>如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的冗余ACK，可以当作一种指示，这个已经被确认过3次的报文段之后的报文段已经丢失。</p><p>一旦收到3个冗余ACK，TCP就执行<strong>快速重传</strong></p><blockquote><p>[! TIP] 在这个报文段的定时器过期之前重传丢失的报文段  </p></blockquote><p>代表ACK的收到的事件的伪代码</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">event : ACK RECEIVED, with ACK field value of y</span><br><span class="line">if(y &gt; SendBase)&#123;</span><br><span class="line">SendBase = y</span><br><span class="line">if( ther are currently any not yet acknowledged segments)</span><br><span class="line">start timer</span><br><span class="line">&#125;</span><br><span class="line">else &#123; </span><br><span class="line">// 一个对确认过的重复的ACK进行发送了三次</span><br><span class="line">increment number of duplicate ACKs received for y=3</span><br><span class="line">// TCP fast retrasment</span><br><span class="line">resend segment with sequence number y</span><br><span class="line">&#125;</span><br><span class="line">break</span><br></pre></td></tr></table></figure></div><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926184721.png"                      alt="image.png" style="zoom:50%;"                 ><h2 id="是回退N步还是选择重传"><a href="#是回退N步还是选择重传" class="headerlink" title="是回退N步还是选择重传"></a><em><strong>是回退N步还是选择重传</strong></em></h2><p>TCP Sender 只维护 SendBase 和NextSeqNum，所以TCP看起来像是一个GBN风格的协议</p><p><strong>但是和GBN有着显著的区别</strong></p><blockquote><p>[!TIP] TCP实现会将正确接收但是失序的报文段缓存起来。</p></blockquote><p>发送报文段 1，2，3，…… N</p><p>假设分组n &lt; N确认报文丢失，但是其余的确认报文都分别在超时之前到达发送端。</p><p>如果是GBN，就会重传n+1，…… N的所有分组</p><p>但是TCP只会重传分组n，而且如果对报文段n+1的确认报文在报文段n超时之前到达，TCP都不重传报文n</p><p><em><strong>选择确认</strong></em></p><p>允许TCP的接收方有选择的确认失去顺序的报文段</p><p>所以当这个机制和选择重传机制结合起来使用的时候（也就是跳过那些已经被接受方确认过的报文段），TCP看起来就像是SR协议</p><blockquote><p>[!INFO] 所以TCP的差错恢复机制就最好被分类为GBN协议和SR协议的混合体</p></blockquote><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a><strong>流量控制</strong></h2><p>流量控制因此是一个速度匹配服务，也就是发送方的发送速率和接收方的应用程序的读取速率相匹配。</p><p>Previous : TCP发送方也可能因为IP网络的拥塞而被遏制。</p><p>要区分流量控制和拥塞控制</p><h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><p>发送方维护接收窗口的变量来提供流量控制。</p><p>TCP是全双工通信，所以两端都要维护接收窗口</p><p>LastByteRead: 主机B上的应用进程从缓存读出的数据流的最后一个字节的编号</p><p>LastByteRcvd: 从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号</p><p>所以接收的数据的大小是前编号减去最后一个编号也就是 Data &#x3D; LastByteRcvd - LastByteRead</p><p>所以接收窗口大小就等于rwnd &#x3D; RcvBuffer - Data</p><p>接收窗口大小是动态的，开机的时候rwnd &#x3D; RcvBuffer</p><p>A主机跟踪两个变量：LastByteSent &amp; LastByteAcked</p><p>两者之差就是A发送到连接中但是没有被确认的数据量。</p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927110938.png"                      alt="image.png"                ></p><p>就只用研究这一张图</p><p>发起TCP连接，发送SYN信号，接收到SYN 和ACK信号就建立连接</p><p>关闭TCP连接，发送FIN信号，进入FIN等待，接收到ACK确认信号，不发送，再等待FIN，再发送最后一次ACK，等待三十秒然后断开连接。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927111152.png"                      alt="image.png"                ></p><p>监听套接字Socket，进入监听状态；得到SYN信号就发送SYN和ACK，进入下一状态，接收到ACK之后不发送，建立好了连接</p><p>关闭连接的时候，接收到FIN之后就发送ACK，进入等待状态，再次发送FIN，接收到了ACK便不发送，关闭连接。</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p><strong>拥塞原因和代价</strong></p><p>Situation 1 :</p><p><strong>两个发送方和一台无穷大缓存的路由器</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927111847.png"                      alt="image.png"                ></p><p>没有执行差错恢复，不用流量控制和拥塞控制</p><p>吞吐率的上线就是R&#x2F;2，因为这是两条连接之间的共享链路容量造成的。</p><p>而且当发送的速率接近R&#x2F;2的时候，平均排队分组的数量就会无限增长</p><blockquote><p>[!拥塞网络的一种代价]<br>分组的到达速率接近链路容量的时候，分组就会经历巨大的排队时延</p></blockquote><p>Situation 2:</p><p><strong>两个发送方和一台具有有限缓存的路由器</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927112045.png"                      alt="image.png"                ></p><p>假如主机还是用$\lambda_{in}$的速率发送数据，运输层向网络中发送报文段（含有初始数据或者重传数据）的速率用$\lambda^{‘}_{in}$表示，这就被称为<strong>供给载荷</strong></p><p>实现性能完全取决于重传的方式。</p><blockquote><p>[!Graph a)]</p></blockquote><p>Assumption: A能够确定路由器是否空闲，空闲的时候才会发送分组，这样就不会丢包 $\Rightarrow \lambda_{in} &#x3D; \lambda^{‘}_{in}$</p><blockquote><p>这个时候的性能是理想的，也就是说每个分组都能够接收到，但是传输速率吧还是不能超过R&#x2F;2。</p></blockquote><blockquote><p>[!Graph b)]</p><p>More Real : 发送方仅在确定了一个分组已经丢失的时候才重传。</p><p>当供给载荷达到了R&#x2F;2的时候，数据被交付的速率为R&#x2F;3，所以说在0.5R的单位传输中，0.333R字节是初始数据，0.166R字节是重传数据</p></blockquote><blockquote><p>[!INFO]<br><strong>网络拥塞的另一种代价</strong></p><p>发送方必须执行重传来步长因为缓存溢出而丢失的分组</p></blockquote><blockquote><p>[!Graph c)]</p><p>发送方会提前发生超时并重传已经被推迟还没有丢失的分组，也就是初始数据分组和重传分组都可能到达接收方。重传分组将被丢弃。</p><p>假定每个分组被转发两次，当供给载荷接近R&#x2F;2的时候，吞吐量就渐进R&#x2F;4</p></blockquote><blockquote><p>[!INFO]<br><strong>网络拥塞的另一种代价</strong></p><p>发送方在遇到大时延的时候所进行的不必要的重传会引起路由器利用其链路带宽来转发不必要的分组副本。</p></blockquote><p>Situation 3:</p><p><strong>四台主机发送分组，通过交叠的两跳路径传输</strong></p><p>采用超时重传机制实现可靠数据传输</p><p>所有路由器链路容量都是R字节&#x2F;s</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230927113951.png"                      alt="image.png"                ></p><p>A $\to$ C的连接： Router R1&amp;R2</p><p>A-C &amp; D-B and A-C &amp; B-D 连接共享路由器R1，R2 </p><p>如果吞吐量很小，路由器缓存的溢出很少见，所以较小的$\lambda_{in}$会导致$\lambda_{out}$的增大</p><p><strong>当$\lambda_{in}$很大的情况 Consider R2</strong></p><p>到达路由器R2的最大速率就只能是R，当$\lambda^{‘}_{in}$无穷大的时候，此时的A-C链路会因为B-D链路的供给载荷升高而导致吞吐量逐渐减少 $\to 0$</p><p>当有一个分组在第二条路由器上被丢弃的时候，第一条路由器所做的努力都白费了，也就是”劳而无功”</p><blockquote><p>[!INFO]<br><strong>拥塞的另一种代价</strong></p><p>当一个分组沿一条路径被丢弃的时候，每个上游路由器用于转发该分组到丢弃该分组而是用的传输容量最终被浪费掉了。</p></blockquote><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><p><strong>端到端的拥塞控制</strong></p><p>网络层没有为运输层拥塞控制提供显式支持</p><p>TCP报文段的丢失可以看作是网络拥塞的迹象，TCP会相应减少窗口长度</p><p>使用增加的往返时延值作为网络拥塞程度增加的指示</p><p><strong>网络辅助的拥塞控制</strong></p><p>网络层构件向发送方提供关于网络中拥塞状态的显式反馈信息。</p><p>ATM ABR拥塞控制形式，允许路由器显式的通知发送方，告知路由器能在输出链路上支持的传输速率。</p><p>XCP协议对每个源提供路由器计算的反馈，这个反馈携带在分组首部中</p><p><strong>直接反馈信息</strong></p><p>由网络路由器发给发送方</p><p><em>阻塞分组的形式</em>  mainly “我拥塞了”</p><p><strong>路由器标记字段</strong></p><p>至少要经过一个完整的往返时间</p><h3 id="ATM-ABR-拥塞控制"><a href="#ATM-ABR-拥塞控制" class="headerlink" title="ATM ABR 拥塞控制"></a>ATM ABR 拥塞控制</h3><p>一种采用网络辅助方法解决拥塞控制的协议</p><p><strong>Goal</strong> : 说明该协议为拥塞控制所采用的方法明显不同于英特网TCP协议的方法</p><p>需要理解的几个方面：</p><ul><li><em><strong>ATM基本上采用一种面向虚电路（VC）的方法来处理分组交换</strong></em></li></ul><p>允许交换机跟踪各个发送方的行为（ex. 平均传输速率）</p><p>采取特定源的拥塞控制动作(交换机变得拥塞的时候，向发送方显式的发送信令减少速率)</p><p>这样的状态（逐VC）非常适合执行网络辅助拥塞控制</p><ul><li><em><strong>设计成一种弹性数据传输服务，该服务方式使人联想起TCP</strong></em></li></ul><p>轻载的时候会充分利用空闲的可用带宽；拥塞的时候会将传输速率抑制为min</p><p><strong>资源管理信源</strong>（aka. 分组，RM）</p><p>主机和交换机之间传递和拥塞相关的信息。</p><p>RM到达目的地之后，会调转方向想发送方传送（Probably 已经被 Destination 修改）</p><p>交换机也能发送RM，并直接发送给源。</p><ul><li><em><strong>基于速率的方法。也就是发送方明确的计算处能发送的最大速率，并据此进行相应的调整。</strong></em></li></ul><blockquote><p>[! EFCI bit]</p><p><strong>显示转发拥塞指示比特</strong></p><p>交换机把EFCI bit set为1，表示网络拥塞</p><p>Destination 检查收到的EFCIIbit是否有1，大多数为1 $\to$ set RM &#x3D; 1</p><p>将RM信源发送回给发送方</p><p>用EFCI &amp; RM中的CIbit，发送方就能在网络交换机拥塞的时候得到通知</p></blockquote><blockquote><p>[!CI &amp; NI bit]</p><p>拥塞指示比特（CI）&amp; 无增长比特（NI）</p><p><strong>每32个数据单元有一个RM信元</strong></p><p>交换机在轻微拥塞的时候将经过的RM中的NI set 1，严重的时候将CI set 1.</p><p>目的主机收到RM信元的时候将RM发回发送方，保持CI,NI不变</p></blockquote><blockquote><p>[!ER]<br>每一个RM信元都会包含两个字节的显式速率（ER）</p><p>一个拥塞的交换机会降低经过的RM信元中ER字段中包含的值</p><p>以这样的方式就可以将ER字段设置为在源到目的地路径上所有交换机的最小可支持速率</p></blockquote><p>一个ATM ABR 以返回的RM信元中的CI、NI和ER值为函数，来调整发送信元的速率。进行速率调整的规划非常复杂而且繁琐。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-3</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-3/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p><strong>网络前十大问题之一：拥塞控制原理</strong></p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><blockquote><p>[!拥塞]<br><strong>非正式的定义</strong>：“太多的发送主机发送了太多的数据或者发送速度过快以至于网络无法处理”</p></blockquote><p><strong>表现</strong>：</p><ul><li>分组丢失（因为路由器的缓存溢出）</li><li>分组延迟过大（在路由器缓存中排队）</li></ul><p><strong>拥塞控制</strong> vs. <strong>流量控制</strong></p><p>A top-10 problem</p><h3 id="拥塞控制的成因和代价"><a href="#拥塞控制的成因和代价" class="headerlink" title="拥塞控制的成因和代价"></a>拥塞控制的成因和代价</h3><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><p>两个senders： 两个recievers</p><p>一个路由器，无限缓存</p><blockquote><p>[!无限缓存]<br>说明不管主机发送的有多快，有多少数据，都可以从路由器传输到对应的位置，不会造成分组丢失</p></blockquote><p>没有丢失的好处：<strong>没有重传</strong></p><p>链路的带宽是C</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926200532.png"                      alt="image.png"                ></p><p>所以可以看到左边这个图：</p><blockquote><p>[!吞吐率]<br> 左边的图是关于吞吐率的<br>达到C&#x2F;2的时候就不会再增长了</p></blockquote><blockquote><p>[!时延]<br>当$\lambda_{in}$靠近C&#x2F;2的时候，是时延爆炸式的增长</p></blockquote><h4 id="场景2"><a href="#场景2" class="headerlink" title="场景2"></a>场景2</h4><ul><li>一个路由器，有限的buffers</li><li>Sender重传分组</li></ul><p><strong>情况a</strong>:</p><p>Sender 能够通过某种机制直到路由器的buffer信息，有空闲才会发 $\lambda_{in} &#x3D; \lambda_{out}$</p><p><strong>情况b</strong>:</p><p>丢失了之后才会重发： $\lambda^{‘}<em>{in} \ge \lambda</em>{out}$</p><p><strong>情况c</strong>:</p><p>分组丢失和定时器超时之后都重发，$\lambda^{‘}_{in}$会变得更大</p><blockquote><p>[!拥塞的代价]<br>对给定的goodput，要做更多的工作（重传）<br>造成资源的浪费</p></blockquote><h4 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h4><p>四个发送方 多跳 超时&#x2F;重传</p><p><strong>拥塞的另一个代价</strong>：当分组被丢失的时候，任何用于该分组的“上游”传输能力全都被浪费掉</p><h3 id="拥塞控制的方法"><a href="#拥塞控制的方法" class="headerlink" title="拥塞控制的方法"></a>拥塞控制的方法</h3><p><strong>端到端拥塞控制</strong></p><ul><li>网络层不需要显式的提供支持</li><li>端系统通过观察loss，delay等网络行为判断是否发生拥塞</li><li>TCP采取这种方法</li></ul><p><strong>网络辅助的拥塞控制</strong></p><ul><li>路由器向发送方显式的反馈网络拥塞信息</li><li>简单的拥塞只是(1bit):SNA,DECbit,TCP&#x2F;IP ECN, ATM</li><li>指示发送方应该采取何种速率</li></ul><h4 id="ATM-ABR-拥塞控制"><a href="#ATM-ABR-拥塞控制" class="headerlink" title="ATM ABR 拥塞控制"></a>ATM ABR 拥塞控制</h4><p><strong>ABR</strong> </p><ul><li>“弹性服务”</li><li>如果发送路径underloaded 🗯️ 使用可用的带宽</li><li>如果发送方路径拥塞  速率降到最低保障速率</li></ul><p><strong>RM</strong></p><ul><li>发送方发送</li><li>交换机设置RM cell位（网络辅助）<ul><li>NI bit : rate不许增长</li><li>CI bit : 拥塞指示</li></ul></li><li>RM cell由接收方返回给发送方</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926203323.png"                                     ></p><blockquote><p>[!RM cell]<br>显式的速率字段（SR）字段：两个字节</p><ul><li>拥塞的交换机可以将ER设置位最低的值</li><li>发送方获知路径能支持的最小速率</li></ul></blockquote><blockquote><p>[!Data cell]<br>EFCI位：拥塞的交换机将其设置为1</p><ul><li>如果RM cell前面的data cell的EFCI位被设置为1，那么发送方再返回的RM cell中设置CI位</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-ReadingComplement-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><strong>三个问题：</strong></p><ul><li>TCP怎么知道发生了拥塞</li><li>TCP怎么能够实现端到端的限流</li><li>TCP在知道拥塞之后实现什么样的算法来控制拥塞</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h1 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h1><h2 id="TCP-概述"><a href="#TCP-概述" class="headerlink" title="TCP 概述"></a>TCP 概述</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>一个发送方一个接收方</p><h3 id="可靠的、按照顺序的字节流"><a href="#可靠的、按照顺序的字节流" class="headerlink" title="可靠的、按照顺序的字节流"></a>可靠的、按照顺序的字节流</h3><h3 id="流水线机制"><a href="#流水线机制" class="headerlink" title="流水线机制"></a>流水线机制</h3><ul><li>TCP拥塞控制和流量控制机制设置窗口尺寸。</li></ul><h3 id="发送方-接收方缓存0"><a href="#发送方-接收方缓存0" class="headerlink" title="发送方&#x2F;接收方缓存0"></a>发送方&#x2F;接收方缓存0</h3><h3 id="全双工（full-duplex）"><a href="#全双工（full-duplex）" class="headerlink" title="全双工（full-duplex）"></a>全双工（full-duplex）</h3><p>同一链接中能够传输双向数据流</p><h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>通信双方在发送数据之前必须建立连接</p><p>连接状态只在链接的两端中维护，在沿途节点中并不维护状态</p><p>TCP连接包括 <em>两台主机上的缓存</em>、<em>连接状态变量</em>、<em>socket</em>等</p><h3 id="流量控制机制"><a href="#流量控制机制" class="headerlink" title="流量控制机制"></a>流量控制机制</h3><h2 id="TCP段的结构"><a href="#TCP段的结构" class="headerlink" title="TCP段的结构"></a>TCP段的结构</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922213232.png"                      alt="image.png"                ></p><p>第一行：源端口号，目的端口号</p><p>段序列号和ACK的数据</p><p>U：URGENT 代表紧急数据<br>A：ACK 代表是否有效<br>P：PUSH DATA NOW 没有用处<br>R：RST<br>S：SYN<br>F：FIN<br>checksum：代表校验和</p><h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><ul><li>序列号是segment中第一个字节的编号，而不是segment的编号</li><li>建立TCP的时候，双方随机选择序列号</li></ul><h3 id="ACKs"><a href="#ACKs" class="headerlink" title="ACKs:"></a>ACKs:</h3><ul><li>希望接收到的下一个字节的序列号</li><li>累计确认，该序列号之前的所有字节都已经被正确收到</li></ul><h4 id="Q：接收方是怎么处理乱序到达的Segment"><a href="#Q：接收方是怎么处理乱序到达的Segment" class="headerlink" title="Q：接收方是怎么处理乱序到达的Segment?"></a>Q：接收方是怎么处理乱序到达的Segment?</h4><blockquote><p><strong>A: TCP 规范中没有规定，由TCP的实现者做出决策</strong></p></blockquote><p>有两台主机，两个之间进行远程登陆的功能 telnet </p><p>〽️ 之前已经建立了连接</p><ul><li>当主机A用户输入一个C之后，会产生一个序列号的段。(Seq&#x3D;42,ACK&#x3D;79（期望收到的）,data&#x3D;’C’)</li><li>返回来的段中的内容是Seq&#x3D;79,ACK&#x3D;43,data&#x3D;’C’</li><li>主机会再发送一个确认，Seq&#x3D;43,ACK&#x3D;80.</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922214115.png"                      alt="image.png"                ></p><h1 id="TCP的可靠数据传输"><a href="#TCP的可靠数据传输" class="headerlink" title="TCP的可靠数据传输"></a>TCP的可靠数据传输</h1><p>TCP在IP层里面提供的服务的不可靠服务基础上实现可靠数据传输服务</p><p>流水线机制</p><p>累计确认</p><p>TCP使用单一重传定时器</p><p>触发重传的时间 </p><ul><li>超时</li><li>收到重复的ACK</li></ul><h2 id="TCP-RTT和超时"><a href="#TCP-RTT和超时" class="headerlink" title="TCP RTT和超时"></a>TCP RTT和超时</h2><p><strong>问题</strong>：<em>怎么设置定时器的超时时间？</em></p><p>可以使用RTT来作为一个标尺来定下TCP的超时时间</p><p>过短就会产生不必要的重传</p><p>如果过长就会对段丢失的时间反应比较慢</p><p><strong>问题</strong>：<em>怎么估计RTT？</em> </p><p><code>SampleRTT</code>：测量从段发出去到收到ACK 的时间</p><ul><li>忽略重传</li></ul><p><code>SampleRTT</code>变化</p><ul><li>测量<strong>多个</strong><code>SampleRTT</code>，求平均值，形成RTT的估计值</li></ul><p>使用指数加权移动平均的方法：</p><p>EstimatedRTT &#x3D; (1 - $\alpha$) * EstimatedRTT  + $\alpha$ * SampleRTT</p><p><strong>典型值就是0.125</strong></p><p><u>定时器超时时间的设置</u></p><ul><li>EstimatedRTT +”安全边界”</li><li>EstimatedRTT变化大 $\rightarrow$ 较大的边界</li></ul><p><u>测量RTT值的变化：SampleRTT和EstimatedRTT的差值</u></p><p>DevRTT &#x3D; (1-$\beta$) * DevRTT + $\beta$ * | SampRTT-EstimatedRTT |</p><p><strong>Typically, $\beta$ &#x3D; 0,25</strong></p><p><u>定时器超时时间的设置</u></p><p>TimeoutInterval &#x3D; EstimatedRTT + 4 * DevRTT</p><h2 id="TCP发送方的事件"><a href="#TCP发送方的事件" class="headerlink" title="TCP发送方的事件"></a>TCP发送方的事件</h2><p>从应用层收到数据</p><ul><li>创建Segment</li><li>序列号是Segment第一个字节的编号</li><li>开启计时器</li><li>设置超时时间：TimOutInterval</li></ul><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><ul><li>重传引起超时的Segment</li><li>重启定时器</li></ul><h3 id="收到ACK"><a href="#收到ACK" class="headerlink" title="收到ACK"></a>收到ACK</h3><p>如果确认此前未确认的Segment</p><ul><li>更新SendBase</li><li>如果窗口中还有没有被确认的分组，重新启动定时器</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922215744.png"                      alt="image.png"                ></p><p>TCP重传示例如上：此时返回的时候ACK发生丢失，主机发生Timeout事件，此时重新接受，同样会使用ACK100来进行回复</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922215855.png"                      alt="image.png"                ></p><p>两个数据相近的发出，这个Timeout间隔设置的短了，所以就会发生重传，<strong>注意，此时重新传回来的数据应该是ACK120</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922220107.png"                      alt="image.png"                ></p><p>如果没有收到100，但是收到了ACK120，同样是把SendBase来设置为120.</p><h2 id="TCP-ACK的生成-：-RFC-1122-RFC-2581"><a href="#TCP-ACK的生成-：-RFC-1122-RFC-2581" class="headerlink" title="TCP ACK的生成 ： RFC 1122,RFC 2581"></a>TCP ACK的生成 ： RFC 1122,RFC 2581</h2><table><thead><tr><th>Event at Receiver</th><th>TCP Receiver action</th></tr></thead><tbody><tr><td>Arrival of in-order segment with expected seq # All data up to expected seq # already ACKed</td><td>Delayed ACK.Wait up to 500ms for next segment. If no next segment send ACK</td></tr><tr><td>Arrival of in-order segment with expected seq # One other segment has ACK pending</td><td>Immediately send single cumulative ACK. ACKing both inorder segments</td></tr><tr><td>Arrival of out-of-order segment higher-the expect seq # Gap detected</td><td>Immediately send <em>duplicate ACK</em>,indicating seq # of next expected byte</td></tr><tr><td>Arrival of segment that partitially of completely fills gap</td><td>Immediately send ACK,provided that segment startset lower end of gap</td></tr></tbody></table><h2 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h2><p>TCP的实现中，如果发生超时，超时的事件间隔将重新设置，即将超时时间间隔加倍，导致很大。</p><ul><li>重发丢失的分组之前要等待很长时间</li></ul><p>通过重复ACK检测分组丢失</p><ul><li>Sender 会背靠背的发送多个分组</li><li>如果某个分组丢失，可能会引起多个重复的ACK</li></ul><p>入宫Sender收到对同一个数据的3个ACK，那么久假定数据之后的段已经丢失</p><p><strong>快速重传</strong>：在定时器超时之前就进行重传！<strong>利用多个重复的ACK</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230922221329.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-TCP-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p>接收方为TCP连接分配buffer</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230924210206.png"                                     ></p><p>蓝色表示空出来的可以接受数据的</p><p>上层应用可能处理buffer中数据的速度较慢就会导致buffer溢出，淹没接收方。</p><p><strong>所以这就是buffer control</strong></p><p><strong>所以怎么做流量控制？</strong></p><p>Buffer中的可用空间(spare room)</p><p>&#x3D; RcvWindow</p><p>&#x3D; RcvBuffer - (LastByteRcvd - LastByteRead)</p><p>Reciever通过在Segment头部字段将RcvWindow告诉Sender</p><p>Sender限制自己已经发送的但是还没有收到ACK的数据不超过接收方的空闲RcvWindow尺寸</p><p>Receiver告知Sender RcvWindow &#x3D; 0 , 会出现什么情况？</p><blockquote><p>[!TIP]<br>会增加一个额外的处理，即使是Window &#x3D; 0 ，仍然可以有很小一部分的数据可以进行传输</p></blockquote><h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a>TCP的连接管理</h2><p>面向连接的连接协议</p><p>TCP sender &amp; reciever 会建立连接</p><p><em><strong>初始化TCP变量</strong></em></p><p>Seq  #<br>Buffer 和流量控制信息</p><p>Client : 连接的发起者</p><blockquote><p>创建一个套接字Socket，将Socket设置主机名和端口号</p></blockquote><p>Server : 等待客户连接请求</p><blockquote><p>接受客户机发起的请求并建立连接</p></blockquote><p>“<em><strong>三次握手机制</strong></em>”</p><blockquote><p>[!Step1]<br>Client host send TCP SYN (标志段) segment to server</p><ul><li>specifies initial seq #（选择自己的序列号并告诉服务器）</li><li>no data （不携带任何数据）</li></ul></blockquote><blockquote><p>[!Step2]<br>Server host recieves SYN , replies with SYN &amp; ACK segment<br>服务器接收到服务器的标志段，用标志段确认段来作为回复</p><ul><li>server allocates buffers (为连接建立缓存)</li><li>specifies server initial seq #(选择自己的初始的序列号并告知客户端)</li></ul></blockquote><blockquote><p>[!Step3]<br>client receives SYNACK, replies with ACK segment, which may contain data.接收到标志段确认段，客户机发送ACK报文段同意连接</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926193703.png"                      alt="image.png"                ></p><blockquote><p>[!INFO]<br>如果在三次握手的第二步服务器分配资源，最后一次握手如果没有发过来，服务端会保留连接，一段时间没有收到ACK才会关闭连接</p></blockquote><p><em><strong>关闭连接</strong></em></p><p>Closing a connection:</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client closes socket</span></span><br><span class="line">clientSocket.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></div><blockquote><p>[!Step1]<br>client向server发送TCP发送TCP FIN控制segment</p></blockquote><blockquote><p>[!Step2]<br>server收到FIN，回复ACK，关闭连接，发送FIN</p></blockquote><blockquote><p>[!Step3]<br>client收到FIN，回复ACK。</p><ul><li>进入<strong>等待</strong> —— 如果收到FIN，就会重新发送ACK</li></ul></blockquote><blockquote><p>[!Step4]<br>server收到ACK，连接关闭</p></blockquote><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[&quot;Closed&quot;]--&gt;|client application initiates a TCP connection| B[&quot;SYN_SENT&quot;]</span><br><span class="line">B--&gt;|recieve SYN &amp; ACK send ACK| C[&quot;ESTABLISHED&quot;]</span><br><span class="line">C--&gt;|client application initiates close connection \n Send FIN|D[&quot;FIN_WAIT_1&quot;]--&gt;|receive ACK send nothing|E[&quot;FIN_WAIT_2&quot;]--&gt;|recieve FIN send ACK| F[&quot;TIME_WAIT&quot;]--&gt;|30s|A</span><br></pre></td></tr></table></figure></div><p><em><strong>同理可以给出服务端的生命周期图</strong></em></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230926195559.png"                      alt="image.png" style="zoom:50%;"                 >]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 传输层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-PUT</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PUT/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PUT/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]<p>将消息体中的文件上传到URL字段所指定的路径</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 知识卡片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-RIP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-RIP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-RIP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p>Internet采用层次化路由</p><p>AS内部路由协议也成为内部网络协议：interior gateway protocols(IGP)</p><p>最常见的AS内部路由协议：</p><ul><li>路由信息协议 routing information protocol  <code>RIP</code></li><li>开放最短路径优先 open shortest path first <code>OSPF</code></li><li>内部网关路由协议 interior gateway routing protocol <code> IGRP</code></li></ul><h2 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h2><p>早于1982年随BSD-UNIX操作系统发布</p><p>距离向量路由算法</p><ul><li><p>距离度量：跳步数(max &#x3D; 15 hops)，每条链路一个跳步</p></li><li><p>每30s，邻居之间交换一次DV，成为通告(advertisement)</p></li><li><p>每次通告：最多25目的子网(IP形式)</p></li></ul><h3 id="链路失效，恢复"><a href="#链路失效，恢复" class="headerlink" title="链路失效，恢复"></a>链路失效，恢复</h3><p>如果180s没有收到通告 $\to$ 邻居&#x2F;链路失效</p><p>经过这个邻居的路由都不可用了</p><p>重新计算路由</p><p>向邻居发送新的通告</p><p>邻居再一次向外发送通告(如果转发表改变)</p><p>链路是小信息能不能快速传播到全网？</p><ul><li>可能发生无穷计数问题</li></ul><p><strong>毒性逆转计数</strong>用于ping pong环路（无穷大距离为16hops）</p><h3 id="RIP路由表的处理"><a href="#RIP路由表的处理" class="headerlink" title="RIP路由表的处理"></a>RIP路由表的处理</h3><p>RIP路由表是利用一个称作rout-d的应用等进程进行管理</p><ul><li>应用进程实现</li></ul><p>通告报文周期性的通过UDP数据报发送</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029225226.png"                      alt="image.png"                ></p><p>层次划分是通过功能来划分的，无论是什么样的形式来完成</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-PPP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PPP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PPP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="点对点数据链路控制"><a href="#点对点数据链路控制" class="headerlink" title="点对点数据链路控制"></a>点对点数据链路控制</h2><p>一个发送端，一个接收端，一条链路: 比广播链路容易</p><ul><li><p>无需介质访问控制(Media Access Control)</p></li><li><p>无需明确的MAC寻址</p></li><li><p>e.g., 拨号链路,ISDN链路</p></li></ul><p>HDLC： High Level Data Link Control</p><p>PPP: (Point-to-Point Protocol)</p><h2 id="PPP设计需求"><a href="#PPP设计需求" class="headerlink" title="PPP设计需求"></a>PPP设计需求</h2><p>组: 将网络层数据报封装到数据链路层帧中可以同时承载任何网络层协议分组(不仅IP数据报)可以向上层实现分用 (多路分解)</p><p>比特透明传输:数据域必须支持承载任何比特模式</p><p>差错检测:(无纠正)</p><p>网络层地址协商: 端结点可以学习&#x2F;配置彼此网络地址</p><h2 id="PPP无需支持的功能"><a href="#PPP无需支持的功能" class="headerlink" title="PPP无需支持的功能"></a>PPP无需支持的功能</h2><p>无需差错纠正&#x2F;恢复无需流量控制不存在乱序交付无需支持多点链路</p><p>差错恢复、流量控制等由高层协议处理!</p><h2 id="PPP数据帧"><a href="#PPP数据帧" class="headerlink" title="PPP数据帧"></a>PPP数据帧</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101222057.png"                      alt="image.png"                ></p><p>标志(Flag): 定界符(delimiter)</p><p>地址(Address): 无效(仅仅是一个选项)</p><p>控制(Control): 无效; 未来可能的多种控制域</p><p>协议(Protocol): 上层协议 (eg, PPP-LCP,IP,IPCP, tc)</p><p>信息(info): 上层协议分组数据</p><p>校验(check): CRC校验，用于差错检测</p><h2 id="字节填充-Byte-Stuffing"><a href="#字节填充-Byte-Stuffing" class="headerlink" title="字节填充(Byte Stuffing)"></a>字节填充(Byte Stuffing)</h2><p>”数据透明传输“ 需求：数据域必须包含标志模式&lt;011110&gt;</p><p>Q:如何判断该作为数据接收，还是作为标志处理？</p><p>发送端: 在数据中的&lt;01111110&gt;和&lt;01111101&gt;字节前添加额外的字节&lt;01111101&gt;(“填充(stuffs)”)</p><p>接收端:<br>单个字节&lt;01111101&gt;表示一个填充字节:<br>连续两个字节&lt;01111101&gt;: 丢弃第1个，第2个作为数据接收</p><h2 id="PPP数据控制协议"><a href="#PPP数据控制协议" class="headerlink" title="PPP数据控制协议"></a>PPP数据控制协议</h2><p>在交换网络层数据之前，PPP数据链路两端必须:</p><ol><li><p>配置PPP链路</p><ol><li>最大帧长度</li><li>身份认证</li></ol></li><li><p>学习&#x2F;配置网络层信息</p><ul><li>对于IP协议: 通过交换IPCP协议(IP Control Protocol )报文(IP分组首部的“上层协议”字段取值: 8021)，完成IP地址等相关信息配置</li></ul></li></ol><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231101222711.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-OSPF协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-OSPF%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-OSPF%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><p>“开放”：公众可用</p><p>采用链路状态路由算法</p><ul><li>LS分组扩散（通告）</li><li>每个路由器构造完整的网络拓扑图</li></ul><p>链路状态数据库</p><p>每个入口对应一个邻居</p><p>OSPF通告在整个AS范围内进行泛洪</p><p>OSPF报文直接封装到IP数据报中</p><p>和OSPF及其相似的一个路由协议：IS-IS路由协议</p><h2 id="RIO不具备的优点"><a href="#RIO不具备的优点" class="headerlink" title="RIO不具备的优点"></a>RIO不具备的优点</h2><ol><li><p><strong>安全</strong>：所有OSPF报文可以被认证（恶意入侵）</p></li><li><p>允许使用<strong>多条</strong>相同费用的<strong>路径</strong>（RIP只能选一条）</p></li><li><p>对于每一条链路，可以针对不同的TOS设置多个不同费用度量</p></li><li><p>继承单播路由和多播路由：</p></li></ol><ul><li>多播OSPF协议和OSPF利用相同的网络拓扑数据</li></ul><p>OSPF支持对大规模AS分层</p><h2 id="分层的OSPF"><a href="#分层的OSPF" class="headerlink" title="分层的OSPF"></a>分层的OSPF</h2><p><strong>两级分层</strong></p><p>局部区和主干区</p><p>链路状态通告只限于区内</p><p>每个路由器掌握所在区的详细拓扑</p><p><strong>区边界路由器</strong>：汇总到达所在区的网络的距离，通告给其他区边界路由器</p><p><strong>主干路由器</strong>：在主干区内运行</p><p><strong>AS边界路由器</strong>：连接其他AS</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.4 计算机网络性能</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.4%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.4%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 速率<p>速率指的是数据率或者称为比特率</p><ul><li>单位时间传输信息量</li><li>计算机网络中最重要的一个性能指标</li><li>单位：b&#x2F;s(或bps)、kb&#x2F;s、Mb&#x2F;s、Gb&#x2F;s<ul><li>$k&#x3D;10^3、M&#x3D;10^6、G&#x3D;10^9$</li></ul></li><li>速率指的是<strong>额定速率</strong>或者<strong>标称速率</strong></li></ul><h1 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h1><p><strong>带宽</strong> 指的是信号具有的额频带宽度，也就是最高频率和最低频率之差，单位是Hz。</p><p>网络的“带宽”指的是信道能传输的“最高数据率”，单位 b&#x2F;s （bps）</p><p>常用的带宽单位：</p><ul><li>kb&#x2F;s </li><li>Mb&#x2F;s</li><li>Gb&#x2F;s</li><li>Tb&#x2F;s</li></ul><h1 id="延迟-时延（delay）"><a href="#延迟-时延（delay）" class="headerlink" title="延迟&#x2F;时延（delay）"></a>延迟&#x2F;时延（delay）</h1><p>分组交换为什么会繁盛丢包和时延？</p><img                       lazyload                     src="/images/loading.svg"                     data-src=".\assets\image-20230807152535076.png"                      alt="$image-20230807152535076$" style="zoom:67%;"                 ><h2 id="d-proc-：节点处理延迟"><a href="#d-proc-：节点处理延迟" class="headerlink" title="$d_{proc}$：节点处理延迟"></a>$d_{proc}$：节点处理延迟</h2><p>（nodal processing delay）</p><ul><li>差错检测</li><li>确定输出链路</li><li>通常 &lt; m sec</li></ul><h2 id="d-queue-：排队延迟"><a href="#d-queue-：排队延迟" class="headerlink" title="$d_{queue}$：排队延迟"></a>$d_{queue}$：排队延迟</h2><p>（queuing delay）</p><ul><li>等待输出链路可用</li><li>取决于路由器拥塞程度</li></ul><h2 id="d-trans-：传输延迟"><a href="#d-trans-：传输延迟" class="headerlink" title="$d_{trans}$：传输延迟"></a>$d_{trans}$：传输延迟</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="D:\MarkdownNotes\计算机网络\assets\image-20230807153108762.png"                      alt="image-20230807153108762" style="zoom: 67%;"                 ><ul><li><p>L ： 分组宽度</p></li><li><p>R：链路带宽</p></li><li><p>$d_{trans}$ &#x3D; L&#x2F;R</p></li></ul><h2 id="d-prop-：传播延迟"><a href="#d-prop-：传播延迟" class="headerlink" title="$d_{prop}$：传播延迟"></a>$d_{prop}$：传播延迟</h2><ul><li>d ： 物理信号链路长度</li><li>s ：信号传播速度</li><li>$d_{prop}$ &#x3D; d&#x2F;s</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="D:\MarkdownNotes\计算机网络\assets\image-20230807153426289.png"                      alt="image-20230807153426289"                ></p><blockquote><p>车速为100 km&#x2F;hr~ 信号传播速度</p><p>收费站放行一台车用时12 秒 ~ 比特传输时间</p><p><code>车 ~ 比特</code>;<code>车队 ~ 分组</code></p><p><strong>车队通过收费站时间 ~ 传输延迟 (120秒)</strong></p><p><strong>每台车从第一个收费站跑到第二个收费站用时~ 传播延迟 (1小时)</strong></p></blockquote><h2 id="排队延迟"><a href="#排队延迟" class="headerlink" title="排队延迟"></a>排队延迟</h2><p>特殊的点在于<em>不确定</em></p><p>R：链路带宽（bps）</p><p>L：分组长度（bits）</p><p>a：平均分组到达速率</p><p>流量强度（traffic intensity &#x3D; $L \ a &#x2F; R$）</p><ul><li>~0  平均排队延迟很小</li><li>→ 1 平均排队延迟很大</li><li>$\gt$ 1 无限大</li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>（<strong>带宽时延积</strong>）</p><p><strong>时延带宽积 &#x3D; 传播时延 $\times$ 带宽</strong></p><p><strong>时延带宽积 &#x3D; $d_{drop} \times R \ (bits)$.</strong></p><p><strong>链路的时延带宽积又称为以比特为单位的链路长度</strong></p><h2 id="分组丢失（丢包）"><a href="#分组丢失（丢包）" class="headerlink" title="分组丢失（丢包）"></a>分组丢失（丢包）</h2><ul><li>队列缓存容量有限</li><li>分组到达已满队列将被丢弃</li><li>丢弃分组可能有前序结点或者源重发（也可能不重发）</li></ul><p>$丢包率 &#x3D; \frac{丢包数}{已发分组总数}$.</p><h2 id="吞吐量（Throughput）"><a href="#吞吐量（Throughput）" class="headerlink" title="吞吐量（Throughput）"></a>吞吐量（Throughput）</h2><p>吞吐量： 表示在发送端与接收端之间传送数据速率（b&#x2F;s）</p><ul><li>即时吞吐量：给定时刻的速率。</li><li>平均吞吐量：一段时间的平均速率。</li></ul><p>端到端的吞吐量决定于传播的各阶段吞吐量的最小值。</p><p>若$R_s &lt; R_c$ 吞吐量就是 $R_s$.</p><p>若$R_s &gt;R_c$ 吞吐量就是$R_c$.</p><p> 🥈 瓶颈链路（<strong>bottleneck link</strong>）</p><p>端到端路径上，限制端到端吞吐量的链路。</p><p>考虑10条“连接”共享主干网瓶颈链路R bits&#x2F;sec</p><p>每条连接的端到端的吞吐量： min($R_c,R_s,R&#x2F;10$)</p><p>实际网络：$R_c$或$R_s$通常是瓶颈</p><hr><p>上一页： [[CourseNotes&#x2F;计算机网络&#x2F;CN-No.3 网络核心]]</p><p>下一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.5 计算机网络的体系结构]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.5 计算机网络的体系结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 计算机网络的体系结构<h2 id="计算机网络是一个非常复杂的系统"><a href="#计算机网络是一个非常复杂的系统" class="headerlink" title="计算机网络是一个非常复杂的系统"></a>计算机网络是一个非常复杂的系统</h2><ul><li>主机</li><li>路由器</li><li>各种链路</li><li>应用</li><li>协议</li><li>硬件、软件</li></ul><p>……</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>是否存在一种系统结构有效描述网络？<br>利用什么样的结构？</p><p>……</p><p>至少用于讨论网络？</p><p>A：分层结构</p><h2 id="复杂系统的分层结构"><a href="#复杂系统的分层结构" class="headerlink" title="复杂系统的分层结构"></a>复杂系统的分层结构</h2><p>类比：航空旅行</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="D:\MarkdownNotes\计算机网络\assets\Untitled-1692438417405-38.png"                      alt="Untitled"                ></p><ul><li>每层完成一种（类）特定服务&#x2F;功能</li></ul><h2 id="计算积网络的体系结构"><a href="#计算积网络的体系结构" class="headerlink" title="计算积网络的体系结构"></a>计算积网络的体系结构</h2><p>网络体系结构是从功能上描述计算机网络结构</p><p>计算机网络体系结构简称网络体系结构（network architecture）是分层结构</p><p>每层遵勖某个 &#x2F; 某些网络协议完成本层功能</p><p><strong>计算机网络体系结构是计算机网络的各层及其协议的集合</strong></p><p>体系结构是一个网络功能层次及其关系的<code>定义</code></p><p>体系结构是<strong>抽象的</strong></p><h2 id="为什么采用分层结构？"><a href="#为什么采用分层结构？" class="headerlink" title="为什么采用分层结构？"></a>为什么采用分层结构？</h2><h3 id="结构清晰-有利于识别复杂系统不见及其关系"><a href="#结构清晰-有利于识别复杂系统不见及其关系" class="headerlink" title="结构清晰 有利于识别复杂系统不见及其关系"></a><code>结构清晰</code> 有利于识别复杂系统不见及其关系</h3><ul><li>分层的参考模型(reference model)</li></ul><h3 id="模块化的分成易于系统更新维护"><a href="#模块化的分成易于系统更新维护" class="headerlink" title="模块化的分成易于系统更新维护"></a>模块化的分成易于系统更新维护</h3><ul><li>任何一层服务实现的改变对于其它系统其他层都是透明的。</li><li>例如，登机过程的改变并不影响航空系统的其他部分。</li></ul><h3 id="有利于标准化"><a href="#有利于标准化" class="headerlink" title="有利于标准化"></a><strong>有利于标准化</strong></h3><p><code>分层是否有不利之处？</code> 会导致效率不足</p><h2 id="分层网络的基本概念"><a href="#分层网络的基本概念" class="headerlink" title="分层网络的基本概念"></a>分层网络的基本概念</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 1-1692438417405-40.png)</p><p><code>实体</code> <strong>(entity)</strong> 表示任何可以发送或者接收信息的硬件或者软件进程</p><p><code>协议</code>是控制两个对等实体进行通信的规则的集合，协议是<code>水平的</code> 。</p><p>任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供<code>服务</code>，服务是垂直的。</p><p>下层协议的实现对上层的服务用户是<strong>透明</strong>的。</p><p>同系统的相邻层实体之间通过接口进行交互，通过服务访问点（SAP），交换原语，指定请求的特定服务。</p><hr><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 2-1692438417406-44.png)</p><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>开放系统互连（OSI）参考模型 $\rightarrow$ 分层网络体系结构模型（1984）</p><p>目的是支持 异构网络系统的互联互通。</p><p>异构网络系统互联的国际标准</p><p>理解网络通信的最佳<code>学习工具</code>（理论模型）</p><p>✅理论成功 市场失败</p><p>7层 （功能）， 每层完成特定的网络功能。</p><h2 id="OSI参考模型的通信过程"><a href="#OSI参考模型的通信过程" class="headerlink" title="OSI参考模型的通信过程"></a>OSI参考模型的通信过程</h2><p>主机从应用层发出信息，通过七个层到达物理层，通过传输介质传输到路由器的物理层，通过遵循各层的协议，经过物理层 $\rightarrow$ 数据链路层 $\rightarrow$ 网络层 $\rightarrow$ 数据链路层 $\rightarrow$ 物理层的转换再进入传输介质，然后再通过七层进入下一个主机的应用层。</p><p><strong>实线表示的是信息的<code>物理传输</code></strong></p><ul><li>通过接口实现</li></ul><p><strong>虚线表示的是<code>协议传输</code></strong></p><ul><li>和写信一样，无关传输过程，只看数据的交换</li></ul><p><strong>端-端层（end - end）</strong></p><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 3-1692438417406-42.png)</p><h2 id="OSI参考模型数据封装与通信过程"><a href="#OSI参考模型数据封装与通信过程" class="headerlink" title="OSI参考模型数据封装与通信过程"></a>OSI参考模型数据封装与通信过程</h2><p>用户数据从主机A出发</p><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 4-1692438417406-46.png)</p><h2 id="为什么要进行数据封装？"><a href="#为什么要进行数据封装？" class="headerlink" title="为什么要进行数据封装？"></a>为什么要进行数据封装？</h2><h3 id="增加控制信息"><a href="#增加控制信息" class="headerlink" title="增加控制信息"></a>增加控制信息</h3><ul><li>构造协议单元（PDU）</li></ul><h3 id="控制信息主要包括"><a href="#控制信息主要包括" class="headerlink" title="控制信息主要包括"></a>控制信息主要包括</h3><ul><li>地址（Address）：表示发送端、接收端</li><li>差错检测编码（Error-detecting code）：用于差错检测或纠正</li><li>协议控制（Protocol control）:实现协议功能的附加信息，如：<strong>优先级（priority） 、服务质量(QoS)、安全控制等</strong></li></ul><hr><h2 id="物理层功能"><a href="#物理层功能" class="headerlink" title="物理层功能"></a>物理层功能</h2><p>就是实现每一个bit的传输，具体的来讲：</p><ul><li><strong>接口特性</strong><ul><li><code>机械特性</code>  、<code>电气特性</code> 、<code>功能特性</code>、<code>规程特性</code></li></ul></li><li><strong>比特编码问题</strong></li><li><strong>数据率</strong></li><li><strong>比特同步</strong><ul><li>时钟同步,在发送设备和接受设备之间的信号同步</li></ul></li><li><strong>传输模式</strong><ul><li>单工<strong>（Simplex）</strong>也就是只能单向的通信</li><li>半双工<strong>（half-duplex）****对讲机</strong></li><li>全双工<em>（full-duplex）</em></li></ul></li></ul><hr><h2 id="数据链路层功能"><a href="#数据链路层功能" class="headerlink" title="数据链路层功能"></a>数据链路层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 5-1692438417406-48.png)</p><p>作为数据链路层解决的主要是<strong>节点到节点</strong>的数据传输</p><p><strong>组帧（Framing）构成帧的主要目的是能够成功的切分出数据帧</strong></p><p><strong>物理寻址（Physical addressing）</strong></p><ul><li>在帧头中增加发送端和接收端的物理地址标识数据帧的发送端和接收端</li></ul><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 6-1692438417406-50.png)</p><p><strong>流量控制（Flow control）</strong></p><ul><li>避免淹没接收端</li></ul><p><strong>差错控制（Error control）</strong></p><ul><li>检测并重传损坏或丢失帧，并避免重复帧</li></ul><p><strong>访问(接入)控制（Access control）</strong></p><ul><li>在任一给定时刻决定那个设备具有链路（物理介质）控制使用权</li></ul><hr><h2 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 7-1692438417406-52.png)</p><ul><li>负责从<strong>源主机到目的主机</strong>数据分组（packet）交付<ul><li>可能穿越多个网络</li></ul></li><li><strong>逻辑寻址（Logical addressing）</strong><ul><li>全局唯一逻辑地址，确保数据分组被送往目的主机，比如IP地址。</li></ul></li><li><strong>路由（Routing）</strong><ul><li>路径选择</li><li>互联网络并由路由分组☞目的主机</li></ul></li><li><strong>分组转发</strong></li></ul><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 8-1692438417406-54.png)</p><hr><h2 id="传输层的功能"><a href="#传输层的功能" class="headerlink" title="传输层的功能"></a>传输层的功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 9-1692438417406-56.png)</p><p>负责源-目的（端-端）（进程间）完整报文传输</p><ul><li><strong>分段和重组</strong></li><li><strong>SAP寻址</strong><ul><li>确保将完整的报文提交给正确进程比如<code>端口号</code></li></ul></li></ul><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 10-1692438417406-58.png)</p><ul><li><strong>连接控制</strong></li><li><strong>流量控制</strong></li><li><strong>差错控制</strong></li></ul><hr><h2 id="会话层功能"><a href="#会话层功能" class="headerlink" title="会话层功能"></a>会话层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 11-1692438417406-60.png)</p><ul><li><strong>对话控制（dialog controling）</strong><ul><li>建立 维护</li></ul></li><li><strong>同步（synchronization）</strong></li><li>最<code>薄</code> 的一层</li></ul><hr><h2 id="表示层功能"><a href="#表示层功能" class="headerlink" title="表示层功能"></a>表示层功能</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 12-1692438417406-62.png)</p><p>处理两个系统之间交换信息的语法和语义<em>（syntax and semantics）</em>问题</p><ul><li><strong>数据表示转化</strong><ul><li>转换为主机独立的编码</li></ul></li><li><strong>加密&#x2F;解密</strong></li><li><strong>压缩&#x2F;解压缩</strong></li></ul><hr><h2 id="应用层问题"><a href="#应用层问题" class="headerlink" title="应用层问题"></a>应用层问题</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 13-1692438417406-64.png)</p><p>支持用户通过用户代理（如浏览器）或者网络接口使用网络（服务）</p><p>典型应用层服务：</p><ul><li>文件传输（FTP）</li><li>电子邮件（SMTP）</li><li>Web（HTTP）</li><li>……</li></ul><p><strong>TCP&#x2F;IP参考模型</strong></p><p>![*IP over Everything*](D:\MarkdownNotes\计算机网络\assets\Untitled 14-1692438417406-66.png)</p><p><em>IP over Everything</em></p><hr><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 15-1692438417406-68.png)</p><p>综合OSI和TCP&#x2F;IP的优点</p><p>大部分都是这样的参考模型</p><p>在功能上基本类似之前的7层</p><p><strong>应用层：支持网络应用</strong></p><p><strong>传输层：进程-进程的数据传输</strong></p><p><strong>网络层：相邻网络元素（主机、交换机、路由器）的数据传输</strong></p><p><strong>物理层：比特传输</strong></p><p><strong>报文</strong>（message）的传播过程如下：</p><p>![Untitled](D:\MarkdownNotes\计算机网络\assets\Untitled 16-1692438417406-70.png)</p><p>💬可以看到交换机和路由器的本质区别是一个只有两层而一个是三层。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.3 网络核心</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.3%20%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.3%20%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 网络核心<h2 id="为什么需要数据交换"><a href="#为什么需要数据交换" class="headerlink" title="为什么需要数据交换"></a>为什么需要数据交换</h2><ul><li>$N^2$ 链路问题</li><li>将主机和交换设备连接</li><li>连通性</li><li>网络规模</li></ul><h2 id="交换？"><a href="#交换？" class="headerlink" title="交换？"></a>交换？</h2><ul><li>动态转接</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png"                      alt="dynamic connect" style="zoom:67%;"                 ><ul><li>动态分配传输资源</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.png"                      alt="dynamic sourse" style="zoom:67%;"                 ><h2 id="数据交换的类型"><a href="#数据交换的类型" class="headerlink" title="数据交换的类型"></a>数据交换的类型</h2><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>电路交换的特点</p><ul><li>最典型的电路交换网络：<strong>电话网络</strong></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png"                      alt="Untitled" style="zoom:67%;"                 >W</p><ul><li>所以电路交换过程可以分为三个阶段：<ul><li>建立连接（呼叫&#x2F;电路建立）</li><li>通信</li><li>释放连接</li></ul></li><li>独占资源（比如信道资源）是不能被第三方共享的</li></ul><h3 id="电路交换网络的链路共享"><a href="#电路交换网络的链路共享" class="headerlink" title="电路交换网络的链路共享"></a>电路交换网络的链路共享</h3><p>→ 电路交换网络如何共享中继线？</p><hr><h2 id="多路复用技术"><a href="#多路复用技术" class="headerlink" title="多路复用技术"></a>多路复用技术</h2><ul><li>多路复用简称复用，是通信技术的基本概念</li><li>传输能力大于单路的信息，所以要实现多路复用技术</li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%203.png"                      alt="复用器进行组合，分用器来进行拆分" style="zoom:67%;"                 ><p>复用器进行组合，分用器来进行拆分</p><p><strong>多路复用：</strong>链路、网络资源 划分为<strong>资源片</strong></p><p>将资源片分配给各路“呼叫”</p><p>每路呼叫独占分配到的资源篇进行通信</p><p>资源片可能闲置</p><h3 id="典型多路复用方法"><a href="#典型多路复用方法" class="headerlink" title="典型多路复用方法"></a>典型多路复用方法</h3><ul><li><p><strong>频分多路复用</strong></p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%204.png"                      alt="最具代表性的就是有线电视网络" style="zoom:67%;"                 >  <p>  最具代表性的就是有线电视网络</p><p>  每个用户占用不同的带宽资源</p><p>  用户在分配到一定的频带后，那自始自终都占用这个频带</p><p>  频分多路技术</p></li><li><p><strong>时分多路复用</strong></p><p>  划分为<strong>帧</strong> 每个用户占据固定序号的时间间隙</p><p>  每个用户占用的时间间隙是周期性出现的</p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%206.png"                      alt="Untitled" style="zoom:50%;"                 >  <p>  在频率上是不分割的</p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%207.png"                      alt="时分多路复用"                ></p><p>  时分多路复用</p></li><li><p><strong>波分多路复用</strong></p><p>  光的频分复用</p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%208.png"                      alt="Untitled"                ></p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%209.png"                      alt="中间的链路是可以共享的，称为中继线"                ></p><p>  中间的链路是可以共享的，称为中继线</p></li><li><p><strong>码分多路复用</strong></p><p>  广泛应用于无线链路共享（蜂窝网，卫星通信）</p><p>  每个用户分配一个唯一的m bit的<strong>码片序列<em>chipping sequence</em></strong></p><p>  用户使用相同频率载波，利用各自码片序列编码数据</p><p>  $编码信号 &#x3D; (原始数据)\times (码片序列)$。</p><ul><li><p>如发送比特1(+1），则发送自己的m bit码片序列</p></li><li><p>如发送比特0(-1)，则发送该码片序列的m bit码片序列的反码</p></li><li><p>各个用户码片序列相互正交</p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2010.png"                      alt="Untitled"                ></p></li><li><p><strong>解码</strong>：码片序列和编码信号的<strong>内积</strong></p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2011.png"                      alt="Untitled"                ></p></li></ul><p>  <strong>具体的实现步骤</strong></p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2012.png"                      alt="在发送端和接收端的信号传输"                ></p><p>  在发送端和接收端的信号传输</p><p>  <strong>如果是多个用户向信道发送数据</strong></p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2013.png"                      alt="需要保证码片之间是正交的"                ></p><p>  需要保证码片之间是正交的</p><h2 id="数据交换：报文交换，分组交换"><a href="#数据交换：报文交换，分组交换" class="headerlink" title="数据交换：报文交换，分组交换"></a>数据交换：报文交换，分组交换</h2><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>  电路交换资源是独占的，报文指的是发送的信息的整体</p><p>  比如：一个文件</p><h3 id="分组交换（package-switch）"><a href="#分组交换（package-switch）" class="headerlink" title="分组交换（package switch）"></a>分组交换（<em><strong>package switch</strong></em>）</h3><p>  分组：报文分叉出来的一系列相对较小的数据包</p><p>  <strong>头 + 数据</strong></p><p>  分组交换需要保温的拆分和重组</p><p>  产生额外开销（因为要消费额外开销）</p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2014.png"                      alt="Untitled"                ></p></li></ul><p>作为分组交换网络，这样的共享不是事先就分配一部分，而是两个的数据分别都是用完整带宽进行转发，具有很强的随机性。所以也称为统计多路复用统计多路复用最大的特点就是按需共享链路。</p><p>每一个分组从上一个节点完整的转发分组，然后存储之后转发走。称为<strong>存储转发操作</strong>。</p><p>这里能保证是有效的数据，有且仅有当两个向量正交的时候才有效，可以通用数学推导出来。主要原因是因为可以去除S1信道和S2信道的交叉乘积的影响，达到隔离的目的：</p><p> $P&#x3D; \underset{1}{\overset{2}{\sum}}d_i \cdot S_i$</p><p>所以可以推导出</p><p>$d_1&#x3D;\frac{1}{m}\cdot S_i \cdot \underset{1}{\overset{2}{\sum}}d_i \cdot S_i &#x3D; \frac{(S_1)^2}{m} \cdot d$。</p><p>可以看出和上面的表达式是相同的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%2015.png"                      alt="Untitled"                ></p><hr><p>区别：</p><ul><li>报文交换用完整的报文</li><li>分组交换用较小的分组</li></ul><h3 id="所以哪种方式更好呢？"><a href="#所以哪种方式更好呢？" class="headerlink" title="所以哪种方式更好呢？"></a>所以哪种方式更好呢？</h3><p><strong>分组交换：传输延迟</strong></p><p>场景假设，源主机有两个分组信息需要发射，每个分组L bit大小</p><p>发送主机：</p><ul><li>接受应用报文（消息）</li><li>拆分为较小长度为L bits的分组</li><li>在传输速率为R的链路上进行传输</li></ul><h3 id="报文交换-vs-分组交换"><a href="#报文交换-vs-分组交换" class="headerlink" title="报文交换 vs 分组交换"></a>报文交换 vs 分组交换</h3><p>报文交换：</p><ul><li>报文长度为M bits</li><li>链路带宽为R bps</li><li>每次传输报文需要M&#x2F;R秒</li></ul><p>分组交换：</p><ul><li>报文被拆分为多个组</li><li>分组长度为L bits</li><li>每个分组传输时延为L&#x2F;R秒</li></ul><p>举例：</p><blockquote><p>M &#x3D; 7.5 Mbits</p><p>L &#x3D; 1500 bits</p><p>M &#x3D; 5000L</p><p>R &#x3D; 1.5 Mbps</p></blockquote><p>如果使用报文交换的时候，路由器的缓存就至少需要一个报文的大小</p><p>分组交换中，原来的主机是要把报文进行拆分拆分成分组，5000个分组</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">title 报文交换</span><br><span class="line">section 时间分布</span><br><span class="line">    dateFormat YYYY-MM-DD</span><br><span class="line">    axisFormat %d</span><br><span class="line">empty:2023-1-1,9d</span><br><span class="line">M/R=7.5/1.5=5:2023-1-10,9d</span><br><span class="line">empty:2023-1-19,10d</span><br></pre></td></tr></table></figure></div><p>主要都采用分组交换技术</p><h1 id="分组交换的交付时间"><a href="#分组交换的交付时间" class="headerlink" title="分组交换的交付时间"></a>分组交换的交付时间</h1><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230807113712816.png"                      alt="image-20230807113712816" style="zoom:50%;"                 ><p>报文：M bits</p><p>链路带宽：（数据传输速率）：R bits</p><p>分组长度（大小）：L bits；</p><p>跳步数量：h</p><p>路由器数量：n &#x3D; h-1</p><p>$T_{传输时间}&#x3D;M&#x2F;R+(h-1)L&#x2F;R&#x3D;M&#x2F;R+nL&#x2F;R$</p><p>跳步指的是从一点到下一个相邻一点就叫做跳步（一个跳步等于链路数量）</p><p><strong><code>M/R</code> 是 整个报文的传输时间</strong></p><p><strong><code>L/R</code> 是 一个路由器的转发时间</strong> </p><h2 id="试题举例"><a href="#试题举例" class="headerlink" title="试题举例"></a>试题举例</h2><blockquote><p> 在下图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为100 M bps，分组大小为1 000 B，其中分组头大小为20 B。若主机H 1向主机H 2发送一个大小为980 000 B的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H 1发送开始到H 2接收完为止，需要的时间至少是多少?</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230807114528393.png"                      alt="image-20230807114528393"                ></p></blockquote><p>分组大小是1000 B，分组头占其中的20 B，所以有980 B携带的是报文数据；</p><p>至少是什么时间，指的是走最近的链路；</p><p>980 KB大小 的文件需要分1000个分组，每个分组1000 B。H 1发送整个文件需要的传输延迟为（980 000 + 20 * 1000 ）* <strong>8</strong> &#x2F; 100 000 000 &#x3D; 80 ms<strong>（注意单位换算）</strong>; <strong>根据路由选择基本定理</strong>，所有数据分组应该经过两个路由器的转发，所以再加上最后一个分组的两次转发的传输延迟，也就是 2 * 1000 * 8 &#x2F; 100 000 000 &#x3D; 0.16 ms。 所以，H 2接受完整个文件至少需要80 + 0.16 &#x3D; 80.16 ms</p><p><em>两次转发的延迟，因为是两个路由器，所以要加上。</em></p><p>例如：1 Mb&#x2F;s 链路</p><p>每个用户：</p><p>:heavy_check_mark: “活动” 时间需要100 Kb&#x2F;s</p><p>:heavy_check_mark: 每个用户的平均活动时间为10 %</p><h3 id="电路交换："><a href="#电路交换：" class="headerlink" title="电路交换："></a>电路交换：</h3><p>电路交换的特点是不能共享，虽然不传输数据但是其他用户是不能使用的，所以在这种情况下的效率很低。:togo:10个用户</p><h3 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h3><p>当一个用户活动的时候恰好赶上了另一个用户活动，可以将活动错开。:heavy_check_mark:对于35个用户，大于10个用户同时活动的概率&lt;0.0004</p><blockquote><p>分组交换允许更多用户同时使用网络！——网络资源充分共享</p></blockquote><h2 id="分组交换绝对由于电路交换？"><a href="#分组交换绝对由于电路交换？" class="headerlink" title="分组交换绝对由于电路交换？"></a>分组交换绝对由于电路交换？</h2><ul><li>适用于<strong>突发</strong>数据传输网络。<ul><li>资源充分共享</li><li>简单、无需呼叫建立  $\Rightarrow$ 可能产生拥塞：分组延迟和丢失</li><li>需要协议处理可靠数据传输和拥塞控制</li></ul></li><li>现在使用的计算机网络具备突发的数据传输特点。</li><li>但是视频传输和通话的传输不具备突发性。</li></ul><p>Q：如何提供电路级性能保障？打电话会出现停顿现象，所以需要使用协议来进行传输</p><hr><p>上一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.2 计算机网络的结构]]</p><p>下一页:  [[CourseNotes&#x2F;计算机网络&#x2F;CN-No.4 计算机网络性能]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.2 计算机网络的结构</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.2%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.2%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head># 计算机网络的结构<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><ul><li>主机</li><li>网络应用</li></ul><h2 id="接入网络、物理介质"><a href="#接入网络、物理介质" class="headerlink" title="接入网络、物理介质"></a>接入网络、物理介质</h2><ul><li>有限或者无线通信链路</li></ul><h2 id="核心网络（网络核心）"><a href="#核心网络（网络核心）" class="headerlink" title="核心网络（网络核心）"></a>核心网络（网络核心）</h2><ul><li>互联的路由器（或者分组转发设备）</li><li>网络之网络</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled.png"                      alt="Untitled"                ></p><h1 id="网络边缘-1"><a href="#网络边缘-1" class="headerlink" title="网络边缘"></a>网络边缘</h1><hr><h2 id="主机端系统"><a href="#主机端系统" class="headerlink" title="主机端系统"></a>主机端系统</h2><ul><li>位于网络边缘</li><li>运行网络应用程序</li></ul><h2 id="客户、服务器应用模型"><a href="#客户、服务器应用模型" class="headerlink" title="客户、服务器应用模型"></a>客户、服务器应用模型</h2><ul><li>客户端发送请求，服务端接受请求并作出响应</li><li>Web应用，文件传输FTP应用</li><li>所有的通信是在客户和服务器之间进行</li></ul><h2 id="对等应用模型"><a href="#对等应用模型" class="headerlink" title="对等应用模型"></a>对等应用模型</h2><ul><li>没有专用服务器</li><li>通信在对等实体之间相互进行</li><li>QQ</li></ul><h1 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h1><hr><ul><li>居民接入网络</li><li>机构接入网络</li><li>移动接入网络</li></ul><p><strong>用户关心的是</strong> </p><ul><li>带宽（bps）</li><li>接入方式是独占的还是共享的</li></ul><h2 id="代表性的接入网络"><a href="#代表性的接入网络" class="headerlink" title="代表性的接入网络"></a><strong>代表性的接入网络</strong></h2><aside>    <img src="https://www.notion.so/icons/merge_yellow.svg" alt="https://www.notion.so/icons/merge_yellow.svg" width="40px" /> <strong>Example 1： 数字用户线路</strong></aside><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%201.png"                      alt="Untitled"                ></p><ul><li>利用已有的电话网络来进行接入中心局的DSLAM<ul><li>数据通信通过DSL线接入internet</li><li>语音通过DLS线接入电话网络</li></ul></li><li>上行速率低，下行速率快</li><li>下行：&gt;50KHz ~ 1MHz<br>上行：4KHz ~ 50KHz<br>传统电话：0KHz ~ 4KHz</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%202.png"                      alt="Untitled"                ></p><ul><li>频分多路复用技术：在不同的载波上传输不同的频道<ul><li>HFC 混合光纤同轴电缆</li><li>下行大于上行</li></ul></li></ul><p><strong>典型家庭网络的接入</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%203.png"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%204.png"                      alt="Untitled"                ></p><ul><li>主要用于高校、企业、公司等机构</li><li>目前端系统通常直接连接以太网交换机（switch）</li></ul><h2 id="无线接入网络"><a href="#无线接入网络" class="headerlink" title="无线接入网络"></a>无线接入网络</h2><p>通过共享的无线接入网络连接端系统和路由器</p><ul><li>通过基站或者称为”接入点”</li></ul><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><ul><li>同一建筑物内（30m）</li></ul><h3 id="广域无线接入"><a href="#广域无线接入" class="headerlink" title="广域无线接入"></a>广域无线接入</h3><ul><li>3G 4G 5G</li></ul><h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><hr><ul><li><p>互联的路由器网络</p></li><li><p>网络的核心功能：路由+转发</p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%205.png"                      alt="Untitled"                ></p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>  确定分组从源到目的传播路径</p><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>  将分组从路由器的输入端口交换至正确的输出端口</p></li></ul><h1 id="Internet-网络结构：网络之网络"><a href="#Internet-网络结构：网络之网络" class="headerlink" title="Internet 网络结构：网络之网络"></a>Internet 网络结构：网络之网络</h1><ul><li><p>端系统通过接入ISP（access ISP）连接到internet</p></li><li><p>接入ISP必须进一步互联</p></li><li><p>构成复杂的网络互连的网络：经济和国家政策是网络演进的主要推动力</p></li><li><p>当前的Internet网络结构是什么样的呢？动态性很强，无法给出描述</p></li><li><p>数以百万计的ISP是如何互联在一起的呢</p><p>  方案1： 全连接</p><p>  但是当基数过大会导致连接数量指数级增长</p><p>  方案2：构建一个全球的大ISP</p><p>  实际上不可能只有一个ISP</p><p>  最终情况：有多个大型的ISP来进行互联，再将大型的ISP进行互联 → 互联的方式：对等链路</p><p>  <img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Untitled%206.png"                      alt="Untitled"                ></p><p>  最后会用区域性的局域网络来连接每一部分的ISP，就构建好了整个的Internet网络</p></li></ul><hr><p>上一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.1 计算机网络基本概念]]<br>下一页：[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.3 网络核心]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-No.1 计算机网络基本概念</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]# 计算机网络基本概念<h2 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h2><p>计算机网络 &#x3D; 通信技术 + 计算机技术</p><ul><li>计算机网络是通信系统和计算机技术紧密结合的产物</li><li>通信系统模型</li></ul><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"> A(&quot;信源&quot;)</span><br><span class="line"> B(&quot;发送设备&quot;)</span><br><span class="line"> C(&quot;信道&quot;)</span><br><span class="line"> D(&quot;噪声源&quot;)</span><br><span class="line"> E(&quot;接受设备&quot;)</span><br><span class="line"> F(&quot;信宿&quot;)</span><br><span class="line"> A--&gt; B--&gt;C--&gt;E--&gt;F</span><br><span class="line"> D--&gt;C</span><br></pre></td></tr></table></figure></div><ul><li>计算机网络就是一种通信网络</li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的自治的计算机集合</p><p>自治  → 没有主从关系</p><p>互联 → 互联互通</p><ul><li>通信链路</li><li>各个节点叫做主机，连接主机的叫做通信链路</li><li>距离远数量大的时候怎么保证互联</li></ul><p>通过<strong>交换网络</strong>互联主机</p><p>中间一个交换网络，主机连在交换网络上，交换网络里面的节点叫做交换节点</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Screenshot_20230713_151648.jpg"                      alt="Screenshot_20230713_151648.jpg"                ></p><h3 id="什么是Internet-组成细节角度"><a href="#什么是Internet-组成细节角度" class="headerlink" title="什么是Internet? - 组成细节角度"></a>什么是Internet? - 组成细节角度</h3><ul><li>全球的最大互联网络<ul><li>ISP( Internet Service Provider )网络互联的“网络的网络”</li><li>数以百万计的互联的计算设备集合：<ul><li>主机（host）&#x3D; 端系统（end system）</li><li><strong>运行各种网络应用</strong></li></ul></li><li>通信链路<ul><li>光纤，铜缆无线电等</li></ul></li><li>分组交换：转发分组(数据包)<ul><li>路由器（routers）和交换器（switches）</li></ul></li></ul></li></ul><h3 id="什么是Internet？-服务角度"><a href="#什么是Internet？-服务角度" class="headerlink" title="什么是Internet？ - 服务角度"></a>什么是Internet？ - 服务角度</h3><ul><li>为网络应用提供通信服务的通信基础设施：<ul><li>Web,VolP,email,网络游戏，电子商务，社交网络，……</li></ul></li><li>为网络应用提供编程接口（API）：<ul><li>支持应用程序“连接”Internet，发送&#x2F;接受数据</li></ul></li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Q： 仅有硬件链接Internet能否顺畅运行？能保证应用数据的有序交付吗？</p><p>A：No！ </p><p><strong>还需要协议！</strong></p><hr><p>下一页[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.2 计算机网络的结构]]</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-NetworkLayer-Reading</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NetworkLayer-Reading/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NetworkLayer-Reading/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Lab4</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab4/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab4/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/697ba05420e5977359d220437080785.png"                      alt="697ba05420e5977359d220437080785.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/6daf8280a4deff66b6f1e719217d621.png"                      alt="6daf8280a4deff66b6f1e719217d621.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/872afc88738ffb252b96e868938e6e6.png"                      alt="872afc88738ffb252b96e868938e6e6.png"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231031110917.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-NAT</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NAT/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NAT/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>网络地址转换（NAT）</p><h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016213809.png"                      alt="image.png" style="zoom: 67%;"                 ><p>本地网络内通信的IP数据包的源和目的IP地址均在子网10.0.0&#x2F;24内</p><p><strong>所有离开</strong>本地网络去往Internet的数据报的<strong>源IP地址</strong>需要替换成<strong>相同</strong>的NATIP地址：138.76.29.7以及<strong>不同</strong>的端口号。</p><h2 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h2><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>只能&#x2F;需要从ISP中申请一个IP地址，IPv4地址耗尽。</p><p>本地网络设备IP地址的变更，无需通告外界网络。</p><p>无论怎么变对外界来说都是一样的。</p><p>变更ISP的时候，无需修改内部网络设备IP地址</p><p>内部网络设备对外界网络不可见，也就是不可直接寻址（安全）</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><p>利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IPD地址，源端口号）</p><h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>将每对（NAT IP地址，新端口号）和（源IP地址，源端口号）的替换信息存储到NAT转换表中</p><h4 id="替换-1"><a href="#替换-1" class="headerlink" title="替换"></a>替换</h4><p>根据NAT转换表，利用（源IP地址，源端口号）替换每个进入内网IP数据报的（目的IP地址，目的端口号），也就是（NAT IP地址，新端口号）</p><p><strong>16-bit端口号字段</strong>：65536 可以同时支持60，000多个并行连接</p><p><strong>NAT的主要争议</strong>：</p><ul><li><p>路由器应该只处理第三层功能</p></li><li><p>违背端到端的通信原则</p><ul><li>应用开发者必须考虑到NAT的存在，e.g P2P应用</li></ul></li><li><p>地址短缺问题应该由IPv6来解决</p></li></ul><h2 id="NAT穿透问题"><a href="#NAT穿透问题" class="headerlink" title="NAT穿透问题"></a>NAT穿透问题</h2><p>穿透问题：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016215448627.png"                      alt="image-20231016215448627" style="zoom: 67%;"                 >10.0.0.1的服务器<ul><li><p>客户并不能直接利用地址10.0.0.1直接访问服务器</p></li><li><p>对外唯一课件的地址是NAT地址138.76.29.7</p></li></ul><p><strong>解决方案1：</strong> 静态配置NAT，将特定端口的连接请求转发给服务器</p><p>e.g.,(138.76.29.7,2500)总是转发给(10.0.0.1,25000)</p><p><strong>解决方案2</strong>：利用UPnP互联网网关设备协议（IGD-Internet Gateway Device）</p><ul><li><p>学习到NAT公共IP地址(138.76.29.7)</p></li><li><p>到NAT转发表中，增删端口映射</p></li></ul><p><strong>解决方案3</strong>：中继（e.g. Skype）</p><ul><li><p>NAT内部的客户和中继服务器建立连接</p></li><li><p>外部的客户也和中继服务器建立连接</p></li><li><p>中继服务器桥接两个连接的分组</p></li></ul><ol><li>connection to relay initiated byu NATed host</li><li>connection to relay initiated by client</li><li>relaying established</li></ol><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016220212.png"                      alt="image.png" style="zoom:67%;"                 >]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-lab2,3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-lab2,3/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Open File] --&gt; B&#123;File Empty?&#125;</span><br><span class="line">    B -- No --&gt; C[Read Data from File]</span><br><span class="line">    C --&gt; D&#123;Window Not Full?&#125;</span><br><span class="line">    D -- Yes --&gt; E[Send Data]</span><br><span class="line">    E --&gt; F&#123;Data Sent Successfully?&#125;</span><br><span class="line">    F -- Yes --&gt; G[Start Timer]</span><br><span class="line">    F -- No --&gt; H&#123;Wait and Retry?&#125;</span><br><span class="line">    H -- Yes --&gt; D</span><br><span class="line">    H -- No --&gt; J[Receive Acknowledgment]</span><br><span class="line">    J -- Updated Window --&gt; K&#123;End of File?&#125;</span><br><span class="line">    K -- Yes --&gt; L[Stop Sending]</span><br><span class="line">    K -- No --&gt; D</span><br><span class="line">    B -- Yes --&gt; L</span><br><span class="line">    J -- Lost Acknowledgment --&gt; M&#123;Resend Data&#125;</span><br><span class="line">    M -- Data Resent --&gt; F</span><br><span class="line">    J -- Data Received --&gt; N[Write Data to File]</span><br><span class="line">    N --&gt; O&#123;Window Not Empty?&#125;</span><br><span class="line">    O -- Yes --&gt; P[Update Base]</span><br><span class="line">    O -- No --&gt; Q&#123;Continue Receiving?&#125;</span><br><span class="line">    Q -- Yes --&gt; J</span><br><span class="line">    Q -- No --&gt; R[Stop Sending and Receiving]</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP编址</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E7%BC%96%E5%9D%80/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E7%BC%96%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>IP分组：</p><p>源地址（SA）- 从哪里来</p><p>目的地址（DA）- 到哪里去</p><p>接口（interface）：主机&#x2F;路由器和物理链路的连接</p><ul><li>实现网络层的功能</li><li>路由器通常有多个接口</li><li>主机通常只有一个或者两个接口（e.g 有限的以太网接口，无线的802.11接口）</li></ul><h2 id="IP编址"><a href="#IP编址" class="headerlink" title="IP编址"></a>IP编址</h2><p>IP地址：32bit（IPv4）</p><p>编号标识主机、路由器的<strong>接口</strong></p><p>IP地址和每个接口关联</p><p>怎样为接口分配IP地址？</p><h2 id="IP子网-subnets"><a href="#IP子网-subnets" class="headerlink" title="IP子网 subnets"></a>IP子网 <code>subnets</code></h2><p>IP地址：</p><p>网络号（NETID）高位比特</p><p>主机号（HOSTID）低位比特</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015201817985.png"                      alt="image-20231015201817985" style="zoom:67%;"                 ><p>实际上的网络的标识方式如下：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015201905891.png"                      alt="image-20231015201905891" style="zoom:67%;"                 ><p>可以用相同的网络号来描述相同区域的网络，称为IP<strong>子网</strong></p><p><strong>子网</strong>的IP地址的网络号是相同的，在所有网络里面所有的接口不超过三个网络设备就可以物理联通</p><p><strong>不跨越路由器</strong> （第三以及上层网络设备）可以彼此物理联通的接口</p><p>在存储向哪个网络转发数据的时候，只用知道子网地址就可以</p><p>可以用一个地址来描述子网：<strong>IP子网地址</strong></p><p>图中网络有多少个IP子网? 通过IP地址就能够描述一个个的描述地址和子网</p><p>一个个IP子网互联而形成的互联网络</p><p>接口对应的IP地址保留之后可以看到有一些网络是孤岛（也就是IP子网）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Lab1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h1 id="实验-1"><a href="#实验-1" class="headerlink" title="实验 1"></a>实验 1</h1><p><strong>HTTP 代理服务器的设计与实现代理服务器的设计与实现代理服务器的设计与实现</strong> </p><h2 id="1-1-1-实验⽬的"><a href="#1-1-1-实验⽬的" class="headerlink" title="1.1.1.实验⽬的"></a>1.1.1.实验⽬的</h2><p><strong>实验⽬的</strong> </p><p>熟悉并掌握 Socket ⽹络编程的过程与技术；</p><p>深⼊理解 HTTP 协议， 掌握 HTTP 代理服务器的基本⼯作原理；</p><p>掌握 HTTP 代理服务器设计与 编程实现的基本技能。 </p><h2 id="2-2-2-实验环境实验环境实验环境"><a href="#2-2-2-实验环境实验环境实验环境" class="headerlink" title="2.2.2.实验环境实验环境实验环境"></a>2.2.2.实验环境实验环境实验环境</h2><ul><li><p>接⼊ Internet 的实验主机； </p></li><li><p>Windows 操作系统； </p></li><li><p>开发语⾔：C&#x2F;C++（或 Java）等。</p></li></ul><h2 id="3-3-3-实验内容实验内容实验内容"><a href="#3-3-3-实验内容实验内容实验内容" class="headerlink" title="3.3.3.实验内容实验内容实验内容"></a>3.3.3.实验内容实验内容实验内容</h2><p>(1) 设计并实现⼀个基本 HTTP 代理服务器。要求在指定端⼝（例如 8080）接收来⾃客户的 HTTP 请求并且根据其中的 URL 地址访问该地址 所指向的 HTTP 服务器（原服务器），接收 HTTP 服务器的响应报⽂，并 将响应报⽂转发给对应的客户进⾏浏览。 </p><p>(2) 设计并实现⼀个⽀持 Cache 功能的 HTTP 代理服务器。要求能缓 存原服务器响应的对象，并能够通过修改请求报⽂（添加 if-modified-since 头⾏），向原服务器确认缓存对象是否是最新版本。（选作内容，加分项 ⽬，可以当堂完成或课下完成） </p><p>(3) 扩展 HTTP 代理服务器，⽀持如下功能：（选作内容，加分项⽬， 可以当堂完成或课下完成） </p><p>a) ⽹站过滤：允许&#x2F;不允许访问某些⽹站； </p><p>b) ⽤户过滤：⽀持&#x2F;不⽀持某些⽤户访问外部⽹站； </p><p>c) ⽹站引导：将⽤户对某个⽹站的访问引导⾄⼀个模拟⽹站（钓⻥）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP数据报</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E6%95%B0%E6%8D%AE%E6%8A%A5/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E6%95%B0%E6%8D%AE%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="Internet-网络层"><a href="#Internet-网络层" class="headerlink" title="Internet 网络层"></a>Internet 网络层</h2><p><strong>主机、路由器网络层主要功能：</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011104748.png"                      alt="image.png"                ></p><p>计算机网络层的协议：</p><p><strong>1. 路由协议</strong>：路径选择；RIP,OSPF,BGP；<br><strong>2. 转发表（路由表）</strong><br><strong>3. IP协议</strong>：寻址规约（conventions) ；数据报（分组）格式；分组处理规约<br><strong>4. ICMP协议</strong>：差错报告；路由器信令 —— IP协议的伴随协议</p><h2 id="IP数据报（分组）格式"><a href="#IP数据报（分组）格式" class="headerlink" title="IP数据报（分组）格式"></a>IP数据报（分组）格式</h2><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011105155.png"                      alt="image.png" style="zoom:67%;"                 ><p>将IP数据报展开得到的是：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231011105216.png"                      alt="image.png" style="zoom:50%;"                 >固定部分有20个字节<h3 id="版本号：4bit-IP协议的版本号"><a href="#版本号：4bit-IP协议的版本号" class="headerlink" title="版本号：4bit IP协议的版本号"></a><strong>版本号</strong>：4bit IP协议的版本号</h3><h3 id="首部长度：4bit-IP分组的首部长度"><a href="#首部长度：4bit-IP分组的首部长度" class="headerlink" title="首部长度：4bit IP分组的首部长度"></a><strong>首部长度</strong>：4bit IP分组的首部长度</h3><blockquote><p>4bit $\to$ 0 ~ 15  <strong>所以没有办法给出20的大小的</strong><br>所以以4字节为单位才能标识全；所以在计算的时候需要乘上4</p></blockquote><p>最典型的前面两段分别是 4 和 5</p><h3 id="服务类型（TOS）字段：-8bit-指示期望获得哪种类型的服务"><a href="#服务类型（TOS）字段：-8bit-指示期望获得哪种类型的服务" class="headerlink" title="服务类型（TOS）字段： 8bit 指示期望获得哪种类型的服务"></a><strong>服务类型（TOS）字段</strong>： 8bit 指示期望获得哪种类型的服务</h3><p>这个字段改名为 <strong>区分服务</strong></p><p>只有在网络提供区分服务（DiffDev）的时候使用</p><p>一般情况下这个字段都是00H</p><h3 id="总长度字段：16bit-IP分组的总字节数（首部-数据）"><a href="#总长度字段：16bit-IP分组的总字节数（首部-数据）" class="headerlink" title="总长度字段：16bit IP分组的总字节数（首部+数据）"></a><strong>总长度字段</strong>：16bit IP分组的总字节数（首部+数据）</h3><p>最大IP分组的总长度：65535B</p><p>最小的IP分组首部：20B</p><p>IP分组可以封装的最大数据：65535 -20 &#x3D; 65515B</p><h3 id="生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数量"><a href="#生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数量" class="headerlink" title="生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数量"></a><strong>生存时间（TTL）字段</strong>占8位：IP分组在网络中可以通过的路由器数量</h3><p>路由器转发一次分组，TTL减1</p><p>如果TTL&#x3D;0，路由器丢弃该IP分组</p><h3 id="协议字段占8位：指示IP分组封装的是哪个协议的数据包"><a href="#协议字段占8位：指示IP分组封装的是哪个协议的数据包" class="headerlink" title="协议字段占8位：指示IP分组封装的是哪个协议的数据包"></a><strong>协议字段</strong>占8位：指示IP分组封装的是哪个协议的数据包</h3><p>实现了复用&#x2F;分解</p><p>Eg 6为TCP，表示封装的是TCP段；17为UDP，表示封装的是UDP数据报</p><h3 id="首部校验和字段占16位：实现对IP分组首部的差错检测"><a href="#首部校验和字段占16位：实现对IP分组首部的差错检测" class="headerlink" title="首部校验和字段占16位：实现对IP分组首部的差错检测"></a><strong>首部校验和字段</strong>占16位：实现对IP分组首部的差错检测</h3><p>计算校验和的时候，该字段设置为全0</p><p>采用反码算数运算求和，和的反码作为首部校验和字段</p><p>逐跳计算、逐跳检验</p><h3 id="源IP地址、目的IP地址字段各占32位：分别表示发送分组的源主机-路由器（网络接口）和接受分组的目的主机-路由器（网路接口）的IP地址"><a href="#源IP地址、目的IP地址字段各占32位：分别表示发送分组的源主机-路由器（网络接口）和接受分组的目的主机-路由器（网路接口）的IP地址" class="headerlink" title="源IP地址、目的IP地址字段各占32位：分别表示发送分组的源主机&#x2F;路由器（网络接口）和接受分组的目的主机&#x2F;路由器（网路接口）的IP地址"></a><strong>源IP地址、目的IP地址字段</strong>各占32位：分别表示发送分组的源主机&#x2F;路由器（网络接口）和接受分组的目的主机&#x2F;路由器（网路接口）的IP地址</h3><h3 id="选项字段占用长度可变，范围在1-40B之间；携带安全、源选路径、时间戳和路由记录等内容"><a href="#选项字段占用长度可变，范围在1-40B之间；携带安全、源选路径、时间戳和路由记录等内容" class="headerlink" title="选项字段占用长度可变，范围在1~40B之间；携带安全、源选路径、时间戳和路由记录等内容"></a><strong>选项字段</strong>占用长度可变，范围在1~40B之间；携带安全、源选路径、时间戳和路由记录等内容</h3><p>实际上很少被使用</p><h3 id="填充字段占长度可变，范围在0-3B之间；目的是不起整个首部符合32位对齐"><a href="#填充字段占长度可变，范围在0-3B之间；目的是不起整个首部符合32位对齐" class="headerlink" title="填充字段占长度可变，范围在0~3B之间；目的是不起整个首部符合32位对齐"></a><strong>填充字段</strong>占长度可变，范围在0~3B之间；目的是不起整个首部符合32位对齐</h3>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 网络层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP子网划分和子网掩码</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>A类网络的网络数量很少，C类网络的网络数量太多，B类网络编址的网络也容易被浪费掉。</p><h2 id="子网划分（Subnetting）？"><a href="#子网划分（Subnetting）？" class="headerlink" title="子网划分（Subnetting）？"></a>子网划分（Subnetting）？</h2><p>有类地址在描述的过程中会出现的问题</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205436105.png"                      alt="image-20231015205436105" style="zoom: 50%;"                 ><p>在实际网络中A类网络和B类网络肯定不可能</p><p>就需要对大的网络区分成更小的网络范围：<strong>子网划分</strong></p><p>怎么划分？  – <strong>IP地址上做文章</strong></p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205608325.png"                      alt="image-20231015205608325" style="zoom: 67%;"                 ><p>使用主机里面的IP比特之间进行划分</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205750642.png"                      alt="image-20231015205750642" style="zoom:67%;"                 ><p>其他的子网就不会受到通信的影响</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015205827679.png"                      alt="image-20231015205827679" style="zoom:67%;"                 ><p>通过<strong>路由器</strong>来进行转发</p><h3 id="Q：如何确定是否划分了子网？利用多少位来划分子网？"><a href="#Q：如何确定是否划分了子网？利用多少位来划分子网？" class="headerlink" title="Q：如何确定是否划分了子网？利用多少位来划分子网？"></a>Q：如何确定是否划分了子网？利用多少位来划分子网？</h3><p>区分的越多，地址空间就会小，所以子网的方式也很重要。</p><h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><p>形如IP地址：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015210018797.png"                      alt="image-20231015210018797"                ></p><p>32位</p><p>点分十进制形式</p><p>取值：</p><p>NetID、SubID位全部取1</p><p>HostID位全取0</p><p>例如：</p><p>A网的默认子网掩码为：255.0.0.0</p><p>B网的默认子网掩码为：255.255.0.0</p><p>C网的默认子网掩码为：255.255.255.0</p><p>借用3bit划分子网的B网的子网掩码为255.255.224.0</p><blockquote><p>[!子网地址 + 子网掩码]</p><p>准确确定子网大小</p></blockquote><p><strong>For example</strong></p><p>子网：201.2.3.0，255.255.255.0</p><p>划分为登场的4个子网</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015210455295.png"                      alt="image-20231015210455295" style="zoom:67%;"                 ><p>利用路由器来互联在一起</p><p><strong>路由器怎么确定应该将IP分组进行转发</strong>?</p><blockquote><p>将IP分组的目的IP地址和子网掩码 按位与运算，提取紫菀地址子网地址</p></blockquote><p>例如：</p><ul><li>目的IP地址：172.32.1.112，子网掩码：255.255.254.0</li></ul><p>172.32.1.112 &#x3D; 10101100 001000000 00000001 01110000<br>255.255.255.254.0 &#x3D; 11111111 11111111 11111110 00000000</p><p>子网地址：172.32.0.0（子网掩码：255.255.254.0）<br>地址范围：172.32.0.0 ~ 172.32.1.255<br>可分配地址范围：172.32.0.1 ~ 172.32.1.254<br>广播地址：172.32.1.255</p><p><strong>一个C类网络划分子网举例</strong>：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015211156.png"                      alt="image.png" style="zoom:67%;"                 ><p>最左侧的列对应的是每一侧子网的子网地址，最右侧代表的是广播地址</p><p>会造成一部分的浪费</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IPv6</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IPv6/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IPv6/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="IPv6：-动机"><a href="#IPv6：-动机" class="headerlink" title="IPv6： 动机"></a>IPv6： 动机</h2><p>最初动机：32位的IPv4的地址空间已经分配殆尽</p><p>其他动机：改进首部格式</p><ul><li>快速处理&#x2F;转发数据报</li><li>支持QoS</li></ul><p><strong>IPv6的数据报格式</strong>：</p><ul><li>固定长度的40字节基本首部</li><li>不允许分片 路由器不再支持分片，如果发生IP数据包的分片的话，需要在主机分片。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022124955.png"                      alt="image.png"                ></p><p>基本的首部</p><p>其他的首部称为选项首部（大部分情况下路由器是不需要处理的）</p><p>路由处理只需要处理40字节的基本头</p><p>这些选项首部和数据部分称为<strong>载荷</strong></p><h2 id="IPv6数据报的格式"><a href="#IPv6数据报的格式" class="headerlink" title="IPv6数据报的格式"></a>IPv6数据报的格式</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022125154.png"                      alt="image.png"                ></p><p><code>优先级</code>（priority）:标识数据报文的优先级<br><code>流标签</code>（flow Label）：标识同一流中的标签</p><blockquote><p>更详细的定义还在讨论当中</p></blockquote><p>载荷的长度一共是16bit，可以表示65535的长度范围</p><p><code>下一个首部</code>指向的是第一个扩展首部，每一个扩展首部都指向下一个首部</p><p>也就是每个首部之间互相连接</p><p>跳步限制：对应了数据报在转发过程中能够通过的路由器总数</p><h2 id="IPv6和IPv4相比的改变"><a href="#IPv6和IPv4相比的改变" class="headerlink" title="IPv6和IPv4相比的改变"></a>IPv6和IPv4相比的改变</h2><p>校验和：彻底移除，以较少每跳处理时间，减少数据包的处理时间</p><p>选项(options)：允许，但是从基本首部移除，定义多个选项首部，通过下一个首部字段来指示</p><p>ICMPv6：新版的ICMP：</p><ul><li>附加报文类型 <code>Packet too big</code></li><li>多播组管理功能</li></ul><p>发送Packet too big报文转发给主机，让主机来进行分片</p><p><code>IGMP协议</code> 也就是多播组的协议，这个被集成到了IPv6之中了</p><h2 id="IPv6地址表示形式"><a href="#IPv6地址表示形式" class="headerlink" title="IPv6地址表示形式"></a>IPv6地址表示形式</h2><p>地址相当庞大，所以不能使用IPv4的点分十进制的方法</p><p>IPv6地址表示形式：冒号分割的十六进制的表示形式</p><p>一般形式：1080：0：FF：0：8：800：200C：417A</p><p>压缩形式：不能连续的两次使用连接的冒号，只用使用一次连续的冒号</p><p>IPv4的嵌入形式：0：0：0：0：0：FFFF：13.1.68.3 后面就是IPv4的嵌入形式，后面可以使用点分十进制</p><p>地址前缀：2002：43C：476b：：&#x2F;48</p><p>IPv6已经不再使用掩码的方式 利用一个斜杠加网络前缀的方式表示</p><p>URLs：http:&#x2F;&#x2F;[3FFE::1:800:200C:417A]:8000 表示形式不出现歧义</p><h2 id="IPv6基本地址类型"><a href="#IPv6基本地址类型" class="headerlink" title="IPv6基本地址类型"></a>IPv6基本地址类型</h2><p>单播地址(unicast):一对一通信</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022130656.png"                      alt="image.png"                ></p><p>多播地址(unicast):一对多通信</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022130704.png"                      alt="image.png"                ></p><p>没有单独的广播地址，广播地址被定义为特殊的多播地址</p><p>又定义了一种全新的数据类型：</p><p>任意播（anycast）：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022130825.png"                      alt="image.png"                ></p><p>发送到最近的接口上去</p><h2 id="IPv4向IPv6过渡"><a href="#IPv4向IPv6过渡" class="headerlink" title="IPv4向IPv6过渡"></a>IPv4向IPv6过渡</h2><p>不可能在某个时刻所有路由器同时被更新位IPv6</p><ul><li><p>不会有“标志性的日期”</p></li><li><p>IPv4和IPv6路由器共存的网络如何运行？</p></li></ul><p><strong>隧道</strong>：IPv6数据包作为IPv4数据包的载荷进行封装</p><h2 id="Tunneling-隧道"><a href="#Tunneling-隧道" class="headerlink" title="Tunneling 隧道"></a>Tunneling 隧道</h2><p>逻辑隧道：利用IPv4隧道，连接IPv6路由器</p><p>物理视角：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231022131114.png"                      alt="image.png"                ></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-IP分片</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%88%86%E7%89%87/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%88%86%E7%89%87/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p><strong>最大传输单元</strong></p><p>数据帧 IP分组</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231013111455.png"                      alt="image.png" style="zoom:67%;"                 ><p>网络链路存在MTU（最大传输单元）——  链路层数据帧可以封装数据的上限</p><p>不同链路的MTU<strong>不相同</strong></p><p>IP分片和重组问题，大IP分组向较小的MTU链路进行转发的时候，可以被分片(fragmented) <strong>也不是一定要进行分片</strong></p><p>大IP分组分片为多个小分组</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013112045421.png"                      alt="image-20231013112045421" style="zoom:67%;"                 ><p>IP分组的分片只分不装</p><p>IP分片的过程中不知道顺序关系</p><p>IP首部的相关字段用于表示分片以及确定分片的相对顺序</p><p><strong>标识字段占16位：标识一个IP分组</strong></p><p>IP协议利用一个计数器，没产生IP分组计数器加1，作为该IP分组的标识</p><p>标志位字段占3位：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013113324350.png"                      alt="image-20231013113324350" style="zoom:67%;"                 ><p>DF禁止分片 MF更多分片</p><p>DF &#x3D; 1 禁止分片</p><p>DF &#x3D; 0 允许分片</p><p>MF &#x3D; 1 不是最后一片</p><p>MF &#x3D; 0 最后一片</p><p>片偏移字段占13位：一个IP分组分片封装原IP分组数据的相对偏移量</p><p>片偏移字段是由8字节为单位（和首部长度一样的问题）</p><p>在IP分组分片的过程中分片的数量一定是8的倍数</p><p>加收原来的IP分组总长度为L，带转发链路的MTU为M，如果L&gt;M且DF&#x3D;0，则可以&#x2F;需要分片的时候每个分片的标识赋值原IP分组的标识</p><p>分片出来的所有IP分组都是一样的标识</p><p>通常分片的时候，除了最后一个分片，其他分片均分为MTU允许的最大分片</p><p>一个最大分片可以封装的数据应该是8的倍数，因此，一个最大分片可以封装的数据是：$d &#x3D; [\frac{M-20}{8}]\times8$</p><p>需要的总片数为：$n&#x3D;[\frac{L -20}{d}]+1$</p><p>IP分片的过程</p><p>每一篇的片偏移量的取值为：$F_i&#x3D;\frac{d}{8}\times (i-1) , 1 \leq i \leq n$</p><p><strong>每一片的总长度字段</strong>：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013121039621.png"                      alt="image-20231013121039621" style="zoom:50%;"                 ><p>每片的MF标志位为：</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013121128043.png"                      alt="image-20231013121128043" style="zoom:50%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231013121142845.png"                      alt="image-20231013121142845" style="zoom: 50%;"                 >]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-ICMP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ICMP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ICMP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="互联网控制报文协议（ICMP）"><a href="#互联网控制报文协议（ICMP）" class="headerlink" title="互联网控制报文协议（ICMP）"></a>互联网控制报文协议（ICMP）</h2><h3 id="互联网控制报文协议ICMP（Internet-Control-Message-Protocol）"><a href="#互联网控制报文协议ICMP（Internet-Control-Message-Protocol）" class="headerlink" title="互联网控制报文协议ICMP（Internet Control Message Protocol）"></a>互联网控制报文协议ICMP（Internet Control Message Protocol）</h3><p>支持主机和路由器：</p><ul><li><p>差错（或者异常）报告</p></li><li><p>网络查询</p></li></ul><h3 id="两类ICMP报文"><a href="#两类ICMP报文" class="headerlink" title="两类ICMP报文"></a>两类ICMP报文</h3><h4 id="差错报告报文（5种）"><a href="#差错报告报文（5种）" class="headerlink" title="差错报告报文（5种）"></a>差错报告报文（5种）</h4><p>目的不可达 </p><p>丢弃的报文可以通过ICMP协议来进行请求</p><p>源抑制</p><p>超时&#x2F;超期</p><p>参数问题</p><p>重定向（Redirect）</p><h4 id="网络探寻报文-2组"><a href="#网络探寻报文-2组" class="headerlink" title="网络探寻报文(2组)"></a>网络探寻报文(2组)</h4><p>回声请求和应答报文</p><p>时间戳请求和应答报文</p><h2 id="ICMP报文"><a href="#ICMP报文" class="headerlink" title="ICMP报文"></a>ICMP报文</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016222307.png"                      alt="image.png"                ></p><h2 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h2><h3 id="几种不发送ICMP差错报告报文的特殊情况"><a href="#几种不发送ICMP差错报告报文的特殊情况" class="headerlink" title="几种不发送ICMP差错报告报文的特殊情况"></a>几种不发送ICMP差错报告报文的特殊情况</h3><ul><li>对ICMP差错报告报文不再发送ICMP差错报告报文</li><li>除了第一个IP数据报分片之外，对所有后续分片均不发送ICMP差错报告报文</li><li>对所有多播IP数据报均不发送ICMP差错报告报文</li><li>对具有特殊地址（127.0.0.0或者0.0.0.0）的IP数据报不发送ICMP差错报告报文</li></ul><h3 id="几种ICMP报文不再使用"><a href="#几种ICMP报文不再使用" class="headerlink" title="几种ICMP报文不再使用"></a>几种ICMP报文不再使用</h3><ul><li>信息请求和应答报文</li><li>子网掩码请求和应答报文</li><li>路由器询问和通告报文</li></ul><h2 id="ICMP报文的格式"><a href="#ICMP报文的格式" class="headerlink" title="ICMP报文的格式"></a>ICMP报文的格式</h2><p>ICMP报文封装到IP数据报中传输</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231016222940.png"                      alt="image.png" style="zoom:50%;"                 ><h2 id="ICMP差错报告报文数据封装"><a href="#ICMP差错报告报文数据封装" class="headerlink" title="ICMP差错报告报文数据封装"></a>ICMP差错报告报文数据封装</h2><p>差错IP数据报</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231016223503690.png"                      alt="image-20231016223503690" style="zoom:50%;"                 ><h2 id="ICMP的应用举例：Traceroute"><a href="#ICMP的应用举例：Traceroute" class="headerlink" title="ICMP的应用举例：Traceroute"></a>ICMP的应用举例：Traceroute</h2><h3 id="源主机向目的主机发送一系列UDP数据报"><a href="#源主机向目的主机发送一系列UDP数据报" class="headerlink" title="源主机向目的主机发送一系列UDP数据报"></a>源主机向目的主机发送一系列UDP数据报</h3><p>第一组IP数据报TTL &#x3D; 1</p><p>第二组IP数据报TTL &#x3D; 2，etc</p><p>目的端口号为不可能使用的端口号</p><h3 id="当第n组数据包（TTL-n）到达第n个路由器时"><a href="#当第n组数据包（TTL-n）到达第n个路由器时" class="headerlink" title="当第n组数据包（TTL &#x3D; n）到达第n个路由器时"></a>当第n组数据包（TTL &#x3D; n）到达第n个路由器时</h3><p>路由器丢弃数据包</p><p>向源主机发送ICMP报文</p><p>ICMP报文携带路由器名称和IP地址信息</p><h3 id="当ICMP报文返回源主机的时候，记录RTT"><a href="#当ICMP报文返回源主机的时候，记录RTT" class="headerlink" title="当ICMP报文返回源主机的时候，记录RTT"></a>当ICMP报文返回源主机的时候，记录RTT</h3><p><strong>停止准则</strong></p><p>UDP数据包最终到达目的主机</p><p>目的主机返回目的端口不可达ICMP报文</p><p>源主机停止</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-HTTP连接类型</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]# HTTP连接<h2 id="非持久性连接（Nopersistent-HTTP）"><a href="#非持久性连接（Nopersistent-HTTP）" class="headerlink" title="非持久性连接（Nopersistent HTTP）"></a>非持久性连接（Nopersistent HTTP）</h2><ul><li>每个TCP连接最多允许传输一个&#96;非持久性连接</li></ul><h2 id="持久性连接（Persitent-HTTP）"><a href="#持久性连接（Persitent-HTTP）" class="headerlink" title="持久性连接（Persitent HTTP）"></a>持久性连接（Persitent HTTP）</h2><ul><li>每个TCP连接允许<code>传输多个对象</code></li><li>HTTP 1.1 版本默认使用<strong>持久性连接</strong></li></ul><h2 id="非持久性连接"><a href="#非持久性连接" class="headerlink" title="非持久性连接"></a>非持久性连接</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917102927.png"                      alt="Pasted image 20230917102927"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917102939.png"                      alt="Pasted image 20230917102939"                ></p><p><a class="link"   href="http://www.someschool.edu/someDepartment/home.index" >www.someSchool.edu/someDepartment/home.index <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> $\rightarrow$ (包含文本和指向10个jepg图片的链接)</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    1A(&quot;1a:HTTP客户端向地址为\nwww.someSchool.edu/someDepartment/home.index\n的服务器上的HTTP服务器进程（端口80）\n发起TCP连接请求&quot;)--&gt;1B(&quot;1b:HTTP服务器在端口80等待TCP连接请求，接受链接并通知客户端&quot;)</span><br><span class="line">    1B--&gt; 2(&quot;2:HTTP客户端将HTTP请求消息（包含URL地址）\n通过TCP链接的套接字发出，\n消息中所含有的URL表明客户端需要对象\n someDepartment/home.index&quot;)</span><br><span class="line">    2--&gt;3(&quot;3:HTTP服务器收到请求消息，\n 解析，产生包含所需要对象的相应消息,\n并通过套接字发送给客户端&quot;)</span><br><span class="line">    3--&gt;4(&quot;4:HTTO服务器关闭TCP连接&quot;)</span><br><span class="line">    4--&gt;5(&quot;5:HTTP客户端收到响应消息，\n解析html文件，发现有10个指向jepg对象的超链接&quot;)</span><br><span class="line">    6(&quot;对每个jepg对象重复步骤1-5&quot;)</span><br></pre></td></tr></table></figure></div><h2 id="响应时间分析和建模"><a href="#响应时间分析和建模" class="headerlink" title="响应时间分析和建模"></a>响应时间分析和建模</h2><h3 id="RTT-Round-Trip-Time"><a href="#RTT-Round-Trip-Time" class="headerlink" title="RTT(Round Trip Time)"></a>RTT(Round Trip Time)</h3><ul><li>从客户端发送一个很小的数组包到服务器并返回所经历的时间</li></ul><h3 id="响应时间-Response-time"><a href="#响应时间-Response-time" class="headerlink" title="响应时间(Response time)"></a>响应时间(Response time)</h3><ul><li><p>发起、建立TCP连接：<strong>一个RTT</strong></p></li><li><p>发送HTTP请求消息到HTTP响应消息的前几个字节到达：<strong>一个RTT</strong></p></li><li><p>响应消息中所含有的文件&#x2F;对象传输时间</p></li><li><p>Total &#x3D; 2RTT + 文件发送时间</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20230911205654485.png"                      alt="image-20230911205654485" style="zoom:67%;"                 ></li></ul><h2 id="持久性HTTP"><a href="#持久性HTTP" class="headerlink" title="持久性HTTP"></a>持久性HTTP</h2><h3 id="非持久性连接的问题"><a href="#非持久性连接的问题" class="headerlink" title="非持久性连接的问题"></a>非持久性连接的问题</h3><ul><li><p>每个对象都需要<code>2个RTT</code></p></li><li><p>操作系统需要为每个TCP连接开销资源(<em><strong>overhead</strong></em>)</p></li><li><p><strong>浏览器</strong>会怎么做：</p><ul><li>打开<strong>多个并行的TCP连接</strong>以获取网页所需要的对象</li><li>给服务器端造成什么影响？<ul><li>会造成很大的负担（是有代价的,<strong>TCP很宝贵</strong>）</li></ul></li></ul></li></ul><h3 id="持久性连接"><a href="#持久性连接" class="headerlink" title="持久性连接"></a>持久性连接</h3><ul><li><p>发送响应后，服务器<code>保持TCP连接的打开</code></p></li><li><p>后续的HTTP消息可以用通过这个直接连接发送</p></li></ul><h4 id="无流水的持久性连接"><a href="#无流水的持久性连接" class="headerlink" title="无流水的持久性连接"></a>无流水的持久性连接</h4><ul><li><p>客户端只有<strong>收到前一个响应之后才发送新的请求</strong></p></li><li><p>每个被应用对象耗时<strong>1RTT</strong></p></li></ul><h4 id="带有流水机制的持续性连接"><a href="#带有流水机制的持续性连接" class="headerlink" title="带有流水机制的持续性连接"></a>带有流水机制的持续性连接</h4><ul><li>HTTP 1.1的默认选项</li><li>客户端只要<em>遇到一个应用对象就会</em>尽快发出请求</li><li>理想情况下，收到所有应用对象只需要耗时大约一个RTT<br>[[CourseNotes&#x2F;计算机网络&#x2F;CN-No.5 计算机网络的体系结构]]</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-HTTP消息格式</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]# HTTP请求消息<h2 id="HTTP有两类消息"><a href="#HTTP有两类消息" class="headerlink" title="HTTP有两类消息"></a>HTTP有两类消息</h2><ul><li>请求消息</li><li>响应消息</li></ul><h2 id="请求消息"><a href="#请求消息" class="headerlink" title="请求消息"></a>请求消息</h2><p><strong>ASCII</strong>：人直接可读</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917103514.png"                      alt="Pasted image 20230917103514"                ></p><h2 id="HTTP请求消息的通用格式"><a href="#HTTP请求消息的通用格式" class="headerlink" title="HTTP请求消息的通用格式"></a>HTTP请求消息的通用格式</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917104130.png"                      alt="Pasted image 20230917104130"                ></p><h2 id="上传输入的方法"><a href="#上传输入的方法" class="headerlink" title="上传输入的方法"></a>上传输入的方法</h2><p><strong>POST方法</strong></p><ul><li>网页需要填写表格</li><li>在请求消息的消息体（<strong>entity body</strong>）中上传客户端的输入</li></ul><p><strong>URL方法</strong></p><ul><li>使用GET方法</li><li>输入信息通过request行的URL字段上传</li></ul><h2 id="方法的类型"><a href="#方法的类型" class="headerlink" title="方法的类型"></a>方法的类型</h2><p><em>HTTP</em>&#x2F;1.0</p><ul><li>GET&#x2F;POST&#x2F;[[CourseNotes&#x2F;计算机网络&#x2F;CN-HEAD]]</li></ul><p><em>HTTP</em>&#x2F;1.1</p><ul><li>GET,POST,HEAD</li><li>[[CourseNotes&#x2F;计算机网络&#x2F;CN-PUT]]</li><li>[[CourseNotes&#x2F;计算机网络&#x2F;CN-DELETE]]</li></ul><h2 id="HTTP的响应消息"><a href="#HTTP的响应消息" class="headerlink" title="HTTP的响应消息"></a>HTTP的响应消息</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/Pasted%20image%2020230917104921.png"                      alt="Pasted image 20230917104921"                ></p><h2 id="HTTP响应状态代码"><a href="#HTTP响应状态代码" class="headerlink" title="HTTP响应状态代码"></a>HTTP响应状态代码</h2><ul><li><p>响应消息是第一行</p></li><li><p>示例</p><ul><li>200 OK</li><li>301 Moved Permanently</li><li>400 Bad Requeast</li><li>404 Not Found</li><li>505 HTTP Version Not Supported</li></ul></li></ul><h2 id="体验一下HTTP"><a href="#体验一下HTTP" class="headerlink" title="体验一下HTTP"></a>体验一下HTTP</h2><p>利用telnet 登录到某个Web服务器</p><ul><li>telnet <a class="link"   href="http://www.hit.edu.cn/" >www.hit.edu.cn:80 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><p>输入一个HTTP请求</p><ul><li>GET&#x2F;about&#x2F;profile.html <strong>HTTP&#x2F;1.1</strong></li><li>Host: <a class="link"   href="http://www.hit.edu.cn/" >www.hit.edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><p>查看HTTP服务器所返回的响应消息</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework5-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework5-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework5-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>#task<br><strong>如图所示网络。</strong></p><p>​</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://edu-image.nosdn.127.net/9C515BE4A654FA395BE5952B80162EDE.png?imageView&thumbnail=520x520&quality=100"                                     ></p><p>请回答下列问题：<br>(1)主机在配置IP地址时，其正确的子网掩码和默认网关分别是多少？</p><p>​</p><p>(2)若路由器R在向互联网转发一个由主机192.168.1.5发送、ID&#x3D;12345、length&#x3D;500B、DF&#x3D;1的IP分组时，则该IP分组首部的哪些字段会被修改？如何修改？</p><p>​</p><p>(3)若主机192.168.1.10向互联网ID&#x3D;6789、length&#x3D;1500B、DF&#x3D;0的IP分组时，路由器需要将该IP分组分为几片（每片尽可能封装为最大片）？给出分片结果，包括每片的ID、DF、MF、length、offset的取值。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework4-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework4-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework4-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>#task 假设A、B两个端系统通过唯一的一条8Mbps链路连接（M&#x3D;10^6），该链路的双向传播时延是150ms；A通过一个TCP连接向B发送一个大文件，B的接收缓存足够大，每个TCP段最大段长度（MSS）为1500字节，TCP采用Reno版本，且总是处于拥塞避免阶段（即忽略慢启动）。请回答下列问题：</p><ol><li>该TCP连接能够获得的最大窗口尺寸（以TCP段数计）是多少？</li></ol><p>‏<br>2. 该TCP连接的平均窗口尺寸（以TCP段数计）和平均吞吐量（以bps计）是多少？</p><p>‏<br>3. 该TCP连接的拥塞窗口从发生丢包到恢复到最大窗口尺寸要经历多长时间？</p><p>‏</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework2-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework2-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework2-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>假设你在浏览某网页时点击了一个超链接，URL为“https://www.kicker.com.cn/index.html”，且该URL对应的IP地址在你的计算机上没有缓存；文件index.html引用了8个小图像。域名解析过程中，无等待的一次DNS解析请求与响应时间记为RTTd，HTTP请求传输Web对象过程的一次往返时间记为RTTh。请回答下列问题： <p>‍1）你的浏览器解析到URL对应的IP地址的最短时间是多少？最长时间是多少？</p><p><strong>浏览器解析到URL对应的IP地址最短时间是RTTd，最长时间是5RTTd。</strong></p><p>‍2）若浏览器没有配置并行TCP连接，则基于HTTP1.0获取URL链接Web页完整内容（包括引用的图像，下同）需要多长时间（不包括域名解析时间，下同）？</p><p><strong>如果浏览器没有配置并行TCP连接，则基于HTTP1.0获取链接Web页面完整内容所需要的时间为18RTTh</strong><br>‏<br>‍3) 若浏览器配置5个并行TCP连接，则基于HTTP1.0获取URL链接Web页完整内容需要多长时间？</p><p><strong>如果浏览器配置5个并行TCP连接，那么基于HTTP1.0获取URL链接Web页面时间为6RTTh</strong>*</p><p>‍4) 若浏览器没有配置并行TCP连接，则基于非流水模式的HTTP1.1获取URL链接Web页完整内容需要多长时间？基于流水模式的HTTP1.1获取URL链接Web页完整内容需要多长时间？</p><p><strong>如果浏览器没有配置并行TCP连接，基于非流水模式的HTTP1.1获取URL链接Web页完整内容需要的时间为3RTTh</strong><br>‏</p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework3-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework3-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework3-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<p>(18 分） 考虑向 N 个对等方（用户）分发 F&#x3D;15Gb 的一个文件。该服务器具有 us&#x3D;30Mbps 的上传速率，每个对等方的下载速率 di&#x3D;2Mbps，上传速率为 u。请分别针对客户-服务器分发模式和 P2P 分发模式两种情况，对于 N&#x3D;10、 100 和 1000 以及 u&#x3D;500kbps、 1Mbps 和 2Mbps 的每种组合，绘制最小分发时间图表。（注： k&#x3D;10^3、 M&#x3D;10^6、 G&#x3D;10^9）</p><p><strong>列表如下所示：</strong></p><table><thead><tr><th>C&#x2F;S Mode</th><th>N&#x3D;10</th><th>N&#x3D;100</th><th>N&#x3D;1000</th></tr></thead><tbody><tr><td>500kbps</td><td>7500s</td><td>50000s</td><td>500000s</td></tr><tr><td>1Mbps</td><td>7500s</td><td>50000s</td><td>500000s</td></tr><tr><td>2Mbps</td><td>7500s</td><td>50000s</td><td>500000s</td></tr></tbody></table><table><thead><tr><th>P2P Mode</th><th>N&#x3D;10</th><th>N&#x3D;100</th><th>N&#x3D;1000</th></tr></thead><tbody><tr><td>500kbps</td><td>7500s</td><td>18750s</td><td>28302s</td></tr><tr><td>1Mbps</td><td>7500s</td><td>11538s</td><td>14563s</td></tr><tr><td>2Mbps</td><td>7500s</td><td>7500s</td><td>7500s</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework1-3</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-3/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-3/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## 题目3<p>假设主机A向主机B以存储-转发的分组交换方式发送一个大文件。主机A到达主机B的路径上有3段链路，其速率分别是R1&#x3D;500kbps，R2&#x3D;2Mbps，R3&#x3D;1Mbps。试求：</p><ol><li>假设网络没有其他流量，则传送该文件的吞吐量是多少？</li></ol><blockquote><p>吞吐量选择其中传输速率最小的链路：500kbps</p></blockquote><ol start="2"><li>假设文件大小为4MB，则传输该文件到主机B大约需要多少时间？</li></ol><blockquote><p>$T &#x3D; 4MB&#x2F;R &#x3D; 4*10^3&#x2F;500kbps &#x3D; 64s$</p></blockquote><h2 id="注：1k-10-3-1M-10-6"><a href="#注：1k-10-3-1M-10-6" class="headerlink" title="(注：1k&#x3D;10^3^,1M&#x3D;10^6^)"></a><strong>(注：1k&#x3D;10^3^,1M&#x3D;10^6^)</strong></h2>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework1-2</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-2/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-2/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## 题目2<p>( 10分 )</p><p>考虑两台主机A和主机B由一条带宽为R bps、长度为M米的链路互连，信号传播速率为V m&#x2F;s。假设主机A从t&#x3D;0时刻开始向主机B发送分组，分组长度为L比特。试求：</p><ol><li>传播延迟（时延）dp；</li></ol><blockquote><p>dp &#x3D; M &#x2F; V</p></blockquote><ol start="2"><li>传输延迟dt；</li></ol><blockquote><p>dt &#x3D; L &#x2F; R</p></blockquote><ol start="3"><li>若忽略结点处理延迟和排队延迟，则端到端延迟de是多少？</li></ol><blockquote><p>de &#x3D; dt + dp</p></blockquote><ol start="4"><li>若dp&gt;dt，则t&#x3D;dt时刻，分组的第一个比特在哪里？</li></ol><blockquote><p>此时还没有到达主机，所以第一个比特在距离A主机 $\frac{M}{V} \times dt$ 的位置处</p></blockquote><ol start="5"><li>若V&#x3D;250000km&#x2F;s，L&#x3D;512比特，R&#x3D;100 Mbps，则使带宽时延积刚好为一个分组长度（即512比特）的链路长度M是多少？</li></ol><blockquote><p>带宽时延积 &#x3D; $dp \times R$</p><p>代入带宽时延积为512bit，$dp &#x3D; \frac{512bit}{100Mbps} &#x3D; 5.12 \times 10^{-6} s&#x3D;\frac{M}{V}&#x3D;\frac{M}{250000km&#x2F;s}$</p><p>可以解得dp &#x3D; 1024m</p></blockquote><p><strong>(注：1k&#x3D;10^3^,1M&#x3D;10^6^)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-HEAD</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HEAD/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HEAD/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]请Server不要将所请求的对象放入响应消息中]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Homework1-1</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-1/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-1/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## 题目1<p>( 14分 )</p><p>如图所示网络。A在t&#x3D;0时刻开始向C发送一个2Mbits的文件；B在t&#x3D;0.1+e秒（e为无限趋近于0的小正实数）向D发送一个1Mbits的文件。忽略传播延迟和结点处理延迟。</p><p>请回答下列问题：</p><ol><li>如果图中网络采用存储-转发方式的报文交换，则A将2Mbits的文件交付给C需要多长时间？B将1Mbits的文件交付给D需要多长时间？</li></ol><blockquote><p>（1）500ms。由于采用报文交换，只有A来进行传输，B的传输不会影响A的传输。设左边的路由器为F，右边的路由器为E，那么从A到F之间的时间为2&#x2F;10&#x3D;0.2s，此后从F到E的传输则为2&#x2F;20&#x3D;0.1s，此时实现从F到E，最后从E到C所用的时间为0.2s，所以总的时间就是0.5s的时间。</p><p>（2）350ms。在从B到F的过程中不受影响，传输的时间为1&#x2F;10&#x3D;0.1s; 从F传输到E的过程中，需要等待A传输完成，A传输时间为0.1s，B端的传输时间就为0.1+0.05&#x3D;0.15s；从E传到D的时候需要0.1s。A不会影响传输所以一共为0.35s。</p></blockquote><ol start="2"><li>如果图中网络采用存储-转发方式的分组交换，分组长度为等长的1kbits，且忽略分组头开销以及报文的拆装开销，则A将2Mbits的文件交付给C需要大约多长时间？B将1Mbits的文件交付给D需要大约多长时间？</li></ol><blockquote><p>(1)  0.200015s。只需要考虑A的第一个分组的传输方式，$T&#x3D;T_{first}+T_{rest}&#x3D;\frac{2 \times 1kb}{10Mb&#x2F;s}+\frac{1kb}{20Mb&#x2F;s}+\frac{1999 \times 1kb}{10Mb&#x2F;s}&#x3D;0.200015s$</p><p>(2) 0.10002s。同样只需要考虑B的第一个传输和剩下的传输，B的第一个传输是全为10Mb&#x2F;s，$T&#x3D;M&#x2F;R+2L&#x2F;R&#x3D;\frac{1Mb}{10Mb&#x2F;s}+2 \times \frac{1kb}{10Mb&#x2F;s}&#x3D;1.0002s$</p></blockquote><ol start="3"><li>报文交换与分组交换相比，哪种交换方式更公平？（即传输数据量小用时少，传输数据量大用时长）</li></ol><blockquote><p>分组交换更公平</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 计算机网络概述 </tag>
            
            <tag> 作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Email消息格式和POP3协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Email%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%92%8CPOP3%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Email%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%92%8CPOP3%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>## Email消息格式<p><strong>SMTP</strong>:  email 消息的传输&#x2F;交换协议</p><p><strong>RFC 822</strong>: 文本消息格式标准</p><ul><li>头部行<ul><li>To</li><li>From</li><li>Subject</li></ul></li><li>消息体<ul><li>消息本身</li><li>只能是ASCII字符</li></ul></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230917171336.png"                      alt="image.png"                ></p><h2 id="Email消息格式：多媒体扩展"><a href="#Email消息格式：多媒体扩展" class="headerlink" title="Email消息格式：多媒体扩展"></a>Email消息格式：多媒体扩展</h2><p>MIME：多媒体邮件扩展RFC 2045，2056</p><ul><li>通过邮件头部增加额外的行以声明MIME的内容类型</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230917171352.png"                      alt="image.png"                ></p><h2 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h2><p>邮件访问协议：从服务器获取邮件</p><ul><li><strong>POP</strong> ：Post Office Protocol [RFC 1939]<ul><li>认证&#x2F;授权（客户端 $\iff$ 服务器）和下载</li></ul></li><li><strong>IMAP</strong>: Internet Mail Access Protocol [RFC 1730]<ul><li>更多功能</li><li>更加复杂</li><li>能够操纵服务器上存储的信息</li></ul></li><li><strong>HTTP</strong>：163，QQ Mail等</li></ul><h2 id="POP协议"><a href="#POP协议" class="headerlink" title="POP协议"></a>POP协议</h2><h3 id="认证过程"><a href="#认证过程" class="headerlink" title="认证过程"></a>认证过程</h3><ul><li>客户端命令：<ul><li>User: 声明用户名</li><li>Pass：声明密码</li></ul></li><li>服务器响应<ul><li>+OK</li><li>-ERR</li></ul></li></ul><h3 id="事务阶段"><a href="#事务阶段" class="headerlink" title="事务阶段"></a>事务阶段</h3><p>List : 列出消息数量<br>Retr : 用编号获取消息<br>Dele : 删除消息<br>Quit</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918202545.png"                      alt="image.png"                ></p><p>“<strong>下载并删除模式</strong>“</p><ul><li>用户如果换了客户端软件，就没有办法重新读这个邮件</li></ul><p>“<strong>下载并保持模式</strong>” </p><ul><li>不同客户端都可以保留消息的拷贝</li></ul><h3 id="POP3是无状态的"><a href="#POP3是无状态的" class="headerlink" title="POP3是无状态的"></a><em>POP3是无状态的</em></h3><h2 id="IMAP协议"><a href="#IMAP协议" class="headerlink" title="IMAP协议"></a>IMAP协议</h2><p>所有消息统一保存在同一个地方：服务器</p><p>允许用户利用文件夹组织消息</p><p>IMAP支持跨会话（Session）的用户状态：</p><ul><li>文件夹的名字</li><li>文件夹和消息ID之间的映射等等</li></ul><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><p><strong>MAP和POP3协议有什么不同？调研一下主流Email服务对IMAP协议的支持情况</strong> </p><p>IMAP（Internet Mail Access Protocol）和POP3（Post Office Protocol）都是用于获取和管理电子邮件的协议，但存在一些区别。</p><ol><li>差异：<ul><li>IMAP允许用户在本地和远程邮件客户端之间同步邮件状态，包括已读、删除等操作。而POP3只是简单地从服务器上下载邮件到本地，不对邮件状态进行同步。</li><li>IMAP在服务器上保留邮件的副本，用户可以在不同的设备上访问和管理邮件。而POP3将邮件下载到本地后，通常会删除服务器上的副本。</li><li>IMAP支持文件夹和子文件夹的管理，可以方便地组织和管理邮件。而POP3通常只有一个收件箱。</li></ul></li><li>关于主流Email服务对IMAP协议的支持情况，我们可以进行调研：<ul><li>根据Cloudflare的文章<a class="link"   href="https://www.cloudflare.com/zh-cn/learning/email-security/what-is-imap/" >What is IMAP? IMAP vs. POP3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，几乎所有的主流Email服务都支持IMAP协议。这包括Gmail、Outlook、Yahoo Mail等。</li><li>另外，根据知乎的回答<a class="link"   href="https://www.zhihu.com/question/24605584" >POP3, SMTP, IMAP 大相径庭—详解邮箱相关知识 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，POP3协议通常用于普通邮件客户端，比如Outlook，而IMAP协议更适合移动设备和Web邮件界面。<br>综上所述，IMAP和POP3协议在邮件管理和访问方式上存在一些差异，主流Email服务一般都支持IMAP协议。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-DNS概述</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DNS%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DNS%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>#DNS<p>互联网中的核心服务</p><p>[[2023-09-18]]</p><h2 id="有关DNS基础资料查询"><a href="#有关DNS基础资料查询" class="headerlink" title="有关DNS基础资料查询"></a>有关DNS基础资料查询</h2><hr><h2 id="DNSDomain-Name-System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：-通俗易懂，了解什么是DNS及查询过程？-介绍了DNS是什么、DNS的查询过程等基础知识。-DNS基础知识详解-对DNS基础知识进行详细解析。-什么是DNS以及DNS工作原理-介绍了DNS的工作原理和作用。-DNS原理简述-简要介绍了DNS的原理和查询过程。"><a href="#DNSDomain-Name-System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：-通俗易懂，了解什么是DNS及查询过程？-介绍了DNS是什么、DNS的查询过程等基础知识。-DNS基础知识详解-对DNS基础知识进行详细解析。-什么是DNS以及DNS工作原理-介绍了DNS的工作原理和作用。-DNS原理简述-简要介绍了DNS的原理和查询过程。" class="headerlink" title="DNSDomain Name System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：- 通俗易懂，了解什么是DNS及查询过程？ - 介绍了DNS是什么、DNS的查询过程等基础知识。- DNS基础知识详解 - 对DNS基础知识进行详细解析。- 什么是DNS以及DNS工作原理 - 介绍了DNS的工作原理和作用。- DNS原理简述 - 简要介绍了DNS的原理和查询过程。"></a>DNSDomain Name System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。<br>查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：<br>- <a class="link"   href="https://zhuanlan.zhihu.com/p/436199902#:~:text=%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%EF%BC%8C%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AFDNS%E5%8F%8A%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B%EF%BC%9F" >通俗易懂，了解什么是DNS及查询过程？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 介绍了DNS是什么、DNS的查询过程等基础知识。<br>- <a class="link"   href="https://www.cnblogs.com/guoxianqi2020/p/13740551.html" >DNS基础知识详解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 对DNS基础知识进行详细解析。<br>- <a class="link"   href="https://blog.csdn.net/bangshao1989/article/details/121913780" >什么是DNS以及DNS工作原理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 介绍了DNS的工作原理和作用。<br>- <a class="link"   href="https://www.ruanyifeng.com/blog/2022/08/dns-query.html" >DNS原理简述 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> - 简要介绍了DNS的原理和查询过程。</h2><h2 id="DNS：Domain-Name-System"><a href="#DNS：Domain-Name-System" class="headerlink" title="DNS：Domain Name System"></a>DNS：Domain Name System</h2><hr><h3 id="Internet-上主机、路由器的识别问题"><a href="#Internet-上主机、路由器的识别问题" class="headerlink" title="Internet 上主机、路由器的识别问题"></a>Internet 上主机、路由器的识别问题</h3><hr><ul><li>IP地址</li><li>域名：<a class="link"   href="http://www.hit.edu.cn/" >www.hit.edu.cn <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ul><h3 id="问题：域名和IP地址之间如何映射？"><a href="#问题：域名和IP地址之间如何映射？" class="headerlink" title="问题：域名和IP地址之间如何映射？"></a>问题：域名和IP地址之间如何映射？</h3><p>💭<strong>资料查询</strong>：</p><blockquote><p>域名和IP地址之间的映射是通过DNS（Domain Name System）来实现的。DNS是一种分布式数据库系统，它将域名解析为相应的IP地址。当用户在浏览器中输入一个域名，比如”<a class="link"   href="http://www.example.com" ,浏览器会向dns服务器发送请求,以获取与该域名对应的ip地址.dns服务器会查询域名对应的ip地址并返回给浏览器,然后浏览器才能连接到该ip地址上的服务器.这样就实现了域名到ip地址的映射关系./">www.example.com&quot;，浏览器会向DNS服务器发送请求，以获取与该域名对应的IP地址。DNS服务器会查询域名对应的IP地址并返回给浏览器，然后浏览器才能连接到该IP地址上的服务器。这样就实现了域名到IP地址的映射关系。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></blockquote><h3 id="域名解析DNS"><a href="#域名解析DNS" class="headerlink" title="域名解析DNS"></a>域名解析DNS</h3><hr><ul><li>多层命名服务器构成的分布式数据库</li><li><strong>应用层协议</strong>：完成名字的解析<ul><li>Internet核心共嗯那个，则应用层协议实现</li><li>网络边界复杂</li></ul></li></ul><h3 id="DNS-服务"><a href="#DNS-服务" class="headerlink" title="DNS 服务"></a>DNS 服务</h3><hr><ul><li>域名向IP地址的翻译</li><li>主机别名</li><li>邮件服务器别名</li><li><strong>负载均衡</strong>：Web服务器</li></ul><h3 id="问题：为什么不使用集中式的DNS？"><a href="#问题：为什么不使用集中式的DNS？" class="headerlink" title="问题：为什么不使用集中式的DNS？"></a>问题：为什么不使用集中式的DNS？</h3><blockquote><p>☁️集中式DNS存在几个问题：</p><ol><li><strong>单点失败问题</strong>：如果唯一的一个服务点（可能有多台服务器）坏掉了，所有使用域名来提供网络服务的都需要请求DNS来做事情，那么整个互联网就会瘫痪。</li><li><strong>流量问题</strong>：如果几十亿台主机都到这个服务器请求DNS查询，流量是巨大的，成本也是高昂的。<br>因此，为了解决这些问题，采用了分布式的DNS系统。这样可以提供高可用性和高伸缩性，减少了单点故障的风险，并且可以将负载均衡地分配到各个DNS服务器上。<br>来源：[CSDN博客](<a class="link"   href="https://blog.csdn.net/lovelyhonghong/article/details/114850420#:~:text=%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%9A%84DNS%EF%BC%9F" >https://blog.csdn.net/lovelyhonghong/article/details/114850420#:~:text=问题：为什么不使用集中式的DNS？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 1.单点失败问题。,如果唯一的一个服务点（可能有多台服务器）坏掉了，所有使用域名来提供网络服务的，都需要请求DNS来做事情，那么整个互联网就坏掉了。 2.流量问题。 如果几十亿台主机都到这个服务器请求DNS查询，流量是巨大的，成本也是高昂的。)</li></ol></blockquote><ol start="3"><li><strong>距离问题</strong>：在外国的服务器无法合理的访问</li><li><strong>维护性问题</strong></li></ol><h2 id="分布式层次式的数据库"><a href="#分布式层次式的数据库" class="headerlink" title="分布式层次式的数据库"></a>分布式层次式的数据库</h2><hr><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918210818.png"                      alt="image.png"                ></p><p>Level one ： 根服务器</p><p>Level two ：顶级域名服务器</p><p>Level three ：权威域名服务器</p><h3 id="客户端想要查询www-amazon-com的IP"><a href="#客户端想要查询www-amazon-com的IP" class="headerlink" title="客户端想要查询www.amazon.com的IP"></a>客户端想要查询<a class="link"   href="http://www.amazon.com的ip/" >www.amazon.com的IP <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><ol><li><p>客户端查询根服务器，找到com域名解析服务器</p></li><li><p>客户端查询com域名解析服务器，找到amazon.com域名解析服务器</p></li><li><p>客户端查询amazon.com域名解析服务器，获得<a class="link"   href="http://www.amazon.com的ip地址/" >www.amazon.com的IP地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p></li></ol><h2 id="DNS根域名服务器"><a href="#DNS根域名服务器" class="headerlink" title="DNS根域名服务器"></a>DNS根域名服务器</h2><p><strong>本地域名解析服务器无法解析域名的时候，访问根域名服务器</strong></p><h3 id="根域名服务器"><a href="#根域名服务器" class="headerlink" title="根域名服务器"></a>根域名服务器</h3><ul><li>如果不知道映射，访问权威域名服务器</li><li>获得映射</li><li>向本地域名服务器返回映射</li></ul><h2 id="TLD和权威域名解析服务器"><a href="#TLD和权威域名解析服务器" class="headerlink" title="TLD和权威域名解析服务器"></a>TLD和权威域名解析服务器</h2><h3 id="顶级域名服务器（TLD，top-level-domain）"><a href="#顶级域名服务器（TLD，top-level-domain）" class="headerlink" title="顶级域名服务器（TLD，top-level domain）"></a>顶级域名服务器（TLD，top-level domain）</h3><hr><p><strong>负责com,org,net,edu等顶级服务器和国家顶级域名，例如</strong>cn,uk,fr等</p><ul><li>Network Solution 维护com顶级域名服务器</li><li>Educause维护edu顶级域名服务器</li></ul><h3 id="权威（Authoritative）域名服务器"><a href="#权威（Authoritative）域名服务器" class="headerlink" title="权威（Authoritative）域名服务器"></a>权威（Authoritative）域名服务器</h3><hr><p><strong>组织的域名解析服务器，提供组织内部服务器的解析服务</strong></p><ul><li><code>组织负责维护</code></li><li><code>服务提供商负责维护</code></li></ul><h2 id="本地域名解析服务器"><a href="#本地域名解析服务器" class="headerlink" title="本地域名解析服务器"></a>本地域名解析服务器</h2><hr><ul><li>不属于严格的层级体系</li><li>每个ISP都有一个本地域名服务器<ul><li>默认域名解析服务器</li></ul></li><li>当主机进行DNS查询的时候，查询被发送到本地域名服务器<ul><li>作为代理(proxy)，将查询转发给(层级式)域名解析服务器系统</li></ul></li></ul><p><strong>DNS服务器除了做代理之外会不会做缓存呢？</strong></p><h2 id="DNS查询示例"><a href="#DNS查询示例" class="headerlink" title="DNS查询示例"></a>DNS查询示例</h2><hr><p><strong>Cis.poly.edu的主机想要获得gaia.cs.umass.edu的IP地址</strong></p><h3 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h3><p>被查询服务器返回域名解析服务器的名字<br><strong>我不认识这个域名，但是你可以访问这个服务器</strong><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918212916.png"                      alt="image.png"                ></p><h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><p>将域名解析的任务交给所联系的服务器<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20230918213045.png"                      alt="image.png"                ></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为"><a href="#如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为" class="headerlink" title="如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为?"></a>如果本地域名服务器无缓存，当采用递归方法解析另一个网络某主机域名的时候，用户主机、本地域名服务器发送的域名请求消息数分别为?</h3><blockquote><p>一条，一条</p></blockquote><h2 id="DNS记录缓存和更新"><a href="#DNS记录缓存和更新" class="headerlink" title="DNS记录缓存和更新"></a>DNS记录缓存和更新</h2><h3 id="只要域名解析服务器获得了域名——IP映射，即缓存这一映射"><a href="#只要域名解析服务器获得了域名——IP映射，即缓存这一映射" class="headerlink" title="只要域名解析服务器获得了域名——IP映射，即缓存这一映射"></a>只要域名解析服务器获得了域名——IP映射，即缓存这一映射</h3><ul><li>一段时间过后，缓存条目失效（删除）</li><li>本地域名服务器一般会缓存顶级域名服务器的映射<ul><li>因此根域名服务器不经常被访问</li></ul></li></ul><h3 id="记录的更新-通知机制"><a href="#记录的更新-通知机制" class="headerlink" title="记录的更新&#x2F;通知机制"></a>记录的更新&#x2F;通知机制</h3><p>RFC 2136</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>我国没有根域名服务器，是否会影响我国的网络安全，会有什么影响？ </p><p>根域名服务器是DNS系统中最高级的服务器，主要负责将域名转换为IP地址。如果我国没有根域名服务器，那么本地DNS服务器需要依赖其他国家或地区的根域名服务器进行域名解析。<br>这可能会导致以下影响：</p><ol><li>域名解析延迟：由于需要通过其他国家或地区的根域名服务器进行域名解析，可能会增加域名解析的延迟时间，影响用户的访问速度。</li><li>DNS污染的风险：如果依赖其他国家或地区的根域名服务器，存在被篡改或操纵的风险，可能会导致DNS污染问题，进而影响用户的网络安全。</li><li>国内域名管理困难：没有根域名服务器可能会使国内域名管理难度增加，因为国内域名需要通过其他根域名服务器进行授权和解析。<br>需要注意的是，虽然我国没有根域名服务器，但我国仍然有多个顶级域名服务器，可以解析国内的顶级域名。此外，我国也有多个根域名服务器的备用节点，以确保网络安全和稳定性。<br>来源：<a class="link"   href="https://www.zhihu.com/question/51263554" >zhihu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-DHCP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DHCP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DHCP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="如何获得IP地址"><a href="#如何获得IP地址" class="headerlink" title="如何获得IP地址"></a>如何获得IP地址</h2><p>Q： 一个主机如何获得IP地址？</p><ul><li>”硬编码“：静态配置</li></ul><p>需要配置的信息包括IP地址和子网掩码。</p><p><strong>默认网关</strong>： 所谓的默认网关就是当这个IP的数据报在向外传递数据的时候应该向什么地方进行转发。代表的是路由器的接口。</p><p>路由器接入子网的这个接口的IP地址就是这个子网中所有主机的默认网关。</p><p>域名服务器：默认的域名服务器 <strong>本地域名服务器</strong></p><ul><li>动态地址的获取 动态主机配置协议：DHCP Dynamic Host Configuration Protocol</li></ul><p>从服务器动态获取</p><ul><li>IP地址</li><li>子网掩码</li><li>默认网关地址</li><li>DNS服务器名称和IP地址</li></ul><p>“即插即用”</p><p>允许地址的重用</p><p>支持在用地址的续租</p><p>支持移动用户加入网络</p><h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>新到主机（DHCP客户）需要本网IP地址</p><p>”主机广播“：DHCP discover（发现报文）</p><p>DHCP服务器利用”DHCP offer“(提供报文)进行相应</p><p>主机请求IP地址：”DHCP request“ (请求报文)</p><h2 id="DHCP工作过程示例"><a href="#DHCP工作过程示例" class="headerlink" title="DHCP工作过程示例"></a>DHCP工作过程示例</h2><p>DHCP server: 223.1.2.5.67</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015220123172.png"                      alt="image-20231015220123172" style="zoom:67%;"                 ><h3 id="DHCP协议在应用层实现"><a href="#DHCP协议在应用层实现" class="headerlink" title="DHCP协议在应用层实现"></a>DHCP协议在应用层实现</h3><p>请求报文封装到UDP数据报中</p><p>IP广播</p><p>链路层广播（以太网广播）</p><p>DHCP服务器构造ACK报文</p><p>包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-DELETE</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DELETE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DELETE/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]删除URL字段所指定的文件]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 知识卡片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-CIDR和路由聚合</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-CIDR%E5%92%8C%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-CIDR%E5%92%8C%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[计算机网络]]<h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>无类域间路由（CIDR：Classless InterDomain Routing)</p><p>消除传统的A类、B类和C类地址界限</p><ul><li>NetID + SubID $\to$ Network Prefix(Prefix) 可以任意的长度</li></ul><p>融合子网地址和子网掩码，方便子网进行划分</p><ul><li>无类地址格式：a.b.c.d&#x2F;x，其中x为前缀长度</li></ul><p>例如</p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231015212717.png"                      alt="image.png" style="zoom:67%;"                 >和有类IP地址就有很大的区别了；也就是打破了有类地址的界限划分<p>子网 201.2.3.64，255.255.255.192 🤜 201.2.3.64&#x2F;26</p><h2 id="CIDR和路由聚合"><a href="#CIDR和路由聚合" class="headerlink" title="CIDR和路由聚合"></a>CIDR和路由聚合</h2><p>无类域间路由（CIDR)</p><ul><li>提高IPv4的地址空间分配效率</li></ul><p>可以将很多的C网划分在一起再统一的进行转发</p><ul><li>能够提高路由效率<ul><li>将多个子网聚合成一个较大的子网</li><li>构造超网</li><li><strong>路由聚合</strong>（route aggregation）</li></ul></li></ul><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015213443100.png"                      alt="image-20231015213443100" style="zoom: 67%;"                 ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015213823598.png"                      alt="image-20231015213823598" style="zoom:67%;"                 >## 路由聚合层级编址使得路由信息通告更加高效<img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/image-20231015213908264.png"                      alt="image-20231015213908264" style="zoom:50%;"                 ><p>选用更加具体的路由：<strong>最长前缀匹配优先</strong>！</p><p>通过前缀长度来加以区分</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-Cookie</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Cookie/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Cookie/</url>
      
        <content type="html"><![CDATA[<head>    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>    <script type="text/x-mathjax-config">        MathJax.Hub.Config({            tex2jax: {            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],            inlineMath: [['$','$']]            }        });    </script></head>[[2023-09-17]]<h2 id="为什么需要Cookie"><a href="#为什么需要Cookie" class="headerlink" title="为什么需要Cookie?"></a>为什么需要Cookie?</h2><p>HTTP协议无状态</p><p>很多应用需要服务器掌握客户的状态：</p><ul><li><strong>网上购物</strong></li></ul><h2 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h2><p>某些网站为了辨别身份，进行session跟踪而存储在用户本地终端上的数据（<strong>通常经过加密</strong>）<br>RFC6265</p><p><strong>Cookie的组件</strong></p><ul><li>HTTP响应消息的cookie头部行</li><li>HTTP请求消息的cookie头部行</li><li>保存在客户端主机上的cookie文件，由浏览器管理</li><li>Web服务器端的后台数据库</li></ul><h2 id="Cookie的原理"><a href="#Cookie的原理" class="headerlink" title="Cookie的原理"></a>Cookie的原理</h2><p>Susan 首次PC上网，首次和Amazon.com取得联系。界定过去访问过eBay站点，当请求报文到达该Amazon Web服务器的时候，这个Web站点将产生一个唯一的识别码，并以此缩影在它的后端数据库中产生一个表项。接下来Amazon Web服务器用一个包含Set-cookie：首部的HTTP响应报文来对Susan的浏览器进行响应，其中Set-cookie:首部含有识别码。</p><p>Susan浏览器收到了该HTTP的响应报文的时候，它会看到该Set-cookie:首部。该浏览器在它管理的特定cookie文件中添加一行，该行包含服务器的主机名和在Set-cookie：首部中的识别码。</p><p>值得注意的是当前的cookie文件已经有了eBay的表项，因为Susan过去访问过该站点。之后的浏览都会从该cookie文件中获取她对这个网站的识别码，并放到HTTP请求报文中包括识别码的cookie首部行中。</p><p>在这种方式下，Amazon服务器可以跟踪Susan在Amazon站点的活动。Amazon使用cookie来提供 <strong>购物车服务</strong> </p><p>![[assets 1&#x2F;Pasted image 20230917115446.png]]</p><h2 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h2><ul><li><p>cookie能够用于：****</p><ul><li>身份认证</li><li>购物车</li><li>推荐</li><li>Web e-mail</li><li>……</li></ul></li><li><p>隐私问题</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> Cookie </tag>
            
            <tag> Web应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-BGP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-BGP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-BGP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="Internet-AS间路由协议：BGP"><a href="#Internet-AS间路由协议：BGP" class="headerlink" title="Internet AS间路由协议：BGP"></a>Internet AS间路由协议：BGP</h2><p><strong>边界网关协议BGP</strong>：事实上的标准域间路由协议</p><ul><li>将Internet “粘合”为一个整体的关键</li></ul><p>BGP为每个AS提供了一种手段：</p><ol><li><p>eBGP：从邻居的自治系统获取子网的可达性信息</p></li><li><p>iBGP：向所有AS内部有尤其传播子网可达性信息</p></li><li><p>基于可达性信息和策略，确定到达其他网络的“好”路径</p></li></ol><p>容许子网向Internet其余部分通告它的存在</p><h2 id="BGP协议的基础"><a href="#BGP协议的基础" class="headerlink" title="BGP协议的基础"></a>BGP协议的基础</h2><p>BGP会话(session)：两个BGP路由器（”Peers”）交换BGP报文：</p><ul><li><p>通告去往不同目的的前缀(prefix)的路径（“路径向量”）协议</p></li><li><p>报文交换基于半永久的TCP协议</p></li></ul><p>BGP报文：</p><p>OPEN：和peers建立TCP连接，并认证发送方</p><p>UPDATE：通告新路径（或者撤销原路径）</p><p>KEEPALIVE：在没有UPDATE的时候，保活连接；也用于对OPEN请求的确认</p><p>NOTIFICATION：报告先前报文的差错；也被用于关闭连接</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029231514.png"                      alt="image.png"                ></p><p>当AS3通告一个前缀给AS1时：</p><ul><li><p>AS3 承诺可以将数据报转发给该子网</p></li><li><p>AS3在通告中会聚合网络前缀</p></li></ul><h2 id="BGP基础：分发路径信息"><a href="#BGP基础：分发路径信息" class="headerlink" title="BGP基础：分发路径信息"></a>BGP基础：分发路径信息</h2><p>在3a和1c之间AS3利用eBGP会话向AS1发送前缀可达信息。</p><p>1c则可以利用iBGP向AS1内的所有路由器分发新的前缀可达性信息</p><p>1b可以(maybe not) 进一步通过1b-到-2a的eBGP会话，向AS2通告新的可达性信息</p><p>当路由器获得新的前缀可达性的时候，就会在转发表中增加关于该前缀的入口(路由项)</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/20231029231942.png"                      alt="image.png"                ></p><h2 id="路径属性和BGP路由-route"><a href="#路径属性和BGP路由-route" class="headerlink" title="路径属性和BGP路由(route)"></a>路径属性和BGP路由(route)</h2><p>通告的前缀信息包括BGP属性</p><ul><li>前缀 + 属性 &#x3D; “路由”</li></ul><p>两个重要属性：</p><ul><li>AS-PATH : 包含前缀通告所经过的AS序列：e.g. AS 67,AS 17</li><li>NEXT-HOP(下一跳)：开始一个AS-PATH的路由器接口，指向吓一跳的AS</li></ul><h2 id="BGP的路由选择"><a href="#BGP的路由选择" class="headerlink" title="BGP的路由选择"></a>BGP的路由选择</h2><p>网关路由器收到路由通告之后，利用其输入策略决策接收或者拒绝该路由</p><p>从不将流量路由到ASx<br>基于策略的路由</p><p>路由器可能或者到某目的AS的多条路由，基于以下准则：</p><ul><li><p>本地偏好值属性：策略决策</p></li><li><p>最短的AS-PATH</p></li><li><p>最近的下一跳路由器</p></li></ul><h2 id="BGP路由选择策略"><a href="#BGP路由选择策略" class="headerlink" title="BGP路由选择策略"></a>BGP路由选择策略</h2><p>提供商网络<br>客户网络<br>桩网络<br>双宿网络</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://typora-slater.oss-cn-beijing.aliyuncs.com/picture/6034294e3b9c0feeabde6fc50c50ec2.jpg"                      alt="6034294e3b9c0feeabde6fc50c50ec2.jpg"                ></p><h3 id="为什么采用不同的AS内和AS间的路由协议"><a href="#为什么采用不同的AS内和AS间的路由协议" class="headerlink" title="为什么采用不同的AS内和AS间的路由协议"></a>为什么采用不同的AS内和AS间的路由协议</h3><h4 id="策略-policy"><a href="#策略-policy" class="headerlink" title="策略(policy):"></a>策略(policy):</h4><p>inter-AS:期望能够管理控制流量如何被路由，谁路由经过其网络等<br>intra-AS: 单一管理，无需策略决策</p><h4 id="规模-scale"><a href="#规模-scale" class="headerlink" title="规模(scale)"></a>规模(scale)</h4><p>层次路由节省路由表大小，减少路由更新流量<br>适应大规模互联网</p><h4 id="性能-performance"><a href="#性能-performance" class="headerlink" title="性能(performance):"></a>性能(performance):</h4><p>intra-AS:侧重性能<br>inter-AS: 策略主导</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CN-ARP协议</title>
      <link href="/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ARP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ARP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[[CN-NotesView]]</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>32位的IP地址：</p><ul><li>接口的网络层地址</li><li>用于标识网络层(第三层)分组，支持分组转发</li></ul><p>MAC地址（或称LAN地址，物理地址，以太网地址）</p><p>作用：用于局域网内的标识一个帧从哪个接口发出没到达哪个物理相连的其他接口</p><p>48位MAC地址（用于大部分LANs）固化在网卡的ROM中，有时也可以用软件设置</p><p>局域网的每块网卡都有唯一的MAC地址</p><p>MAC地址由IEEE统一管理和分配</p><p>网卡生产商够吗MAC地址空间（前24bit）</p><p>类比：</p><ul><li>MAC地址：身份证号</li><li>IP地址：邮政地址</li></ul><p><strong>MAC地址是“平面”地址: 可“携带</strong></p><p>可以从一个LAN移到另一个LAN</p><p><strong>IP地址是层次地址: 不可“携带“</strong></p><p>IP地址依赖于结点连接到哪个子网</p><h2 id="ARP：地址解析协议"><a href="#ARP：地址解析协议" class="headerlink" title="ARP：地址解析协议"></a>ARP：地址解析协议</h2><p>问题：（在同一个LAN内）如何在一致目的接口的IP地址前提下确定其MAC地址？</p><p>ARP表：LAN中的每个IP结点(主机&#x2F;路由器)维护一个表</p><ul><li><p>存储某些LAN结点的IP、MAC关系地址映射关系：&lt;IP;MAC;TTL&gt;</p></li><li><p>TTL(Time To Live): 经过这个时间之后这个映射关系会被遗弃</p></li></ul><p>A想要给同一个局域网内的B发送数据报</p><p>B的MAC地址不再A的ARP表中。</p><p>A广播ARP查询分组，其中包含B的IP分组</p><p>目的MAC地址 &#x3D; FF-FF-FF-FF-FF-FF</p><p>LAN中的所有结点都会接收ARP查询</p><p>B接收ARP查询分组，IP地址匹配成功，向A应答B的MAC地址</p><ul><li>利用单播帧向A发送应答</li></ul><p>A在其ARP表中，缓存B的IP-MAC地址对，直至超时</p><ul><li>超时之后，再次刷新</li></ul><p>ARP是”即插即用“协议：</p><ul><li>结点自主创建ARP表，无需干预</li></ul><h2 id="寻址：从一个LAN路由到另一个LAN"><a href="#寻址：从一个LAN路由到另一个LAN" class="headerlink" title="寻址：从一个LAN路由到另一个LAN"></a>寻址：从一个LAN路由到另一个LAN</h2><p>通信过程：A通过路由器R向B发送数据报</p><ul><li>关注寻址：IP地址（数据报中）和MAC地址（帧中）</li><li>假设A直到B的IP地址（怎么知道的?）</li><li>假设A知道第一跳路由器R（左）接口IP地址</li><li>假设A知道第一条路由器R（左）接口的MAC地址</li></ul><p>A构造IP数据报，其中源IP地址是A的IP地址，目的IP地址是B的IP地址</p><p>A构造链路层帧，其中源MAC地址是A的MAC地址，目的MAC地址做接口的MAC地址，封装A到B的数据报</p><p>帧从A发送到R</p><p>R接收帧，提取IP数据报，传递给上层的IP协议</p><p>R转发IP数据报</p><p>R构造链路层帧，其中源MAC地址是R接口的MAC地址，目的MAC地址是B的MAC地址，封装A到B的IP数据报</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
