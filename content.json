{"posts":[{"title":"CN-ARP协议","text":"[[CN-NotesView]] MAC地址32位的IP地址： 接口的网络层地址 用于标识网络层(第三层)分组，支持分组转发 MAC地址（或称LAN地址，物理地址，以太网地址） 作用：用于局域网内的标识一个帧从哪个接口发出没到达哪个物理相连的其他接口 48位MAC地址（用于大部分LANs）固化在网卡的ROM中，有时也可以用软件设置 局域网的每块网卡都有唯一的MAC地址 MAC地址由IEEE统一管理和分配 网卡生产商够吗MAC地址空间（前24bit） 类比： MAC地址：身份证号 IP地址：邮政地址 MAC地址是“平面”地址: 可“携带 可以从一个LAN移到另一个LAN IP地址是层次地址: 不可“携带“ IP地址依赖于结点连接到哪个子网 ARP：地址解析协议问题：（在同一个LAN内）如何在一致目的接口的IP地址前提下确定其MAC地址？ ARP表：LAN中的每个IP结点(主机/路由器)维护一个表 存储某些LAN结点的IP、MAC关系地址映射关系：&lt;IP;MAC;TTL&gt; TTL(Time To Live): 经过这个时间之后这个映射关系会被遗弃 A想要给同一个局域网内的B发送数据报 B的MAC地址不再A的ARP表中。 A广播ARP查询分组，其中包含B的IP分组 目的MAC地址 = FF-FF-FF-FF-FF-FF LAN中的所有结点都会接收ARP查询 B接收ARP查询分组，IP地址匹配成功，向A应答B的MAC地址 利用单播帧向A发送应答 A在其ARP表中，缓存B的IP-MAC地址对，直至超时 超时之后，再次刷新 ARP是”即插即用“协议： 结点自主创建ARP表，无需干预 寻址：从一个LAN路由到另一个LAN通信过程：A通过路由器R向B发送数据报 关注寻址：IP地址（数据报中）和MAC地址（帧中） 假设A直到B的IP地址（怎么知道的?） 假设A知道第一跳路由器R（左）接口IP地址 假设A知道第一条路由器R（左）接口的MAC地址 A构造IP数据报，其中源IP地址是A的IP地址，目的IP地址是B的IP地址 A构造链路层帧，其中源MAC地址是A的MAC地址，目的MAC地址做接口的MAC地址，封装A到B的数据报 帧从A发送到R R接收帧，提取IP数据报，传递给上层的IP协议 R转发IP数据报 R构造链路层帧，其中源MAC地址是R接口的MAC地址，目的MAC地址是B的MAC地址，封装A到B的IP数据报","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ARP%E5%8D%8F%E8%AE%AE/"},{"title":"CN-CIDR和路由聚合","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] CIDR无类域间路由（CIDR：Classless InterDomain Routing) 消除传统的A类、B类和C类地址界限 NetID + SubID $\\to$ Network Prefix(Prefix) 可以任意的长度 融合子网地址和子网掩码，方便子网进行划分 无类地址格式：a.b.c.d/x，其中x为前缀长度 例如 和有类IP地址就有很大的区别了；也就是打破了有类地址的界限划分 子网 201.2.3.64，255.255.255.192 🤜 201.2.3.64/26 CIDR和路由聚合无类域间路由（CIDR) 提高IPv4的地址空间分配效率 可以将很多的C网划分在一起再统一的进行转发 能够提高路由效率 将多个子网聚合成一个较大的子网 构造超网 路由聚合（route aggregation） ## 路由聚合 层级编址使得路由信息通告更加高效 选用更加具体的路由：最长前缀匹配优先！ 通过前缀长度来加以区分","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-CIDR%E5%92%8C%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88/"},{"title":"CN-BGP协议","text":"[[CN-NotesView]] Internet AS间路由协议：BGP边界网关协议BGP：事实上的标准域间路由协议 将Internet “粘合”为一个整体的关键 BGP为每个AS提供了一种手段： eBGP：从邻居的自治系统获取子网的可达性信息 iBGP：向所有AS内部有尤其传播子网可达性信息 基于可达性信息和策略，确定到达其他网络的“好”路径 容许子网向Internet其余部分通告它的存在 BGP协议的基础BGP会话(session)：两个BGP路由器（”Peers”）交换BGP报文： 通告去往不同目的的前缀(prefix)的路径（“路径向量”）协议 报文交换基于半永久的TCP协议 BGP报文： OPEN：和peers建立TCP连接，并认证发送方 UPDATE：通告新路径（或者撤销原路径） KEEPALIVE：在没有UPDATE的时候，保活连接；也用于对OPEN请求的确认 NOTIFICATION：报告先前报文的差错；也被用于关闭连接 当AS3通告一个前缀给AS1时： AS3 承诺可以将数据报转发给该子网 AS3在通告中会聚合网络前缀 BGP基础：分发路径信息在3a和1c之间AS3利用eBGP会话向AS1发送前缀可达信息。 1c则可以利用iBGP向AS1内的所有路由器分发新的前缀可达性信息 1b可以(maybe not) 进一步通过1b-到-2a的eBGP会话，向AS2通告新的可达性信息 当路由器获得新的前缀可达性的时候，就会在转发表中增加关于该前缀的入口(路由项) 路径属性和BGP路由(route)通告的前缀信息包括BGP属性 前缀 + 属性 = “路由” 两个重要属性： AS-PATH : 包含前缀通告所经过的AS序列：e.g. AS 67,AS 17 NEXT-HOP(下一跳)：开始一个AS-PATH的路由器接口，指向吓一跳的AS BGP的路由选择网关路由器收到路由通告之后，利用其输入策略决策接收或者拒绝该路由 从不将流量路由到ASx基于策略的路由 路由器可能或者到某目的AS的多条路由，基于以下准则： 本地偏好值属性：策略决策 最短的AS-PATH 最近的下一跳路由器 BGP路由选择策略提供商网络客户网络桩网络双宿网络 为什么采用不同的AS内和AS间的路由协议策略(policy):inter-AS:期望能够管理控制流量如何被路由，谁路由经过其网络等intra-AS: 单一管理，无需策略决策 规模(scale)层次路由节省路由表大小，减少路由更新流量适应大规模互联网 性能(performance):intra-AS:侧重性能inter-AS: 策略主导","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-BGP%E5%8D%8F%E8%AE%AE/"},{"title":"CN-Cookie","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[2023-09-17]] 为什么需要Cookie?HTTP协议无状态 很多应用需要服务器掌握客户的状态： 网上购物 Cookie技术某些网站为了辨别身份，进行session跟踪而存储在用户本地终端上的数据（通常经过加密）RFC6265 Cookie的组件 HTTP响应消息的cookie头部行 HTTP请求消息的cookie头部行 保存在客户端主机上的cookie文件，由浏览器管理 Web服务器端的后台数据库 Cookie的原理Susan 首次PC上网，首次和Amazon.com取得联系。界定过去访问过eBay站点，当请求报文到达该Amazon Web服务器的时候，这个Web站点将产生一个唯一的识别码，并以此缩影在它的后端数据库中产生一个表项。接下来Amazon Web服务器用一个包含Set-cookie：首部的HTTP响应报文来对Susan的浏览器进行响应，其中Set-cookie:首部含有识别码。 Susan浏览器收到了该HTTP的响应报文的时候，它会看到该Set-cookie:首部。该浏览器在它管理的特定cookie文件中添加一行，该行包含服务器的主机名和在Set-cookie：首部中的识别码。 值得注意的是当前的cookie文件已经有了eBay的表项，因为Susan过去访问过该站点。之后的浏览都会从该cookie文件中获取她对这个网站的识别码，并放到HTTP请求报文中包括识别码的cookie首部行中。 在这种方式下，Amazon服务器可以跟踪Susan在Amazon站点的活动。Amazon使用cookie来提供 购物车服务 ![[assets 1/Pasted image 20230917115446.png]] Cookie的作用 cookie能够用于：**** 身份认证 购物车 推荐 Web e-mail …… 隐私问题","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Cookie/"},{"title":"CN-DHCP协议","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 如何获得IP地址Q： 一个主机如何获得IP地址？ ”硬编码“：静态配置 需要配置的信息包括IP地址和子网掩码。 默认网关： 所谓的默认网关就是当这个IP的数据报在向外传递数据的时候应该向什么地方进行转发。代表的是路由器的接口。 路由器接入子网的这个接口的IP地址就是这个子网中所有主机的默认网关。 域名服务器：默认的域名服务器 本地域名服务器 动态地址的获取 动态主机配置协议：DHCP Dynamic Host Configuration Protocol 从服务器动态获取 IP地址 子网掩码 默认网关地址 DNS服务器名称和IP地址 “即插即用” 允许地址的重用 支持在用地址的续租 支持移动用户加入网络 动态主机配置协议新到主机（DHCP客户）需要本网IP地址 ”主机广播“：DHCP discover（发现报文） DHCP服务器利用”DHCP offer“(提供报文)进行相应 主机请求IP地址：”DHCP request“ (请求报文) DHCP工作过程示例DHCP server: 223.1.2.5.67 DHCP协议在应用层实现请求报文封装到UDP数据报中 IP广播 链路层广播（以太网广播） DHCP服务器构造ACK报文 包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DHCP%E5%8D%8F%E8%AE%AE/"},{"title":"CN-DELETE","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[2023-09-17]] 删除URL字段所指定的文件","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DELETE/"},{"title":"CN-DNS概述","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); #DNS 互联网中的核心服务 [[2023-09-18]] 有关DNS基础资料查询 DNSDomain Name System，域名系统）是互联网的一项服务，用于将域名转换成与之相对应的IP地址。DNS的作用是通过域名，将用户能够记忆的域名转化为计算机能够识别的IP地址，以便进行网络通信。DNS服务运行在域名服务器上，当用户发起域名解析请求时，通过查询域名服务器上的缓存，将域名解析为对应的IP地址。查询DNS基础资料可以了解DNS的工作原理、域名解析过程以及DNS的作用等。以下是一些有关DNS基础资料的参考链接：- 通俗易懂，了解什么是DNS及查询过程？ - 介绍了DNS是什么、DNS的查询过程等基础知识。- DNS基础知识详解 - 对DNS基础知识进行详细解析。- 什么是DNS以及DNS工作原理 - 介绍了DNS的工作原理和作用。- DNS原理简述 - 简要介绍了DNS的原理和查询过程。DNS：Domain Name System Internet 上主机、路由器的识别问题 IP地址 域名：www.hit.edu.cn 问题：域名和IP地址之间如何映射？💭资料查询： 域名和IP地址之间的映射是通过DNS（Domain Name System）来实现的。DNS是一种分布式数据库系统，它将域名解析为相应的IP地址。当用户在浏览器中输入一个域名，比如”","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-DNS%E6%A6%82%E8%BF%B0/"},{"title":"CN-HEAD","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[2023-09-17]] 请Server不要将所请求的对象放入响应消息中","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HEAD/"},{"title":"CN-Email消息格式和POP3协议","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); ## Email消息格式 SMTP: email 消息的传输/交换协议 RFC 822: 文本消息格式标准 头部行 To From Subject 消息体 消息本身 只能是ASCII字符 Email消息格式：多媒体扩展MIME：多媒体邮件扩展RFC 2045，2056 通过邮件头部增加额外的行以声明MIME的内容类型 邮件访问协议邮件访问协议：从服务器获取邮件 POP ：Post Office Protocol [RFC 1939] 认证/授权（客户端 $\\iff$ 服务器）和下载 IMAP: Internet Mail Access Protocol [RFC 1730] 更多功能 更加复杂 能够操纵服务器上存储的信息 HTTP：163，QQ Mail等 POP协议认证过程 客户端命令： User: 声明用户名 Pass：声明密码 服务器响应 +OK -ERR 事务阶段List : 列出消息数量Retr : 用编号获取消息Dele : 删除消息Quit “下载并删除模式“ 用户如果换了客户端软件，就没有办法重新读这个邮件 “下载并保持模式” 不同客户端都可以保留消息的拷贝 POP3是无状态的IMAP协议所有消息统一保存在同一个地方：服务器 允许用户利用文件夹组织消息 IMAP支持跨会话（Session）的用户状态： 文件夹的名字 文件夹和消息ID之间的映射等等 课后练习MAP和POP3协议有什么不同？调研一下主流Email服务对IMAP协议的支持情况 IMAP（Internet Mail Access Protocol）和POP3（Post Office Protocol）都是用于获取和管理电子邮件的协议，但存在一些区别。 差异： IMAP允许用户在本地和远程邮件客户端之间同步邮件状态，包括已读、删除等操作。而POP3只是简单地从服务器上下载邮件到本地，不对邮件状态进行同步。 IMAP在服务器上保留邮件的副本，用户可以在不同的设备上访问和管理邮件。而POP3将邮件下载到本地后，通常会删除服务器上的副本。 IMAP支持文件夹和子文件夹的管理，可以方便地组织和管理邮件。而POP3通常只有一个收件箱。 关于主流Email服务对IMAP协议的支持情况，我们可以进行调研： 根据Cloudflare的文章What is IMAP? IMAP vs. POP3，几乎所有的主流Email服务都支持IMAP协议。这包括Gmail、Outlook、Yahoo Mail等。 另外，根据知乎的回答POP3, SMTP, IMAP 大相径庭—详解邮箱相关知识，POP3协议通常用于普通邮件客户端，比如Outlook，而IMAP协议更适合移动设备和Web邮件界面。综上所述，IMAP和POP3协议在邮件管理和访问方式上存在一些差异，主流Email服务一般都支持IMAP协议。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Email%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F%E5%92%8CPOP3%E5%8D%8F%E8%AE%AE/"},{"title":"CN-HTTP消息格式","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[2023-09-17]] # HTTP请求消息 HTTP有两类消息 请求消息 响应消息 请求消息ASCII：人直接可读 HTTP请求消息的通用格式 上传输入的方法POST方法 网页需要填写表格 在请求消息的消息体（entity body）中上传客户端的输入 URL方法 使用GET方法 输入信息通过request行的URL字段上传 方法的类型HTTP/1.0 GET/POST/[[CourseNotes/计算机网络/CN-HEAD]] HTTP/1.1 GET,POST,HEAD [[CourseNotes/计算机网络/CN-PUT]] [[CourseNotes/计算机网络/CN-DELETE]] HTTP的响应消息 HTTP响应状态代码 响应消息是第一行 示例 200 OK 301 Moved Permanently 400 Bad Requeast 404 Not Found 505 HTTP Version Not Supported 体验一下HTTP利用telnet 登录到某个Web服务器 telnet www.hit.edu.cn:80 输入一个HTTP请求 GET/about/profile.html HTTP/1.1 Host: www.hit.edu.cn 查看HTTP服务器所返回的响应消息","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F/"},{"title":"CN-Homework1-1","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); ## 题目1 ( 14分 ) 如图所示网络。A在t=0时刻开始向C发送一个2Mbits的文件；B在t=0.1+e秒（e为无限趋近于0的小正实数）向D发送一个1Mbits的文件。忽略传播延迟和结点处理延迟。 请回答下列问题： 如果图中网络采用存储-转发方式的报文交换，则A将2Mbits的文件交付给C需要多长时间？B将1Mbits的文件交付给D需要多长时间？ （1）500ms。由于采用报文交换，只有A来进行传输，B的传输不会影响A的传输。设左边的路由器为F，右边的路由器为E，那么从A到F之间的时间为2/10=0.2s，此后从F到E的传输则为2/20=0.1s，此时实现从F到E，最后从E到C所用的时间为0.2s，所以总的时间就是0.5s的时间。 （2）350ms。在从B到F的过程中不受影响，传输的时间为1/10=0.1s; 从F传输到E的过程中，需要等待A传输完成，A传输时间为0.1s，B端的传输时间就为0.1+0.05=0.15s；从E传到D的时候需要0.1s。A不会影响传输所以一共为0.35s。 如果图中网络采用存储-转发方式的分组交换，分组长度为等长的1kbits，且忽略分组头开销以及报文的拆装开销，则A将2Mbits的文件交付给C需要大约多长时间？B将1Mbits的文件交付给D需要大约多长时间？ (1) 0.200015s。只需要考虑A的第一个分组的传输方式，$T=T_{first}+T_{rest}=\\frac{2 \\times 1kb}{10Mb/s}+\\frac{1kb}{20Mb/s}+\\frac{1999 \\times 1kb}{10Mb/s}=0.200015s$ (2) 0.10002s。同样只需要考虑B的第一个传输和剩下的传输，B的第一个传输是全为10Mb/s，$T=M/R+2L/R=\\frac{1Mb}{10Mb/s}+2 \\times \\frac{1kb}{10Mb/s}=1.0002s$ 报文交换与分组交换相比，哪种交换方式更公平？（即传输数据量小用时少，传输数据量大用时长） 分组交换更公平","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-1/"},{"title":"CN-HTTP连接类型","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[2023-09-17]] # HTTP连接 非持久性连接（Nopersistent HTTP） 每个TCP连接最多允许传输一个`非持久性连接 持久性连接（Persitent HTTP） 每个TCP连接允许传输多个对象 HTTP 1.1 版本默认使用持久性连接 非持久性连接 www.someSchool.edu/someDepartment/home.index $\\rightarrow$ (包含文本和指向10个jepg图片的链接) 1234567graph TB 1A(&quot;1a:HTTP客户端向地址为\\nwww.someSchool.edu/someDepartment/home.index\\n的服务器上的HTTP服务器进程（端口80）\\n发起TCP连接请求&quot;)--&gt;1B(&quot;1b:HTTP服务器在端口80等待TCP连接请求，接受链接并通知客户端&quot;) 1B--&gt; 2(&quot;2:HTTP客户端将HTTP请求消息（包含URL地址）\\n通过TCP链接的套接字发出，\\n消息中所含有的URL表明客户端需要对象\\n someDepartment/home.index&quot;) 2--&gt;3(&quot;3:HTTP服务器收到请求消息，\\n 解析，产生包含所需要对象的相应消息,\\n并通过套接字发送给客户端&quot;) 3--&gt;4(&quot;4:HTTO服务器关闭TCP连接&quot;) 4--&gt;5(&quot;5:HTTP客户端收到响应消息，\\n解析html文件，发现有10个指向jepg对象的超链接&quot;) 6(&quot;对每个jepg对象重复步骤1-5&quot;) 响应时间分析和建模RTT(Round Trip Time) 从客户端发送一个很小的数组包到服务器并返回所经历的时间 响应时间(Response time) 发起、建立TCP连接：一个RTT 发送HTTP请求消息到HTTP响应消息的前几个字节到达：一个RTT 响应消息中所含有的文件/对象传输时间 Total = 2RTT + 文件发送时间 持久性HTTP非持久性连接的问题 每个对象都需要2个RTT 操作系统需要为每个TCP连接开销资源(overhead) 浏览器会怎么做： 打开多个并行的TCP连接以获取网页所需要的对象 给服务器端造成什么影响？ 会造成很大的负担（是有代价的,TCP很宝贵） 持久性连接 发送响应后，服务器保持TCP连接的打开 后续的HTTP消息可以用通过这个直接连接发送 无流水的持久性连接 客户端只有收到前一个响应之后才发送新的请求 每个被应用对象耗时1RTT 带有流水机制的持续性连接 HTTP 1.1的默认选项 客户端只要遇到一个应用对象就会尽快发出请求 理想情况下，收到所有应用对象只需要耗时大约一个RTT[[CourseNotes/计算机网络/CN-No.5 计算机网络的体系结构]]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-HTTP%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B/"},{"title":"CN-Homework1-2","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); ## 题目2 ( 10分 ) 考虑两台主机A和主机B由一条带宽为R bps、长度为M米的链路互连，信号传播速率为V m/s。假设主机A从t=0时刻开始向主机B发送分组，分组长度为L比特。试求： 传播延迟（时延）dp； dp = M / V 传输延迟dt； dt = L / R 若忽略结点处理延迟和排队延迟，则端到端延迟de是多少？ de = dt + dp 若dp&gt;dt，则t=dt时刻，分组的第一个比特在哪里？ 此时还没有到达主机，所以第一个比特在距离A主机 $\\frac{M}{V} \\times dt$ 的位置处 若V=250000km/s，L=512比特，R=100 Mbps，则使带宽时延积刚好为一个分组长度（即512比特）的链路长度M是多少？ 带宽时延积 = $dp \\times R$ 代入带宽时延积为512bit，$dp = \\frac{512bit}{100Mbps} = 5.12 \\times 10^{-6} s=\\frac{M}{V}=\\frac{M}{250000km/s}$ 可以解得dp = 1024m (注：1k=10^3^,1M=10^6^)","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-2/"},{"title":"CN-Homework1-3","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); ## 题目3 假设主机A向主机B以存储-转发的分组交换方式发送一个大文件。主机A到达主机B的路径上有3段链路，其速率分别是R1=500kbps，R2=2Mbps，R3=1Mbps。试求： 假设网络没有其他流量，则传送该文件的吞吐量是多少？ 吞吐量选择其中传输速率最小的链路：500kbps 假设文件大小为4MB，则传输该文件到主机B大约需要多少时间？ $T = 4MB/R = 4*10^3/500kbps = 64s$ (注：1k=10^3^,1M=10^6^)","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework1-3/"},{"title":"CN-Homework2-1","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); 假设你在浏览某网页时点击了一个超链接，URL为“https://www.kicker.com.cn/index.html”，且该URL对应的IP地址在你的计算机上没有缓存；文件index.html引用了8个小图像。域名解析过程中，无等待的一次DNS解析请求与响应时间记为RTTd，HTTP请求传输Web对象过程的一次往返时间记为RTTh。请回答下列问题： ‍1）你的浏览器解析到URL对应的IP地址的最短时间是多少？最长时间是多少？ 浏览器解析到URL对应的IP地址最短时间是RTTd，最长时间是5RTTd。 ‍2）若浏览器没有配置并行TCP连接，则基于HTTP1.0获取URL链接Web页完整内容（包括引用的图像，下同）需要多长时间（不包括域名解析时间，下同）？ 如果浏览器没有配置并行TCP连接，则基于HTTP1.0获取链接Web页面完整内容所需要的时间为18RTTh‏‍3) 若浏览器配置5个并行TCP连接，则基于HTTP1.0获取URL链接Web页完整内容需要多长时间？ 如果浏览器配置5个并行TCP连接，那么基于HTTP1.0获取URL链接Web页面时间为6RTTh* ‍4) 若浏览器没有配置并行TCP连接，则基于非流水模式的HTTP1.1获取URL链接Web页完整内容需要多长时间？基于流水模式的HTTP1.1获取URL链接Web页完整内容需要多长时间？ 如果浏览器没有配置并行TCP连接，基于非流水模式的HTTP1.1获取URL链接Web页完整内容需要的时间为3RTTh‏ ‍","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework2-1/"},{"title":"CN-Homework4-1","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] #task 假设A、B两个端系统通过唯一的一条8Mbps链路连接（M=10^6），该链路的双向传播时延是150ms；A通过一个TCP连接向B发送一个大文件，B的接收缓存足够大，每个TCP段最大段长度（MSS）为1500字节，TCP采用Reno版本，且总是处于拥塞避免阶段（即忽略慢启动）。请回答下列问题： 该TCP连接能够获得的最大窗口尺寸（以TCP段数计）是多少？ ‏2. 该TCP连接的平均窗口尺寸（以TCP段数计）和平均吞吐量（以bps计）是多少？ ‏3. 该TCP连接的拥塞窗口从发生丢包到恢复到最大窗口尺寸要经历多长时间？ ‏","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework4-1/"},{"title":"CN-Homework3-1","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] (18 分） 考虑向 N 个对等方（用户）分发 F=15Gb 的一个文件。该服务器具有 us=30Mbps 的上传速率，每个对等方的下载速率 di=2Mbps，上传速率为 u。请分别针对客户-服务器分发模式和 P2P 分发模式两种情况，对于 N=10、 100 和 1000 以及 u=500kbps、 1Mbps 和 2Mbps 的每种组合，绘制最小分发时间图表。（注： k=10^3、 M=10^6、 G=10^9） 列表如下所示： C/S Mode N=10 N=100 N=1000 500kbps 7500s 50000s 500000s 1Mbps 7500s 50000s 500000s 2Mbps 7500s 50000s 500000s P2P Mode N=10 N=100 N=1000 500kbps 7500s 18750s 28302s 1Mbps 7500s 11538s 14563s 2Mbps 7500s 7500s 7500s","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework3-1/"},{"title":"CN-Homework5-1","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] #task如图所示网络。 ​ 请回答下列问题：(1)主机在配置IP地址时，其正确的子网掩码和默认网关分别是多少？ ​ (2)若路由器R在向互联网转发一个由主机192.168.1.5发送、ID=12345、length=500B、DF=1的IP分组时，则该IP分组首部的哪些字段会被修改？如何修改？ ​ (3)若主机192.168.1.10向互联网ID=6789、length=1500B、DF=0的IP分组时，路由器需要将该IP分组分为几片（每片尽可能封装为最大片）？给出分片结果，包括每片的ID、DF、MF、length、offset的取值。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Homework5-1/"},{"title":"CN-ICMP协议","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 互联网控制报文协议（ICMP）互联网控制报文协议ICMP（Internet Control Message Protocol）支持主机和路由器： 差错（或者异常）报告 网络查询 两类ICMP报文差错报告报文（5种）目的不可达 丢弃的报文可以通过ICMP协议来进行请求 源抑制 超时/超期 参数问题 重定向（Redirect） 网络探寻报文(2组)回声请求和应答报文 时间戳请求和应答报文 ICMP报文 例外情况几种不发送ICMP差错报告报文的特殊情况 对ICMP差错报告报文不再发送ICMP差错报告报文 除了第一个IP数据报分片之外，对所有后续分片均不发送ICMP差错报告报文 对所有多播IP数据报均不发送ICMP差错报告报文 对具有特殊地址（127.0.0.0或者0.0.0.0）的IP数据报不发送ICMP差错报告报文 几种ICMP报文不再使用 信息请求和应答报文 子网掩码请求和应答报文 路由器询问和通告报文 ICMP报文的格式ICMP报文封装到IP数据报中传输 ICMP差错报告报文数据封装差错IP数据报 ICMP的应用举例：Traceroute源主机向目的主机发送一系列UDP数据报第一组IP数据报TTL = 1 第二组IP数据报TTL = 2，etc 目的端口号为不可能使用的端口号 当第n组数据包（TTL = n）到达第n个路由器时路由器丢弃数据包 向源主机发送ICMP报文 ICMP报文携带路由器名称和IP地址信息 当ICMP报文返回源主机的时候，记录RTT停止准则 UDP数据包最终到达目的主机 目的主机返回目的端口不可达ICMP报文 源主机停止","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-ICMP%E5%8D%8F%E8%AE%AE/"},{"title":"CN-IPv6","text":"[[CN-NotesView]] IPv6： 动机最初动机：32位的IPv4的地址空间已经分配殆尽 其他动机：改进首部格式 快速处理/转发数据报 支持QoS IPv6的数据报格式： 固定长度的40字节基本首部 不允许分片 路由器不再支持分片，如果发生IP数据包的分片的话，需要在主机分片。 基本的首部 其他的首部称为选项首部（大部分情况下路由器是不需要处理的） 路由处理只需要处理40字节的基本头 这些选项首部和数据部分称为载荷 IPv6数据报的格式 优先级（priority）:标识数据报文的优先级流标签（flow Label）：标识同一流中的标签 更详细的定义还在讨论当中 载荷的长度一共是16bit，可以表示65535的长度范围 下一个首部指向的是第一个扩展首部，每一个扩展首部都指向下一个首部 也就是每个首部之间互相连接 跳步限制：对应了数据报在转发过程中能够通过的路由器总数 IPv6和IPv4相比的改变校验和：彻底移除，以较少每跳处理时间，减少数据包的处理时间 选项(options)：允许，但是从基本首部移除，定义多个选项首部，通过下一个首部字段来指示 ICMPv6：新版的ICMP： 附加报文类型 Packet too big 多播组管理功能 发送Packet too big报文转发给主机，让主机来进行分片 IGMP协议 也就是多播组的协议，这个被集成到了IPv6之中了 IPv6地址表示形式地址相当庞大，所以不能使用IPv4的点分十进制的方法 IPv6地址表示形式：冒号分割的十六进制的表示形式 一般形式：1080：0：FF：0：8：800：200C：417A 压缩形式：不能连续的两次使用连接的冒号，只用使用一次连续的冒号 IPv4的嵌入形式：0：0：0：0：0：FFFF：13.1.68.3 后面就是IPv4的嵌入形式，后面可以使用点分十进制 地址前缀：2002：43C：476b：：/48 IPv6已经不再使用掩码的方式 利用一个斜杠加网络前缀的方式表示 URLs：http://[3FFE::1:800:200C:417A]:8000 表示形式不出现歧义 IPv6基本地址类型单播地址(unicast):一对一通信 多播地址(unicast):一对多通信 没有单独的广播地址，广播地址被定义为特殊的多播地址 又定义了一种全新的数据类型： 任意播（anycast）： 发送到最近的接口上去 IPv4向IPv6过渡不可能在某个时刻所有路由器同时被更新位IPv6 不会有“标志性的日期” IPv4和IPv6路由器共存的网络如何运行？ 隧道：IPv6数据包作为IPv4数据包的载荷进行封装 Tunneling 隧道逻辑隧道：利用IPv4隧道，连接IPv6路由器 物理视角：","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IPv6/"},{"title":"CN-IP子网划分和子网掩码","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] A类网络的网络数量很少，C类网络的网络数量太多，B类网络编址的网络也容易被浪费掉。 子网划分（Subnetting）？有类地址在描述的过程中会出现的问题 在实际网络中A类网络和B类网络肯定不可能 就需要对大的网络区分成更小的网络范围：子网划分 怎么划分？ – IP地址上做文章 使用主机里面的IP比特之间进行划分 其他的子网就不会受到通信的影响 通过路由器来进行转发 Q：如何确定是否划分了子网？利用多少位来划分子网？区分的越多，地址空间就会小，所以子网的方式也很重要。 子网掩码形如IP地址： 32位 点分十进制形式 取值： NetID、SubID位全部取1 HostID位全取0 例如： A网的默认子网掩码为：255.0.0.0 B网的默认子网掩码为：255.255.0.0 C网的默认子网掩码为：255.255.255.0 借用3bit划分子网的B网的子网掩码为255.255.224.0 [!子网地址 + 子网掩码] 准确确定子网大小 For example 子网：201.2.3.0，255.255.255.0 划分为登场的4个子网 利用路由器来互联在一起 路由器怎么确定应该将IP分组进行转发? 将IP分组的目的IP地址和子网掩码 按位与运算，提取紫菀地址子网地址 例如： 目的IP地址：172.32.1.112，子网掩码：255.255.254.0 172.32.1.112 = 10101100 001000000 00000001 01110000255.255.255.254.0 = 11111111 11111111 11111110 00000000 子网地址：172.32.0.0（子网掩码：255.255.254.0）地址范围：172.32.0.0 ~ 172.32.1.255可分配地址范围：172.32.0.1 ~ 172.32.1.254广播地址：172.32.1.255 一个C类网络划分子网举例： 最左侧的列对应的是每一侧子网的子网地址，最右侧代表的是广播地址 会造成一部分的浪费","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%92%8C%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/"},{"title":"CN-IP分片","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 最大传输单元 数据帧 IP分组 网络链路存在MTU（最大传输单元）—— 链路层数据帧可以封装数据的上限 不同链路的MTU不相同 IP分片和重组问题，大IP分组向较小的MTU链路进行转发的时候，可以被分片(fragmented) 也不是一定要进行分片 大IP分组分片为多个小分组 IP分组的分片只分不装 IP分片的过程中不知道顺序关系 IP首部的相关字段用于表示分片以及确定分片的相对顺序 标识字段占16位：标识一个IP分组 IP协议利用一个计数器，没产生IP分组计数器加1，作为该IP分组的标识 标志位字段占3位： DF禁止分片 MF更多分片 DF = 1 禁止分片 DF = 0 允许分片 MF = 1 不是最后一片 MF = 0 最后一片 片偏移字段占13位：一个IP分组分片封装原IP分组数据的相对偏移量 片偏移字段是由8字节为单位（和首部长度一样的问题） 在IP分组分片的过程中分片的数量一定是8的倍数 加收原来的IP分组总长度为L，带转发链路的MTU为M，如果L&gt;M且DF=0，则可以/需要分片的时候每个分片的标识赋值原IP分组的标识 分片出来的所有IP分组都是一样的标识 通常分片的时候，除了最后一个分片，其他分片均分为MTU允许的最大分片 一个最大分片可以封装的数据应该是8的倍数，因此，一个最大分片可以封装的数据是：$d = [\\frac{M-20}{8}]\\times8$ 需要的总片数为：$n=[\\frac{L -20}{d}]+1$ IP分片的过程 每一篇的片偏移量的取值为：$F_i=\\frac{d}{8}\\times (i-1) , 1 \\leq i \\leq n$ 每一片的总长度字段： 每片的MF标志位为：","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E5%88%86%E7%89%87/"},{"title":"CN-IP编址","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] IP分组： 源地址（SA）- 从哪里来 目的地址（DA）- 到哪里去 接口（interface）：主机/路由器和物理链路的连接 实现网络层的功能 路由器通常有多个接口 主机通常只有一个或者两个接口（e.g 有限的以太网接口，无线的802.11接口） IP编址IP地址：32bit（IPv4） 编号标识主机、路由器的接口 IP地址和每个接口关联 怎样为接口分配IP地址？ IP子网 subnetsIP地址： 网络号（NETID）高位比特 主机号（HOSTID）低位比特 实际上的网络的标识方式如下： 可以用相同的网络号来描述相同区域的网络，称为IP子网 子网的IP地址的网络号是相同的，在所有网络里面所有的接口不超过三个网络设备就可以物理联通 不跨越路由器 （第三以及上层网络设备）可以彼此物理联通的接口 在存储向哪个网络转发数据的时候，只用知道子网地址就可以 可以用一个地址来描述子网：IP子网地址 图中网络有多少个IP子网? 通过IP地址就能够描述一个个的描述地址和子网 一个个IP子网互联而形成的互联网络 接口对应的IP地址保留之后可以看到有一些网络是孤岛（也就是IP子网）","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E7%BC%96%E5%9D%80/"},{"title":"CN-IP数据报","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] Internet 网络层主机、路由器网络层主要功能： 计算机网络层的协议： 1. 路由协议：路径选择；RIP,OSPF,BGP；2. 转发表（路由表）3. IP协议：寻址规约（conventions) ；数据报（分组）格式；分组处理规约4. ICMP协议：差错报告；路由器信令 —— IP协议的伴随协议 IP数据报（分组）格式 将IP数据报展开得到的是： 固定部分有20个字节 版本号：4bit IP协议的版本号首部长度：4bit IP分组的首部长度 4bit $\\to$ 0 ~ 15 所以没有办法给出20的大小的所以以4字节为单位才能标识全；所以在计算的时候需要乘上4 最典型的前面两段分别是 4 和 5 服务类型（TOS）字段： 8bit 指示期望获得哪种类型的服务这个字段改名为 区分服务 只有在网络提供区分服务（DiffDev）的时候使用 一般情况下这个字段都是00H 总长度字段：16bit IP分组的总字节数（首部+数据）最大IP分组的总长度：65535B 最小的IP分组首部：20B IP分组可以封装的最大数据：65535 -20 = 65515B 生存时间（TTL）字段占8位：IP分组在网络中可以通过的路由器数量路由器转发一次分组，TTL减1 如果TTL=0，路由器丢弃该IP分组 协议字段占8位：指示IP分组封装的是哪个协议的数据包实现了复用/分解 Eg 6为TCP，表示封装的是TCP段；17为UDP，表示封装的是UDP数据报 首部校验和字段占16位：实现对IP分组首部的差错检测计算校验和的时候，该字段设置为全0 采用反码算数运算求和，和的反码作为首部校验和字段 逐跳计算、逐跳检验 源IP地址、目的IP地址字段各占32位：分别表示发送分组的源主机/路由器（网络接口）和接受分组的目的主机/路由器（网路接口）的IP地址选项字段占用长度可变，范围在1~40B之间；携带安全、源选路径、时间戳和路由记录等内容实际上很少被使用 填充字段占长度可变，范围在0~3B之间；目的是不起整个首部符合32位对齐","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-IP%E6%95%B0%E6%8D%AE%E6%8A%A5/"},{"title":"CN-Lab1","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 实验 1HTTP 代理服务器的设计与实现代理服务器的设计与实现代理服务器的设计与实现 1.1.1.实验⽬的实验⽬的 熟悉并掌握 Socket ⽹络编程的过程与技术； 深⼊理解 HTTP 协议， 掌握 HTTP 代理服务器的基本⼯作原理； 掌握 HTTP 代理服务器设计与 编程实现的基本技能。 2.2.2.实验环境实验环境实验环境 接⼊ Internet 的实验主机； Windows 操作系统； 开发语⾔：C/C++（或 Java）等。 3.3.3.实验内容实验内容实验内容(1) 设计并实现⼀个基本 HTTP 代理服务器。要求在指定端⼝（例如 8080）接收来⾃客户的 HTTP 请求并且根据其中的 URL 地址访问该地址 所指向的 HTTP 服务器（原服务器），接收 HTTP 服务器的响应报⽂，并 将响应报⽂转发给对应的客户进⾏浏览。 (2) 设计并实现⼀个⽀持 Cache 功能的 HTTP 代理服务器。要求能缓 存原服务器响应的对象，并能够通过修改请求报⽂（添加 if-modified-since 头⾏），向原服务器确认缓存对象是否是最新版本。（选作内容，加分项 ⽬，可以当堂完成或课下完成） (3) 扩展 HTTP 代理服务器，⽀持如下功能：（选作内容，加分项⽬， 可以当堂完成或课下完成） a) ⽹站过滤：允许/不允许访问某些⽹站； b) ⽤户过滤：⽀持/不⽀持某些⽤户访问外部⽹站； c) ⽹站引导：将⽤户对某个⽹站的访问引导⾄⼀个模拟⽹站（钓⻥）。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab1/"},{"title":"CN-Lab4","text":"[[CN-NotesView]]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Lab4/"},{"title":"CN-NAT","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 网络地址转换（NAT） 网络地址转换 本地网络内通信的IP数据包的源和目的IP地址均在子网10.0.0/24内 所有离开本地网络去往Internet的数据报的源IP地址需要替换成相同的NATIP地址：138.76.29.7以及不同的端口号。 网络地址转换NAT动机只能/需要从ISP中申请一个IP地址，IPv4地址耗尽。 本地网络设备IP地址的变更，无需通告外界网络。 无论怎么变对外界来说都是一样的。 变更ISP的时候，无需修改内部网络设备IP地址 内部网络设备对外界网络不可见，也就是不可直接寻址（安全） 实现替换利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IPD地址，源端口号） 记录将每对（NAT IP地址，新端口号）和（源IP地址，源端口号）的替换信息存储到NAT转换表中 替换根据NAT转换表，利用（源IP地址，源端口号）替换每个进入内网IP数据报的（目的IP地址，目的端口号），也就是（NAT IP地址，新端口号） 16-bit端口号字段：65536 可以同时支持60，000多个并行连接 NAT的主要争议： 路由器应该只处理第三层功能 违背端到端的通信原则 应用开发者必须考虑到NAT的存在，e.g P2P应用 地址短缺问题应该由IPv6来解决 NAT穿透问题穿透问题： 10.0.0.1的服务器 客户并不能直接利用地址10.0.0.1直接访问服务器 对外唯一课件的地址是NAT地址138.76.29.7 解决方案1： 静态配置NAT，将特定端口的连接请求转发给服务器 e.g.,(138.76.29.7,2500)总是转发给(10.0.0.1,25000) 解决方案2：利用UPnP互联网网关设备协议（IGD-Internet Gateway Device） 学习到NAT公共IP地址(138.76.29.7) 到NAT转发表中，增删端口映射 解决方案3：中继（e.g. Skype） NAT内部的客户和中继服务器建立连接 外部的客户也和中继服务器建立连接 中继服务器桥接两个连接的分组 connection to relay initiated byu NATed host connection to relay initiated by client relaying established","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NAT/"},{"title":"CN-NetworkLayer-Reading","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-NetworkLayer-Reading/"},{"title":"CN-No.1 计算机网络基本概念","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] # 计算机网络基本概念 什么是计算机网络计算机网络 = 通信技术 + 计算机技术 计算机网络是通信系统和计算机技术紧密结合的产物 通信系统模型 123456789graph LR A(&quot;信源&quot;) B(&quot;发送设备&quot;) C(&quot;信道&quot;) D(&quot;噪声源&quot;) E(&quot;接受设备&quot;) F(&quot;信宿&quot;) A--&gt; B--&gt;C--&gt;E--&gt;F D--&gt;C 计算机网络就是一种通信网络 计算机网络计算机网络就是互联的自治的计算机集合 自治 → 没有主从关系 互联 → 互联互通 通信链路 各个节点叫做主机，连接主机的叫做通信链路 距离远数量大的时候怎么保证互联 通过交换网络互联主机 中间一个交换网络，主机连在交换网络上，交换网络里面的节点叫做交换节点 什么是Internet? - 组成细节角度 全球的最大互联网络 ISP( Internet Service Provider )网络互联的“网络的网络” 数以百万计的互联的计算设备集合： 主机（host）= 端系统（end system） 运行各种网络应用 通信链路 光纤，铜缆无线电等 分组交换：转发分组(数据包) 路由器（routers）和交换器（switches） 什么是Internet？ - 服务角度 为网络应用提供通信服务的通信基础设施： Web,VolP,email,网络游戏，电子商务，社交网络，…… 为网络应用提供编程接口（API）： 支持应用程序“连接”Internet，发送/接受数据 问题Q： 仅有硬件链接Internet能否顺畅运行？能保证应用数据的有序交付吗？ A：No！ 还需要协议！ 下一页[[CourseNotes/计算机网络/CN-No.2 计算机网络的结构]]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.1%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"CN-No.2 计算机网络的结构","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 计算机网络的结构 网络边缘 主机 网络应用 接入网络、物理介质 有限或者无线通信链路 核心网络（网络核心） 互联的路由器（或者分组转发设备） 网络之网络 网络边缘 主机端系统 位于网络边缘 运行网络应用程序 客户、服务器应用模型 客户端发送请求，服务端接受请求并作出响应 Web应用，文件传输FTP应用 所有的通信是在客户和服务器之间进行 对等应用模型 没有专用服务器 通信在对等实体之间相互进行 QQ 接入网络 居民接入网络 机构接入网络 移动接入网络 用户关心的是 带宽（bps） 接入方式是独占的还是共享的 代表性的接入网络 Example 1： 数字用户线路 利用已有的电话网络来进行接入中心局的DSLAM 数据通信通过DSL线接入internet 语音通过DLS线接入电话网络 上行速率低，下行速率快 下行：&gt;50KHz ~ 1MHz上行：4KHz ~ 50KHz传统电话：0KHz ~ 4KHz 频分多路复用技术：在不同的载波上传输不同的频道 HFC 混合光纤同轴电缆 下行大于上行 典型家庭网络的接入 主要用于高校、企业、公司等机构 目前端系统通常直接连接以太网交换机（switch） 无线接入网络通过共享的无线接入网络连接端系统和路由器 通过基站或者称为”接入点” 无线局域网 同一建筑物内（30m） 广域无线接入 3G 4G 5G 网络核心 互联的路由器网络 网络的核心功能：路由+转发 路由 确定分组从源到目的传播路径 转发 将分组从路由器的输入端口交换至正确的输出端口 Internet 网络结构：网络之网络 端系统通过接入ISP（access ISP）连接到internet 接入ISP必须进一步互联 构成复杂的网络互连的网络：经济和国家政策是网络演进的主要推动力 当前的Internet网络结构是什么样的呢？动态性很强，无法给出描述 数以百万计的ISP是如何互联在一起的呢 方案1： 全连接 但是当基数过大会导致连接数量指数级增长 方案2：构建一个全球的大ISP 实际上不可能只有一个ISP 最终情况：有多个大型的ISP来进行互联，再将大型的ISP进行互联 → 互联的方式：对等链路 最后会用区域性的局域网络来连接每一部分的ISP，就构建好了整个的Internet网络 上一页：[[CourseNotes/计算机网络/CN-No.1 计算机网络基本概念]]下一页：[[CourseNotes/计算机网络/CN-No.3 网络核心]]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.2%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%93%E6%9E%84/"},{"title":"CN-No.4 计算机网络性能","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 速率 速率指的是数据率或者称为比特率 单位时间传输信息量 计算机网络中最重要的一个性能指标 单位：b/s(或bps)、kb/s、Mb/s、Gb/s $k=10^3、M=10^6、G=10^9$ 速率指的是额定速率或者标称速率 带宽带宽 指的是信号具有的额频带宽度，也就是最高频率和最低频率之差，单位是Hz。 网络的“带宽”指的是信道能传输的“最高数据率”，单位 b/s （bps） 常用的带宽单位： kb/s Mb/s Gb/s Tb/s 延迟/时延（delay）分组交换为什么会繁盛丢包和时延？ $d_{proc}$：节点处理延迟（nodal processing delay） 差错检测 确定输出链路 通常 &lt; m sec $d_{queue}$：排队延迟（queuing delay） 等待输出链路可用 取决于路由器拥塞程度 $d_{trans}$：传输延迟 L ： 分组宽度 R：链路带宽 $d_{trans}$ = L/R $d_{prop}$：传播延迟 d ： 物理信号链路长度 s ：信号传播速度 $d_{prop}$ = d/s 车速为100 km/hr~ 信号传播速度 收费站放行一台车用时12 秒 ~ 比特传输时间 车 ~ 比特;车队 ~ 分组 车队通过收费站时间 ~ 传输延迟 (120秒) 每台车从第一个收费站跑到第二个收费站用时~ 传播延迟 (1小时) 排队延迟特殊的点在于不确定 R：链路带宽（bps） L：分组长度（bits） a：平均分组到达速率 流量强度（traffic intensity = $L \\ a / R$） ~0 平均排队延迟很小 → 1 平均排队延迟很大 $\\gt$ 1 无限大 时延带宽积（带宽时延积） 时延带宽积 = 传播时延 $\\times$ 带宽 时延带宽积 = $d_{drop} \\times R \\ (bits)$. 链路的时延带宽积又称为以比特为单位的链路长度 分组丢失（丢包） 队列缓存容量有限 分组到达已满队列将被丢弃 丢弃分组可能有前序结点或者源重发（也可能不重发） $丢包率 = \\frac{丢包数}{已发分组总数}$. 吞吐量（Throughput）吞吐量： 表示在发送端与接收端之间传送数据速率（b/s） 即时吞吐量：给定时刻的速率。 平均吞吐量：一段时间的平均速率。 端到端的吞吐量决定于传播的各阶段吞吐量的最小值。 若$R_s &lt; R_c$ 吞吐量就是 $R_s$. 若$R_s &gt;R_c$ 吞吐量就是$R_c$. 🥈 瓶颈链路（bottleneck link） 端到端路径上，限制端到端吞吐量的链路。 考虑10条“连接”共享主干网瓶颈链路R bits/sec 每条连接的端到端的吞吐量： min($R_c,R_s,R/10$) 实际网络：$R_c$或$R_s$通常是瓶颈 上一页： [[CourseNotes/计算机网络/CN-No.3 网络核心]] 下一页：[[CourseNotes/计算机网络/CN-No.5 计算机网络的体系结构]]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.4%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/"},{"title":"CN-No.3 网络核心","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 网络核心 为什么需要数据交换 $N^2$ 链路问题 将主机和交换设备连接 连通性 网络规模 交换？ 动态转接 动态分配传输资源 数据交换的类型电路交换电路交换的特点 最典型的电路交换网络：电话网络 W 所以电路交换过程可以分为三个阶段： 建立连接（呼叫/电路建立） 通信 释放连接 独占资源（比如信道资源）是不能被第三方共享的 电路交换网络的链路共享→ 电路交换网络如何共享中继线？ 多路复用技术 多路复用简称复用，是通信技术的基本概念 传输能力大于单路的信息，所以要实现多路复用技术 复用器进行组合，分用器来进行拆分 多路复用：链路、网络资源 划分为资源片 将资源片分配给各路“呼叫” 每路呼叫独占分配到的资源篇进行通信 资源片可能闲置 典型多路复用方法 频分多路复用 最具代表性的就是有线电视网络 每个用户占用不同的带宽资源 用户在分配到一定的频带后，那自始自终都占用这个频带 频分多路技术 时分多路复用 划分为帧 每个用户占据固定序号的时间间隙 每个用户占用的时间间隙是周期性出现的 在频率上是不分割的 时分多路复用 波分多路复用 光的频分复用 中间的链路是可以共享的，称为中继线 码分多路复用 广泛应用于无线链路共享（蜂窝网，卫星通信） 每个用户分配一个唯一的m bit的码片序列chipping sequence 用户使用相同频率载波，利用各自码片序列编码数据 $编码信号 = (原始数据)\\times (码片序列)$。 如发送比特1(+1），则发送自己的m bit码片序列 如发送比特0(-1)，则发送该码片序列的m bit码片序列的反码 各个用户码片序列相互正交 解码：码片序列和编码信号的内积 具体的实现步骤 在发送端和接收端的信号传输 如果是多个用户向信道发送数据 需要保证码片之间是正交的 数据交换：报文交换，分组交换报文交换 电路交换资源是独占的，报文指的是发送的信息的整体 比如：一个文件 分组交换（package switch） 分组：报文分叉出来的一系列相对较小的数据包 头 + 数据 分组交换需要保温的拆分和重组 产生额外开销（因为要消费额外开销） 作为分组交换网络，这样的共享不是事先就分配一部分，而是两个的数据分别都是用完整带宽进行转发，具有很强的随机性。所以也称为统计多路复用统计多路复用最大的特点就是按需共享链路。 每一个分组从上一个节点完整的转发分组，然后存储之后转发走。称为存储转发操作。 这里能保证是有效的数据，有且仅有当两个向量正交的时候才有效，可以通用数学推导出来。主要原因是因为可以去除S1信道和S2信道的交叉乘积的影响，达到隔离的目的： $P= \\underset{1}{\\overset{2}{\\sum}}d_i \\cdot S_i$ 所以可以推导出 $d_1=\\frac{1}{m}\\cdot S_i \\cdot \\underset{1}{\\overset{2}{\\sum}}d_i \\cdot S_i = \\frac{(S_1)^2}{m} \\cdot d$。 可以看出和上面的表达式是相同的 区别： 报文交换用完整的报文 分组交换用较小的分组 所以哪种方式更好呢？分组交换：传输延迟 场景假设，源主机有两个分组信息需要发射，每个分组L bit大小 发送主机： 接受应用报文（消息） 拆分为较小长度为L bits的分组 在传输速率为R的链路上进行传输 报文交换 vs 分组交换报文交换： 报文长度为M bits 链路带宽为R bps 每次传输报文需要M/R秒 分组交换： 报文被拆分为多个组 分组长度为L bits 每个分组传输时延为L/R秒 举例： M = 7.5 Mbits L = 1500 bits M = 5000L R = 1.5 Mbps 如果使用报文交换的时候，路由器的缓存就至少需要一个报文的大小 分组交换中，原来的主机是要把报文进行拆分拆分成分组，5000个分组 12345678gantt title 报文交换 section 时间分布 dateFormat YYYY-MM-DD axisFormat %d empty:2023-1-1,9d M/R=7.5/1.5=5:2023-1-10,9d empty:2023-1-19,10d 主要都采用分组交换技术 分组交换的交付时间 报文：M bits 链路带宽：（数据传输速率）：R bits 分组长度（大小）：L bits； 跳步数量：h 路由器数量：n = h-1 $T_{传输时间}=M/R+(h-1)L/R=M/R+nL/R$ 跳步指的是从一点到下一个相邻一点就叫做跳步（一个跳步等于链路数量） M/R 是 整个报文的传输时间 L/R 是 一个路由器的转发时间 试题举例 在下图所示的采用“存储-转发”方式的分组交换网络中，所有链路的数据传输速率为100 M bps，分组大小为1 000 B，其中分组头大小为20 B。若主机H 1向主机H 2发送一个大小为980 000 B的文件，则在不考虑分组拆装时间和传播延迟的情况下，从H 1发送开始到H 2接收完为止，需要的时间至少是多少? 分组大小是1000 B，分组头占其中的20 B，所以有980 B携带的是报文数据； 至少是什么时间，指的是走最近的链路； 980 KB大小 的文件需要分1000个分组，每个分组1000 B。H 1发送整个文件需要的传输延迟为（980 000 + 20 * 1000 ）* 8 / 100 000 000 = 80 ms（注意单位换算）; 根据路由选择基本定理，所有数据分组应该经过两个路由器的转发，所以再加上最后一个分组的两次转发的传输延迟，也就是 2 * 1000 * 8 / 100 000 000 = 0.16 ms。 所以，H 2接受完整个文件至少需要80 + 0.16 = 80.16 ms 两次转发的延迟，因为是两个路由器，所以要加上。 例如：1 Mb/s 链路 每个用户： :heavy_check_mark: “活动” 时间需要100 Kb/s :heavy_check_mark: 每个用户的平均活动时间为10 % 电路交换：电路交换的特点是不能共享，虽然不传输数据但是其他用户是不能使用的，所以在这种情况下的效率很低。:togo:10个用户 分组交换：当一个用户活动的时候恰好赶上了另一个用户活动，可以将活动错开。:heavy_check_mark:对于35个用户，大于10个用户同时活动的概率&lt;0.0004 分组交换允许更多用户同时使用网络！——网络资源充分共享 分组交换绝对由于电路交换？ 适用于突发数据传输网络。 资源充分共享 简单、无需呼叫建立 $\\Rightarrow$ 可能产生拥塞：分组延迟和丢失 需要协议处理可靠数据传输和拥塞控制 现在使用的计算机网络具备突发的数据传输特点。 但是视频传输和通话的传输不具备突发性。 Q：如何提供电路级性能保障？打电话会出现停顿现象，所以需要使用协议来进行传输 上一页：[[CourseNotes/计算机网络/CN-No.2 计算机网络的结构]] 下一页: [[CourseNotes/计算机网络/CN-No.4 计算机网络性能]]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.3%20%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83/"},{"title":"CN-OSPF协议","text":"[[CN-NotesView]] OSPF“开放”：公众可用 采用链路状态路由算法 LS分组扩散（通告） 每个路由器构造完整的网络拓扑图 链路状态数据库 每个入口对应一个邻居 OSPF通告在整个AS范围内进行泛洪 OSPF报文直接封装到IP数据报中 和OSPF及其相似的一个路由协议：IS-IS路由协议 RIO不具备的优点 安全：所有OSPF报文可以被认证（恶意入侵） 允许使用多条相同费用的路径（RIP只能选一条） 对于每一条链路，可以针对不同的TOS设置多个不同费用度量 继承单播路由和多播路由： 多播OSPF协议和OSPF利用相同的网络拓扑数据 OSPF支持对大规模AS分层 分层的OSPF两级分层 局部区和主干区 链路状态通告只限于区内 每个路由器掌握所在区的详细拓扑 区边界路由器：汇总到达所在区的网络的距离，通告给其他区边界路由器 主干路由器：在主干区内运行 AS边界路由器：连接其他AS","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-OSPF%E5%8D%8F%E8%AE%AE/"},{"title":"CN-PPP协议","text":"[[CN-NotesView]] 点对点数据链路控制一个发送端，一个接收端，一条链路: 比广播链路容易 无需介质访问控制(Media Access Control) 无需明确的MAC寻址 e.g., 拨号链路,ISDN链路 HDLC： High Level Data Link Control PPP: (Point-to-Point Protocol) PPP设计需求组: 将网络层数据报封装到数据链路层帧中可以同时承载任何网络层协议分组(不仅IP数据报)可以向上层实现分用 (多路分解) 比特透明传输:数据域必须支持承载任何比特模式 差错检测:(无纠正) 网络层地址协商: 端结点可以学习/配置彼此网络地址 PPP无需支持的功能无需差错纠正/恢复无需流量控制不存在乱序交付无需支持多点链路 差错恢复、流量控制等由高层协议处理! PPP数据帧 标志(Flag): 定界符(delimiter) 地址(Address): 无效(仅仅是一个选项) 控制(Control): 无效; 未来可能的多种控制域 协议(Protocol): 上层协议 (eg, PPP-LCP,IP,IPCP, tc) 信息(info): 上层协议分组数据 校验(check): CRC校验，用于差错检测 字节填充(Byte Stuffing)”数据透明传输“ 需求：数据域必须包含标志模式&lt;011110&gt; Q:如何判断该作为数据接收，还是作为标志处理？ 发送端: 在数据中的&lt;01111110&gt;和&lt;01111101&gt;字节前添加额外的字节&lt;01111101&gt;(“填充(stuffs)”) 接收端:单个字节&lt;01111101&gt;表示一个填充字节:连续两个字节&lt;01111101&gt;: 丢弃第1个，第2个作为数据接收 PPP数据控制协议在交换网络层数据之前，PPP数据链路两端必须: 配置PPP链路 最大帧长度 身份认证 学习/配置网络层信息 对于IP协议: 通过交换IPCP协议(IP Control Protocol )报文(IP分组首部的“上层协议”字段取值: 8021)，完成IP地址等相关信息配置","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PPP%E5%8D%8F%E8%AE%AE/"},{"title":"CN-PUT","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[2023-09-17]] 将消息体中的文件上传到URL字段所指定的路径","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-PUT/"},{"title":"CN-RIP协议","text":"[[CN-NotesView]] Internet采用层次化路由 AS内部路由协议也成为内部网络协议：interior gateway protocols(IGP) 最常见的AS内部路由协议： 路由信息协议 routing information protocol RIP 开放最短路径优先 open shortest path first OSPF 内部网关路由协议 interior gateway routing protocol IGRP RIP早于1982年随BSD-UNIX操作系统发布 距离向量路由算法 距离度量：跳步数(max = 15 hops)，每条链路一个跳步 每30s，邻居之间交换一次DV，成为通告(advertisement) 每次通告：最多25目的子网(IP形式) 链路失效，恢复如果180s没有收到通告 $\\to$ 邻居/链路失效 经过这个邻居的路由都不可用了 重新计算路由 向邻居发送新的通告 邻居再一次向外发送通告(如果转发表改变) 链路是小信息能不能快速传播到全网？ 可能发生无穷计数问题 毒性逆转计数用于ping pong环路（无穷大距离为16hops） RIP路由表的处理RIP路由表是利用一个称作rout-d的应用等进程进行管理 应用进程实现 通告报文周期性的通过UDP数据报发送 层次划分是通过功能来划分的，无论是什么样的形式来完成","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-RIP%E5%8D%8F%E8%AE%AE/"},{"title":"CN-TCP-1","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] TCP概述TCP 概述点对点一个发送方一个接收方 可靠的、按照顺序的字节流流水线机制 TCP拥塞控制和流量控制机制设置窗口尺寸。 发送方/接收方缓存0全双工（full-duplex）同一链接中能够传输双向数据流 面向连接通信双方在发送数据之前必须建立连接 连接状态只在链接的两端中维护，在沿途节点中并不维护状态 TCP连接包括 两台主机上的缓存、连接状态变量、socket等 流量控制机制TCP段的结构 第一行：源端口号，目的端口号 段序列号和ACK的数据 U：URGENT 代表紧急数据A：ACK 代表是否有效P：PUSH DATA NOW 没有用处R：RSTS：SYNF：FINchecksum：代表校验和 序列号 序列号是segment中第一个字节的编号，而不是segment的编号 建立TCP的时候，双方随机选择序列号 ACKs: 希望接收到的下一个字节的序列号 累计确认，该序列号之前的所有字节都已经被正确收到 Q：接收方是怎么处理乱序到达的Segment? A: TCP 规范中没有规定，由TCP的实现者做出决策 有两台主机，两个之间进行远程登陆的功能 telnet 〽️ 之前已经建立了连接 当主机A用户输入一个C之后，会产生一个序列号的段。(Seq=42,ACK=79（期望收到的）,data=’C’) 返回来的段中的内容是Seq=79,ACK=43,data=’C’ 主机会再发送一个确认，Seq=43,ACK=80. TCP的可靠数据传输TCP在IP层里面提供的服务的不可靠服务基础上实现可靠数据传输服务 流水线机制 累计确认 TCP使用单一重传定时器 触发重传的时间 超时 收到重复的ACK TCP RTT和超时问题：怎么设置定时器的超时时间？ 可以使用RTT来作为一个标尺来定下TCP的超时时间 过短就会产生不必要的重传 如果过长就会对段丢失的时间反应比较慢 问题：怎么估计RTT？ SampleRTT：测量从段发出去到收到ACK 的时间 忽略重传 SampleRTT变化 测量多个SampleRTT，求平均值，形成RTT的估计值 使用指数加权移动平均的方法： EstimatedRTT = (1 - $\\alpha$) * EstimatedRTT + $\\alpha$ * SampleRTT 典型值就是0.125 定时器超时时间的设置 EstimatedRTT +”安全边界” EstimatedRTT变化大 $\\rightarrow$ 较大的边界 测量RTT值的变化：SampleRTT和EstimatedRTT的差值 DevRTT = (1-$\\beta$) * DevRTT + $\\beta$ * | SampRTT-EstimatedRTT | Typically, $\\beta$ = 0,25 定时器超时时间的设置 TimeoutInterval = EstimatedRTT + 4 * DevRTT TCP发送方的事件从应用层收到数据 创建Segment 序列号是Segment第一个字节的编号 开启计时器 设置超时时间：TimOutInterval 超时 重传引起超时的Segment 重启定时器 收到ACK如果确认此前未确认的Segment 更新SendBase 如果窗口中还有没有被确认的分组，重新启动定时器 TCP重传示例如上：此时返回的时候ACK发生丢失，主机发生Timeout事件，此时重新接受，同样会使用ACK100来进行回复 两个数据相近的发出，这个Timeout间隔设置的短了，所以就会发生重传，注意，此时重新传回来的数据应该是ACK120 如果没有收到100，但是收到了ACK120，同样是把SendBase来设置为120. TCP ACK的生成 ： RFC 1122,RFC 2581 Event at Receiver TCP Receiver action Arrival of in-order segment with expected seq # All data up to expected seq # already ACKed Delayed ACK.Wait up to 500ms for next segment. If no next segment send ACK Arrival of in-order segment with expected seq # One other segment has ACK pending Immediately send single cumulative ACK. ACKing both inorder segments Arrival of out-of-order segment higher-the expect seq # Gap detected Immediately send duplicate ACK,indicating seq # of next expected byte Arrival of segment that partitially of completely fills gap Immediately send ACK,provided that segment startset lower end of gap 快速重传机制TCP的实现中，如果发生超时，超时的事件间隔将重新设置，即将超时时间间隔加倍，导致很大。 重发丢失的分组之前要等待很长时间 通过重复ACK检测分组丢失 Sender 会背靠背的发送多个分组 如果某个分组丢失，可能会引起多个重复的ACK 入宫Sender收到对同一个数据的3个ACK，那么久假定数据之后的段已经丢失 快速重传：在定时器超时之前就进行重传！利用多个重复的ACK","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-1/"},{"title":"CN-No.5 计算机网络的体系结构","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 计算机网络的体系结构 计算机网络是一个非常复杂的系统 主机 路由器 各种链路 应用 协议 硬件、软件 …… 问题是否存在一种系统结构有效描述网络？利用什么样的结构？ …… 至少用于讨论网络？ A：分层结构 复杂系统的分层结构类比：航空旅行 每层完成一种（类）特定服务/功能 计算积网络的体系结构网络体系结构是从功能上描述计算机网络结构 计算机网络体系结构简称网络体系结构（network architecture）是分层结构 每层遵勖某个 / 某些网络协议完成本层功能 计算机网络体系结构是计算机网络的各层及其协议的集合 体系结构是一个网络功能层次及其关系的定义 体系结构是抽象的 为什么采用分层结构？结构清晰 有利于识别复杂系统不见及其关系 分层的参考模型(reference model) 模块化的分成易于系统更新维护 任何一层服务实现的改变对于其它系统其他层都是透明的。 例如，登机过程的改变并不影响航空系统的其他部分。 有利于标准化分层是否有不利之处？ 会导致效率不足 分层网络的基本概念![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 1-1692438417405-40.png) 实体 (entity) 表示任何可以发送或者接收信息的硬件或者软件进程 协议是控制两个对等实体进行通信的规则的集合，协议是水平的 。 任一层实体需要使用下层服务，遵循本层协议，实现本层功能，向上层提供服务，服务是垂直的。 下层协议的实现对上层的服务用户是透明的。 同系统的相邻层实体之间通过接口进行交互，通过服务访问点（SAP），交换原语，指定请求的特定服务。 ![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 2-1692438417406-44.png) OSI参考模型开放系统互连（OSI）参考模型 $\\rightarrow$ 分层网络体系结构模型（1984） 目的是支持 异构网络系统的互联互通。 异构网络系统互联的国际标准 理解网络通信的最佳学习工具（理论模型） ✅理论成功 市场失败 7层 （功能）， 每层完成特定的网络功能。 OSI参考模型的通信过程主机从应用层发出信息，通过七个层到达物理层，通过传输介质传输到路由器的物理层，通过遵循各层的协议，经过物理层 $\\rightarrow$ 数据链路层 $\\rightarrow$ 网络层 $\\rightarrow$ 数据链路层 $\\rightarrow$ 物理层的转换再进入传输介质，然后再通过七层进入下一个主机的应用层。 实线表示的是信息的物理传输 通过接口实现 虚线表示的是协议传输 和写信一样，无关传输过程，只看数据的交换 端-端层（end - end） ![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 3-1692438417406-42.png) OSI参考模型数据封装与通信过程用户数据从主机A出发 ![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 4-1692438417406-46.png) 为什么要进行数据封装？增加控制信息 构造协议单元（PDU） 控制信息主要包括 地址（Address）：表示发送端、接收端 差错检测编码（Error-detecting code）：用于差错检测或纠正 协议控制（Protocol control）:实现协议功能的附加信息，如：优先级（priority） 、服务质量(QoS)、安全控制等 物理层功能就是实现每一个bit的传输，具体的来讲： 接口特性 机械特性 、电气特性 、功能特性、规程特性 比特编码问题 数据率 比特同步 时钟同步,在发送设备和接受设备之间的信号同步 传输模式 单工（Simplex）也就是只能单向的通信 半双工（half-duplex）****对讲机 全双工（full-duplex） 数据链路层功能![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 5-1692438417406-48.png) 作为数据链路层解决的主要是节点到节点的数据传输 组帧（Framing）构成帧的主要目的是能够成功的切分出数据帧 物理寻址（Physical addressing） 在帧头中增加发送端和接收端的物理地址标识数据帧的发送端和接收端 ![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 6-1692438417406-50.png) 流量控制（Flow control） 避免淹没接收端 差错控制（Error control） 检测并重传损坏或丢失帧，并避免重复帧 访问(接入)控制（Access control） 在任一给定时刻决定那个设备具有链路（物理介质）控制使用权 网络层功能![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 7-1692438417406-52.png) 负责从源主机到目的主机数据分组（packet）交付 可能穿越多个网络 逻辑寻址（Logical addressing） 全局唯一逻辑地址，确保数据分组被送往目的主机，比如IP地址。 路由（Routing） 路径选择 互联网络并由路由分组☞目的主机 分组转发 ![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 8-1692438417406-54.png) 传输层的功能![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 9-1692438417406-56.png) 负责源-目的（端-端）（进程间）完整报文传输 分段和重组 SAP寻址 确保将完整的报文提交给正确进程比如端口号 ![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 10-1692438417406-58.png) 连接控制 流量控制 差错控制 会话层功能![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 11-1692438417406-60.png) 对话控制（dialog controling） 建立 维护 同步（synchronization） 最薄 的一层 表示层功能![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 12-1692438417406-62.png) 处理两个系统之间交换信息的语法和语义（syntax and semantics）问题 数据表示转化 转换为主机独立的编码 加密/解密 压缩/解压缩 应用层问题![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 13-1692438417406-64.png) 支持用户通过用户代理（如浏览器）或者网络接口使用网络（服务） 典型应用层服务： 文件传输（FTP） 电子邮件（SMTP） Web（HTTP） …… TCP/IP参考模型 ![*IP over Everything*](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 14-1692438417406-66.png) IP over Everything 五层参考模型![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 15-1692438417406-68.png) 综合OSI和TCP/IP的优点 大部分都是这样的参考模型 在功能上基本类似之前的7层 应用层：支持网络应用 传输层：进程-进程的数据传输 网络层：相邻网络元素（主机、交换机、路由器）的数据传输 物理层：比特传输 报文（message）的传播过程如下： ![Untitled](D:\\MarkdownNotes\\计算机网络\\assets\\Untitled 16-1692438417406-70.png) 💬可以看到交换机和路由器的本质区别是一个只有两层而一个是三层。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-No.5%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"title":"CN-TCP-2","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] TCP流量控制接收方为TCP连接分配buffer 蓝色表示空出来的可以接受数据的 上层应用可能处理buffer中数据的速度较慢就会导致buffer溢出，淹没接收方。 所以这就是buffer control 所以怎么做流量控制？ Buffer中的可用空间(spare room) = RcvWindow = RcvBuffer - (LastByteRcvd - LastByteRead) Reciever通过在Segment头部字段将RcvWindow告诉Sender Sender限制自己已经发送的但是还没有收到ACK的数据不超过接收方的空闲RcvWindow尺寸 Receiver告知Sender RcvWindow = 0 , 会出现什么情况？ [!TIP]会增加一个额外的处理，即使是Window = 0 ，仍然可以有很小一部分的数据可以进行传输 TCP的连接管理面向连接的连接协议 TCP sender &amp; reciever 会建立连接 初始化TCP变量 Seq #Buffer 和流量控制信息 Client : 连接的发起者 创建一个套接字Socket，将Socket设置主机名和端口号 Server : 等待客户连接请求 接受客户机发起的请求并建立连接 “三次握手机制” [!Step1]Client host send TCP SYN (标志段) segment to server specifies initial seq #（选择自己的序列号并告诉服务器） no data （不携带任何数据） [!Step2]Server host recieves SYN , replies with SYN &amp; ACK segment服务器接收到服务器的标志段，用标志段确认段来作为回复 server allocates buffers (为连接建立缓存) specifies server initial seq #(选择自己的初始的序列号并告知客户端) [!Step3]client receives SYNACK, replies with ACK segment, which may contain data.接收到标志段确认段，客户机发送ACK报文段同意连接 [!INFO]如果在三次握手的第二步服务器分配资源，最后一次握手如果没有发过来，服务端会保留连接，一段时间没有收到ACK才会关闭连接 关闭连接 Closing a connection: 12// client closes socketclientSocket.close(); [!Step1]client向server发送TCP发送TCP FIN控制segment [!Step2]server收到FIN，回复ACK，关闭连接，发送FIN [!Step3]client收到FIN，回复ACK。 进入等待 —— 如果收到FIN，就会重新发送ACK [!Step4]server收到ACK，连接关闭 1234graph TBA[&quot;Closed&quot;]--&gt;|client application initiates a TCP connection| B[&quot;SYN_SENT&quot;]B--&gt;|recieve SYN &amp; ACK send ACK| C[&quot;ESTABLISHED&quot;]C--&gt;|client application initiates close connection \\n Send FIN|D[&quot;FIN_WAIT_1&quot;]--&gt;|receive ACK send nothing|E[&quot;FIN_WAIT_2&quot;]--&gt;|recieve FIN send ACK| F[&quot;TIME_WAIT&quot;]--&gt;|30s|A 同理可以给出服务端的生命周期图","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-2/"},{"title":"CN-TCP-3","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 网络前十大问题之一：拥塞控制原理 拥塞控制 [!拥塞]非正式的定义：“太多的发送主机发送了太多的数据或者发送速度过快以至于网络无法处理” 表现： 分组丢失（因为路由器的缓存溢出） 分组延迟过大（在路由器缓存中排队） 拥塞控制 vs. 流量控制 A top-10 problem 拥塞控制的成因和代价假设两个senders： 两个recievers 一个路由器，无限缓存 [!无限缓存]说明不管主机发送的有多快，有多少数据，都可以从路由器传输到对应的位置，不会造成分组丢失 没有丢失的好处：没有重传 链路的带宽是C 所以可以看到左边这个图： [!吞吐率] 左边的图是关于吞吐率的达到C/2的时候就不会再增长了 [!时延]当$\\lambda_{in}$靠近C/2的时候，是时延爆炸式的增长 场景2 一个路由器，有限的buffers Sender重传分组 情况a: Sender 能够通过某种机制直到路由器的buffer信息，有空闲才会发 $\\lambda_{in} = \\lambda_{out}$ 情况b: 丢失了之后才会重发： $\\lambda^{‘}{in} \\ge \\lambda{out}$ 情况c: 分组丢失和定时器超时之后都重发，$\\lambda^{‘}_{in}$会变得更大 [!拥塞的代价]对给定的goodput，要做更多的工作（重传）造成资源的浪费 场景3四个发送方 多跳 超时/重传 拥塞的另一个代价：当分组被丢失的时候，任何用于该分组的“上游”传输能力全都被浪费掉 拥塞控制的方法端到端拥塞控制 网络层不需要显式的提供支持 端系统通过观察loss，delay等网络行为判断是否发生拥塞 TCP采取这种方法 网络辅助的拥塞控制 路由器向发送方显式的反馈网络拥塞信息 简单的拥塞只是(1bit):SNA,DECbit,TCP/IP ECN, ATM 指示发送方应该采取何种速率 ATM ABR 拥塞控制ABR “弹性服务” 如果发送路径underloaded 🗯️ 使用可用的带宽 如果发送方路径拥塞 速率降到最低保障速率 RM 发送方发送 交换机设置RM cell位（网络辅助） NI bit : rate不许增长 CI bit : 拥塞指示 RM cell由接收方返回给发送方 [!RM cell]显式的速率字段（SR）字段：两个字节 拥塞的交换机可以将ER设置位最低的值 发送方获知路径能支持的最小速率 [!Data cell]EFCI位：拥塞的交换机将其设置为1 如果RM cell前面的data cell的EFCI位被设置为1，那么发送方再返回的RM cell中设置CI位","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-3/"},{"title":"CN-TCP-ReadingComplement-2","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] TCP拥塞控制三个问题： TCP怎么知道发生了拥塞 TCP怎么能够实现端到端的限流 TCP在知道拥塞之后实现什么样的算法来控制拥塞","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement-2/"},{"title":"CN-Web缓存","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); ## Web缓存/代理服务器技术 功能 - 能够在不访问服务器的前提下满足客户端的HTTP请求 为什么要发明这种技术 缩短客户请求的响应时间减少机构/组织的流量在大范围内(Internet)实现有效的内容分发 Web缓存/代理服务器** 用户设定浏览器通过缓存进行Web访问 浏览器向缓存/代理服务器发送所有的HTTP请求 如果锁清秋的对象在缓存中给，缓存返回对象 否则，缓存服务器向原始服务器发送HTTP请求，获取对象，然后返回给客户端并保存该对象缓存既充当客户端，也充当服务器一般由ISP(Internet服务提供商架设) Web缓存示例假定： 对象的平均大小是1000，000 bit 机构网络中的浏览器平均每秒有15个到原始服务器的请求 从机构路由器到原始服务器的往返延迟=2s 网络性能分析：局域网（LAN）的利用率= (15个请求/s) * (1Mb/请求) / (100Mbps) = 15%然而接入链路上的流量强度为 1接入互联网的链路的利用率 = 100%总的延迟 = 互联网上的延迟 + 访问延迟 +局域网延迟 $延迟= 2s + n \\ min+ m \\ ms$ 由于局域网上的强度为0.15的通信量最多导致数毫秒的实验，我们可以忽略局域网的时延。 [[CourseNotes/计算机网络/CN-分组交换网络中的时延、丢包和吞吐量]] 由于链路上的时延因为利用率的原因会趋于无穷大，所系选哟改进事件响应特性 解决方案1将链路的速率提高，从15Mbps增加到100Mbps。这样可以将介入链路上的流量强度减少到0.15 缺点：代价很高 解决方案2安装Web缓存 假定缓存命中率是0.4 网络性能分析有40%的请求立即得到满足剩下的60%通过原始服务器满足 接入互联网的链路的利用率下降到 **60%**，从而其延迟可以忽略不计，例如10微秒 总的平均延迟：$互联网上的延迟+访问延迟+局域网延迟 = 0.6 \\times 2.01s +0.4 \\times n \\ ms &lt;1.4 s$ 内容分发网络（Content Distribution Network,CDN） 条件GET方法景观高速缓存能够减少用户感受到的响应时间，但是也引入了一个新的问题 数据一致性问题 HTTP协议有一种机制，允许缓存器确定它的对象是最新的。 条件Get方法（Conditional GET）如果： 请求报文使用的是GET方法 请求报文中包含一个if-Modified-Since的首部行 那么这个HTTP报文就是一个条件GET报文 条件GET方法的操作方式一个代理缓存我器代表一个请求浏览器 向某Web服务器发送一个请求报文： 12GET /fruit/kiwi.gif HTTP/1.1Bost: www.exotiquecuisine.com 其次，改web服务器像缓存器发送具有被请求对象的响应报文 1234567HTTP/1.1 200 CRDATA: Sat,8 Oct 2011 15:39:29Server : Apache/1.3.0 (Unix)Last-Modified :Wed, 7 Sep 2011 09:23:24Content-Type: image/gif(data ……) 该缓存器在将该对象转发到请求的浏览器的同时，也在本地缓存了这个对象。更重要的是缓存器在存储这个对象的时候也存储了最后的修改日期 一星期之后，另一个用户经过该缓存器上请求同一个对象 该对象仍然在这个缓存器里面，由于可能被修改，所以缓存器会发送一个条件GET执行最新检查 123GET /fruit/kiwi.gif HTTP/1.1Bost: www.exotiquecuisine.comIf-Midified-Since: Wed, 7 Sep 2011 09:23:24 值得注意的是If-Modified-Since刚好等于上个星期的Last-Modified值假设没有被修改，那么Web服务器向该缓存器发送一个响应报文： 12345HTTP/1.1 304 Not ModifiedDATA: Sat, 15 Oct 2011 15:39:29Server : Apache/1.3.0 (Unix)(EMPTY ENTITY BODY)","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Web%E7%BC%93%E5%AD%98/"},{"title":"CN-Week5-Class","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] [!QUEATION]TCP如何进行流量控制，可能存在什么问题？ 糊涂窗口综合症（ Sillly Window Syndrome ） 是发送方引起的 telnet 远程登陆，执行一种远程的终端，过程当中计算机只是作为终端来给远程的服务器交换数据。 Nagle算法：报文段一定长度之后再发送 TCP协议为什么要用三次握手建立连接？四次挥手断开连接？连接建立和断开的过程的序号怎么变化？ TCP协议使用三次握手建立连接的主要原因是为了确保双方能够正常通信并同步序号和确认号。三次握手的过程包括： 客户端发送一个SYN包到服务器，其中包含一个初始化的序号（ISN）。 服务器收到SYN包后，回复一个SYN-ACK包给客户端，确认连接请求，并为自己建立连接。 客户端收到SYN-ACK包后，再发送一个ACK包给服务器，确认收到服务器的确认，并建立连接。 四次挥手用于断开连接时，是因为在客户端请求断开时，服务器可能还有数据未发完，所以需要分开操作： 客户端发送一个FIN包到服务器，请求关闭连接。 服务器收到FIN包后，回复一个ACK包给客户端，表示同意对方关闭连接，但服务器可能还有数据需要发送。 服务器发送完未发送的数据后，发送一个FIN包给客户端，表示自己也请求关闭连接。 客户端收到FIN包后，回复一个ACK包给服务器，确认关闭连接。 在连接建立和断开的过程中，序号的变化如下： 连接建立时，客户端和服务器分别使用随机的初始序号（ISN）作为起始序号。 在数据传输过程中，序号根据发送和接收的数据包数量以及数据包的长度进行递增。 在连接断开时，通过发送和确认FIN包，最后一个的确认号（ACK）将成为下一个会话的初始序号。 来源：TCP三次握手，四次挥手的原理及过程 网络拥塞控制可以有哪些策略？ 网络拥塞控制可以采用以下策略： 慢开始：慢开始算法的思路是当主机开始发送数据时，先试探一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。来源 拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1。来源 快重传与快恢复：快重传（Fast Retransmit）是一种拥塞控制算法，能够快速恢复丢失的数据包。快恢复（Fast Recovery）算法用于在拥塞控制时快速恢复拥塞窗口的值。来源 拥塞检测与拥塞通知：拥塞检测与拥塞通知算法用于检测网络中的拥塞和通知相关主机降低数据发送速率。这可以通过网络设备或协议来实现。来源 请注意，以上策略不是所有的拥塞控制算法都会使用，具体的具体拥塞控制算法有不同的实现方式和策略。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week5-Class/"},{"title":"CN-TCP-ReadingComplement","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] TCP发送方必须处理的第三个主要事件：接受方确认的报文段的到达 当时间发生的时候将ACK y的值和变量SendBase相比较，如果y大于SendBase,也就是说ACK在确认先前没有被确认的报文段，所以更新SendBase为y。 A向B发送了序号为92的8字节数据，主机B向A返回ACK=100但是在过程中丢失，在超时之后将会进行重传，N再重新传回ACK=100 可以看出第一次超时两个ACK都没有收到，之后第二次超时重新发送了Seq=92,在第二个超时时间内收到ACK=120，这样第二个报文段就不会被重传 这就和第二种情况中一样，但是ACK在第一次的超时间隔内就就收到了，虽然ACK 100没有正确接收，但是ACK 120正确接收了，说明119之前的所有数据都正确接收了，也就不用重新传输第一段报文 超时间隔加倍 每当超时时间发生，重传具有序号最小的还没有被确认的报文段 将超时时间间隔设为先前值的两倍 超时间隔在每次重传之后会呈现指数型增长 提供了形式受限的拥塞控制 定时器过期很可能是由网络拥塞引起的 [!TIP] 太多的分组到达源和目的地之间路径上的一台（或者多台）路由器的队列中，造成分组丢失或者长时间的排队时延 拥塞的时候，如果源持续重传分组，会让拥塞 更加严重 快速重传超时周期因为每次的指数形式增长会让超市周期可能相对较长 增加了端到端的时延 注意到冗余ACK来检测丢包情况 [!TIP] 冗余ACK代表的是在其确认某个报文段的ACK 当接受方检测到了数据流中的一个间隔，这样就是报文段的丢失。 TCP不使用否定确认，所以接收方不能向发送方发送一个显示的否定确认（NAK），所以TCP对接收到的最后一个按序字符进行重复确认 如果一个报文段丢失，就很可能引起许多一个接一个的冗余ACK。如果TCP发送方接收到对相同数据的冗余ACK，可以当作一种指示，这个已经被确认过3次的报文段之后的报文段已经丢失。 一旦收到3个冗余ACK，TCP就执行快速重传 [! TIP] 在这个报文段的定时器过期之前重传丢失的报文段 代表ACK的收到的事件的伪代码 12345678910111213event : ACK RECEIVED, with ACK field value of y if(y &gt; SendBase){ SendBase = y if( ther are currently any not yet acknowledged segments) start timer } else { // 一个对确认过的重复的ACK进行发送了三次 increment number of duplicate ACKs received for y=3 // TCP fast retrasment resend segment with sequence number y } break 是回退N步还是选择重传TCP Sender 只维护 SendBase 和NextSeqNum，所以TCP看起来像是一个GBN风格的协议 但是和GBN有着显著的区别 [!TIP] TCP实现会将正确接收但是失序的报文段缓存起来。 发送报文段 1，2，3，…… N 假设分组n &lt; N确认报文丢失，但是其余的确认报文都分别在超时之前到达发送端。 如果是GBN，就会重传n+1，…… N的所有分组 但是TCP只会重传分组n，而且如果对报文段n+1的确认报文在报文段n超时之前到达，TCP都不重传报文n 选择确认 允许TCP的接收方有选择的确认失去顺序的报文段 所以当这个机制和选择重传机制结合起来使用的时候（也就是跳过那些已经被接受方确认过的报文段），TCP看起来就像是SR协议 [!INFO] 所以TCP的差错恢复机制就最好被分类为GBN协议和SR协议的混合体 流量控制流量控制因此是一个速度匹配服务，也就是发送方的发送速率和接收方的应用程序的读取速率相匹配。 Previous : TCP发送方也可能因为IP网络的拥塞而被遏制。 要区分流量控制和拥塞控制 接收窗口发送方维护接收窗口的变量来提供流量控制。 TCP是全双工通信，所以两端都要维护接收窗口 LastByteRead: 主机B上的应用进程从缓存读出的数据流的最后一个字节的编号 LastByteRcvd: 从网络中到达的并且已经放入主机B接收缓存中的数据流的最后一个字节的编号 所以接收的数据的大小是前编号减去最后一个编号也就是 Data = LastByteRcvd - LastByteRead 所以接收窗口大小就等于rwnd = RcvBuffer - Data 接收窗口大小是动态的，开机的时候rwnd = RcvBuffer A主机跟踪两个变量：LastByteSent &amp; LastByteAcked 两者之差就是A发送到连接中但是没有被确认的数据量。 TCP连接管理 就只用研究这一张图 发起TCP连接，发送SYN信号，接收到SYN 和ACK信号就建立连接 关闭TCP连接，发送FIN信号，进入FIN等待，接收到ACK确认信号，不发送，再等待FIN，再发送最后一次ACK，等待三十秒然后断开连接。 监听套接字Socket，进入监听状态；得到SYN信号就发送SYN和ACK，进入下一状态，接收到ACK之后不发送，建立好了连接 关闭连接的时候，接收到FIN之后就发送ACK，进入等待状态，再次发送FIN，接收到了ACK便不发送，关闭连接。 拥塞控制拥塞原因和代价 Situation 1 : 两个发送方和一台无穷大缓存的路由器 没有执行差错恢复，不用流量控制和拥塞控制 吞吐率的上线就是R/2，因为这是两条连接之间的共享链路容量造成的。 而且当发送的速率接近R/2的时候，平均排队分组的数量就会无限增长 [!拥塞网络的一种代价]分组的到达速率接近链路容量的时候，分组就会经历巨大的排队时延 Situation 2: 两个发送方和一台具有有限缓存的路由器 假如主机还是用$\\lambda_{in}$的速率发送数据，运输层向网络中发送报文段（含有初始数据或者重传数据）的速率用$\\lambda^{‘}_{in}$表示，这就被称为供给载荷 实现性能完全取决于重传的方式。 [!Graph a)] Assumption: A能够确定路由器是否空闲，空闲的时候才会发送分组，这样就不会丢包 $\\Rightarrow \\lambda_{in} = \\lambda^{‘}_{in}$ 这个时候的性能是理想的，也就是说每个分组都能够接收到，但是传输速率吧还是不能超过R/2。 [!Graph b)] More Real : 发送方仅在确定了一个分组已经丢失的时候才重传。 当供给载荷达到了R/2的时候，数据被交付的速率为R/3，所以说在0.5R的单位传输中，0.333R字节是初始数据，0.166R字节是重传数据 [!INFO]网络拥塞的另一种代价 发送方必须执行重传来步长因为缓存溢出而丢失的分组 [!Graph c)] 发送方会提前发生超时并重传已经被推迟还没有丢失的分组，也就是初始数据分组和重传分组都可能到达接收方。重传分组将被丢弃。 假定每个分组被转发两次，当供给载荷接近R/2的时候，吞吐量就渐进R/4 [!INFO]网络拥塞的另一种代价 发送方在遇到大时延的时候所进行的不必要的重传会引起路由器利用其链路带宽来转发不必要的分组副本。 Situation 3: 四台主机发送分组，通过交叠的两跳路径传输 采用超时重传机制实现可靠数据传输 所有路由器链路容量都是R字节/s A $\\to$ C的连接： Router R1&amp;R2 A-C &amp; D-B and A-C &amp; B-D 连接共享路由器R1，R2 如果吞吐量很小，路由器缓存的溢出很少见，所以较小的$\\lambda_{in}$会导致$\\lambda_{out}$的增大 当$\\lambda_{in}$很大的情况 Consider R2 到达路由器R2的最大速率就只能是R，当$\\lambda^{‘}_{in}$无穷大的时候，此时的A-C链路会因为B-D链路的供给载荷升高而导致吞吐量逐渐减少 $\\to 0$ 当有一个分组在第二条路由器上被丢弃的时候，第一条路由器所做的努力都白费了，也就是”劳而无功” [!INFO]拥塞的另一种代价 当一个分组沿一条路径被丢弃的时候，每个上游路由器用于转发该分组到丢弃该分组而是用的传输容量最终被浪费掉了。 拥塞控制方法端到端的拥塞控制 网络层没有为运输层拥塞控制提供显式支持 TCP报文段的丢失可以看作是网络拥塞的迹象，TCP会相应减少窗口长度 使用增加的往返时延值作为网络拥塞程度增加的指示 网络辅助的拥塞控制 网络层构件向发送方提供关于网络中拥塞状态的显式反馈信息。 ATM ABR拥塞控制形式，允许路由器显式的通知发送方，告知路由器能在输出链路上支持的传输速率。 XCP协议对每个源提供路由器计算的反馈，这个反馈携带在分组首部中 直接反馈信息 由网络路由器发给发送方 阻塞分组的形式 mainly “我拥塞了” 路由器标记字段 至少要经过一个完整的往返时间 ATM ABR 拥塞控制一种采用网络辅助方法解决拥塞控制的协议 Goal : 说明该协议为拥塞控制所采用的方法明显不同于英特网TCP协议的方法 需要理解的几个方面： ATM基本上采用一种面向虚电路（VC）的方法来处理分组交换 允许交换机跟踪各个发送方的行为（ex. 平均传输速率） 采取特定源的拥塞控制动作(交换机变得拥塞的时候，向发送方显式的发送信令减少速率) 这样的状态（逐VC）非常适合执行网络辅助拥塞控制 设计成一种弹性数据传输服务，该服务方式使人联想起TCP 轻载的时候会充分利用空闲的可用带宽；拥塞的时候会将传输速率抑制为min 资源管理信源（aka. 分组，RM） 主机和交换机之间传递和拥塞相关的信息。 RM到达目的地之后，会调转方向想发送方传送（Probably 已经被 Destination 修改） 交换机也能发送RM，并直接发送给源。 基于速率的方法。也就是发送方明确的计算处能发送的最大速率，并据此进行相应的调整。 [! EFCI bit] 显示转发拥塞指示比特 交换机把EFCI bit set为1，表示网络拥塞 Destination 检查收到的EFCIIbit是否有1，大多数为1 $\\to$ set RM = 1 将RM信源发送回给发送方 用EFCI &amp; RM中的CIbit，发送方就能在网络交换机拥塞的时候得到通知 [!CI &amp; NI bit] 拥塞指示比特（CI）&amp; 无增长比特（NI） 每32个数据单元有一个RM信元 交换机在轻微拥塞的时候将经过的RM中的NI set 1，严重的时候将CI set 1. 目的主机收到RM信元的时候将RM发回发送方，保持CI,NI不变 [!ER]每一个RM信元都会包含两个字节的显式速率（ER） 一个拥塞的交换机会降低经过的RM信元中ER字段中包含的值 以这样的方式就可以将ER字段设置为在源到目的地路径上所有交换机的最小可支持速率 一个ATM ABR 以返回的RM信元中的CI、NI和ER值为函数，来调整发送信元的速率。进行速率调整的规划非常复杂而且繁琐。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-TCP-ReadingComplement/"},{"title":"CN-Week8-Class","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 通过DHCP动态分配IP地址过程中需要交换哪些DHCP报文？这些报文直接封装到哪个协议的数据包中？封装这些报文的IP数据包的目的IP是什么？为什么？ 在DHCP动态分配IP地址过程中，需要交换以下几种DHCP报文： DHCP发现报文（DHCP Discover）：客户端发送此报文以发现可用的DHCP服务器。 DHCP提供报文（DHCP Offer）：DHCP服务器在收到DHCP发现报文后，向客户端发送此报文，提供可用的IP地址租约。 DHCP请求报文（DHCP Request）：客户端在收到DHCP提供报文后，向选定的DHCP服务器发送此报文，请求分配给自己的IP地址。 DHCP确认报文（DHCP Acknowledgement）：DHCP服务器在收到DHCP请求报文后，向客户端发送此报文，确认分配给客户端的IP地址租约。这些DHCP报文被封装在IP数据包中，使用的是UDP协议。UDP协议位于IP协议之上，为DHCP报文提供可靠的数据传输。封装这些DHCP报文的IP数据包的目的IP是广播地址（255.255.255.255），因为客户端在初始化阶段没有分配的IP地址，所以只能使用广播地址发送DHCP报文，以便DHCP服务器能够接收并回复。通过使用广播地址，确保DHCP服务器能够接收到相应的报文，进而进行IP地址的分配和交换。 一个路由器在转发IP分组的时候IP分组的哪些字段会发生修改？如何修改？ 在转发IP分组时，路由器会根据目标IP地址和路由表进行转发决策，并且可能会修改IP分组的一些字段。被修改的字段包括： TTL字段：TTL（Time to Live）字段表示IP分组在网络中能够经过的最大跳数，每经过一个路由器，TTL字段的值会减一。路由器在转发IP分组时，会将TTL减一，并重新计算校验和。 源IP地址字段：通常情况下，路由器不会修改源IP地址字段，它会保留原始的源IP地址。 目标IP地址字段：路由器会根据目标IP地址进行转发决策，并将目标IP地址字段更新为下一跳路由器的IP地址。 校验和字段：路由器在转发IP分组时，会重新计算校验和字段，以保证数据完整性。以上是常见的修改字段的情况，实际上，路由器在转发IP分组时可能还会修改其他字段，具体修改方式取决于路由器的配置和网络环境。 如果两个均使用私有IP地址的主机需要进行P2P通信？可能会遇到什么问题？怎么解决？ 如果两个均使用私有IP地址的主机需要进行P2P通信，可能会遇到以下问题： NAT（网络地址转换）阻止了直接的通信：私有IP地址不能在Internet上直接路由。当两个主机试图通过NAT网关进行通信时，通常会被NAT阻止。 防火墙阻塞了P2P连接：防火墙可能会屏蔽P2P连接，以保护网络的安全性。 为了解决这些问题，可以采取以下方法： 使用UPnP（通用即插即用）：通过启用UPnP功能，可以自动配置NAT设备，允许P2P通信。 使用端口映射：将P2P应用程序使用的端口映射到NAT设备上。这样，P2P通信的数据包就可以正确地路由到私有IP地址的主机。 使用中继服务器：如果两个主机无法直接通信，可以借助第三方中继服务器来中转通信。中继服务器将两个主机之间的数据包进行转发，使得通信得以建立。 穿越防火墙：使用一些特殊技术和协议，如STUN、TURN和ICE等，可以在防火墙后建立P2P连接，使得私有IP地址的主机能够直接通信。 请注意，每种方法的适用性和实施方式可能因网络环境和设备配置而异。具体的实施需要根据实际情况进行调整。 NAT穿透问题一定会有在外面有公网地址，在支持NAT的另一端，这时候需要转换。但是这是一个一对多的问题，因为私网IP是可以重复的，所以需要端口来辅助完成区别。静态配置：端口映射。 某校园网有两个局域网，通过路由器R1/R2/R3互联之后接入Internet,S1和S2为以太网交换机，局域网采用静态IP地址配置。 为了让H2和H3能够访问Web服务器，R2需要进行什么配置？ 可以利用ICMP协议实现哪些网络监测功能？怎么实现？ ICMP协议可以实现以下网络监测功能： Ping（网络连通性测试）：使用ICMP Echo请求消息来检测目标主机是否在线。Ping命令发送ICMP Echo请求消息到目标主机，目标主机接收到请求后返回ICMP Echo应答消息。 Traceroute（路径追踪）：通过使用ICMP的Time-to-Live（TTL）字段，从源主机向目标主机发送一系列的UDP数据包。每个数据包在传输过程中的路由器都会将TTL减少，直到它达到0并被丢弃。源主机通过检测收到的ICMP TTL超时消息来确定数据包传输路径。 ICMP Jitter（延迟测量）：利用ICMP消息的传输延迟来测量网络性能。通过发送ICMP Echo请求消息并记录请求发送和接收之间的时间差来获取延迟信息。 实现上述功能的方法如下： Ping：使用ping命令或编写程序发送ICMP Echo请求消息，并接收目标主机的ICMP Echo应答消息。 Traceroute：使用traceroute命令或编写程序发送一系列的UDP数据包，并监听接收到的ICMP TTL超时消息，记录路由路径。 ICMP Jitter：通过编写程序发送ICMP Echo请求消息，并记录请求发送和接收之间的时间差，计算延迟值。 参考来源： ICMP协议简介 ICMP协议的应用 距离向量路由算法可能产生什么问题，怎么会发生这样的问题？怎么消除这个问题？","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week8-Class/"},{"title":"CN-Week7-Class","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] Q1: 虚电路的VCID如何取值？在每段物理链路上都相同吗？为什么？ VCID的取值方式是由ATM网络设备或协议规范来定义的。通常，VCID的取值范围是0到65535，但具体取值范围可以根据设备和网络配置而有所不同。在同一段物理链路上，不同虚电路的VCID通常是不同的。这是因为VCID的主要作用是用来区分不同的虚电路，如果在同一物理链路上有多个虚电路，它们需要具有不同的VCID，以便网络设备能够正确地路由和交换数据。 Q2: IP分片在哪里重组？为什么？ IP分片是在网络层（第三层）上实现的。当一个IP数据报的大小超过了网络的最大传输单元（MTU）时，它会被分割成更小的片段，以适应网络的限制。每个分片都会被独立地发送到目标主机。IP分片是为了解决不同网络链路上的最大传输单元（MTU）不一致的问题。如果一个IP数据报的大小超过了链路上的MTU，它将被分割成更小的片段进行传输。这样可以确保数据能够通过链路传输，并且在目标主机上进行重组，还原为原始的数据报。 Q3: 请将192.168.1.0/24剩余IP地址分配给局域网13，其中局域网1需要IP地址数不少于60个，局域网2、3需要IP地址不少于30个。说明局域网13的子网地址、广播地址、子网掩码、可分配的IP地址数和范围。 Q4：","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week7-Class/"},{"title":"CN-Week9-Class","text":"[[CN-NotesView]] 以太网中采用二进制指数后推算法处理冲突问题。 链路层能够提供的可能服务有哪些？其中可靠传输服务，在传输层也同样提供，那么链路层的可靠传输服务是不是必要？传输层的可靠传输理论以及方法是否适用于链路层？ 链路层能够提供的可能服务包括以下几个方面： 提供透明可靠的数据传输服务：链路层向网络层提供了透明可靠的数据传输服务，确保数据能够从发送方传输到接收方。 差错检测和纠正：链路层通过使用差错检测和纠正方法，对传输过程中可能出现的错误进行检测和纠正，从而保证数据传输的可靠性。 帧同步和流量控制：链路层在数据传输过程中能够进行帧同步和流量控制，确保数据的顺序和速率统一。 传输层也可以提供可靠传输服务，但链路层的可靠传输服务并不是必要的。传输层的可靠传输服务更加高级和复杂，可以处理端到端的可靠传输问题。 传输层的可靠传输理论和方法并不一定适用于链路层。链路层的可靠传输服务更加专注于在链路层中处理数据传输的可靠性，与传输层的可靠传输服务有所不同。链路层使用的纠错方法和协议可能与传输层不同，具体取决于传输介质和网络需求。 为什么同时使用MAC地址和IP地址？为什么不止使用MAC地址或者只使用IP地址？ 如何实现差错控制(差错纠正策略)？可以采用哪些协议？ 差错控制是为了处理在数据传输过程中可能发生的差错，包括差错检测和差错纠正。可以采用以下策略实现差错控制： 差错检测：通过添加冗余信息来判断数据是否遭到损坏。 校验和：将数据划分为多个块，并计算每个块的和，将和值附加到数据中。 循环冗余检验 (CRC)：使用多项式除法来计算校验码，并将其附加到数据中。 差错纠正：不仅能检测出差错，还能进行纠正。 汉明码：通过在数据中添加冗余位来纠正错误，并检测出多位错误。 奇偶校验：通过添加一个奇偶位来检测和纠正单个比特错误。 差错控制可以应用于不同的协议和通信网络中，包括： TCP (传输控制协议)：在数据通信过程中通过使用序列号、确认应答和重传机制来实现差错控制。 UDP (用户数据报协议)：提供差错检测功能，但不支持差错纠正。 ARQ (自动重传请求)：一种协议，通过请求重传错误的数据包来实现差错控制。 来源： TCP、UDP与ARQ错误控制 差错控制的方法与技术 随机访问MAC怎么检测冲突？ 要检测随机访问MAC的冲突，可以采取以下方法： 使用MAC地址检测工具：可以使用专门的MAC地址检测工具来检测MAC冲突。这些工具可以扫描局域网上的设备，并检查是否有重复的MAC地址。一旦发现重复的MAC地址，就可以确定发生了冲突。 查看网络设备日志：路由器或交换机上的日志记录可能会显示有关MAC地址冲突的信息。通过查看日志，可以了解到是否发生了冲突以及冲突的具体信息。 使用网络分析工具：可以使用网络分析工具来监测网络流量和活动。这些工具可以检测到连续的MAC冲突，通过分析网络流量，可以确定冲突的设备和触发冲突的原因。 以上是一些常见的检测随机访问MAC冲突的方法，可以根据具体的需求和网络环境选择合适的方法进行检测。 总结两个轮转访问MAC协议，轮询和令牌传递的共同点和不同点，并设计一个轮转访问的MAC协议？ 轮询和令牌传递是两种常见的轮转访问MAC协议。它们的共同点是都采用了轮流访问的方式来协调多个设备之间的数据传输。然而，它们在实现细节和工作原理上有一些区别。 共同点： 轮询和令牌传递都是使用轮流访问的方式，按照特定的顺序依次控制设备的访问，使每个设备都能有机会传输数据。 两种协议都能避免设备之间的冲突和碰撞，提高网络的效率。 不同点： 轮询协议是由一个中心设备（通常是主机或主控器）负责控制访问顺序，按照预定的顺序对每个设备进行轮询。而令牌传递协议则是通过传递令牌的方式来控制设备的访问顺序，只有拥有令牌的设备才能传输数据。 在轮询协议中，当一个设备完成数据传输后，控制权会立即转移到下一个设备。而在令牌传递协议中，只有拥有令牌的设备才能传输数据，其他设备需要等待令牌传递到自己才能进行传输。 轮询协议可以更灵活地控制设备的访问顺序，可以根据设备的优先级或其他因素来调整轮询顺序。而令牌传递协议的访问顺序是固定的，由令牌的传递顺序决定。 设计一个轮转访问的MAC协议： 以下是一个简单的轮转访问的MAC协议设计示例： 定义一个主控设备，负责控制轮询顺序。 所有参与传输的设备按照预定顺序排列，每个设备分配一个唯一的标识符。 主控设备按照设备的顺序轮询，依次给每个设备分配传输时间窗口。 在每个时间窗口内，设备可以传输数据或请求传输数据。 设备根据自己的需求在分配的时间窗口内进行数据传输。 主控设备根据轮询顺序不断循环，确保每个设备都有机会传输数据。 如果有新设备接入或有设备离开，主控设备需要更新轮询顺序。 这个设计示例基于轮询的方式，通过主控设备控","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week9-Class/"},{"title":"CN-Week3-class","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] RDT数据是可能出错的，如何判断出错，所以需要校验机制；使用校验和机制。 RDT实际上是一种停等协议 GBN 出错全部重传 SR 选择重传 **** 如何理解传输层复用和分用？复用和分用只在传输层进行嘛？可能通过其他方式实现复用和分用嘛？ 传输层的复用和分用是指在传输层中将多个应用程序的数据流进行合并和拆分的过程。复用是指将多个应用程序的数据流合并在一起，使用传输层提供的协议或端口标识符将这些数据流区分开。分用是指将传输层接收到的数据流拆分成多个应用程序的数据流，并将其传递给相应的应用程序。 传输层复用和分用并不仅限于传输层，还可以通过其他方式实现复用和分用。例如，在应用层中可以使用多路复用技术将多个应用程序的数据流合并在一起，并在传输层使用单个传输层连接进行传输。同样，分用也可以在应用层或其他网络层进行，以将接收到的数据流分发给相应的应用程序或网络节点。 总结起来，传输层是最常见的实现复用和分用的层次，但复用和分用也可以在其他层次进行实现，以实现合并和拆分数据流的目的。 复用和分用FDM 收音机 如何理解滑动窗口协议？都会有哪些因素会影响窗口大小的确定？ 滑动窗口协议是一种用于在通信中进行流量控制和可靠数据传输的机制。它通过在发送方和接收方之间维护一个固定大小的窗口来实现流量控制。发送方将数据分割成适当大小的数据块，并通过网络发送给接收方。接收方使用确认应答来告知发送方已经成功接收数据。同时，接收方也会告知发送方当前可接收新数据的窗口大小。 影响窗口大小确定的因素包括： 网络的带宽和延迟：如果网络带宽较大或延迟较小，窗口大小可以设置得较大，以更高效地利用网络资源。 接收方的处理能力：如果接收方处理能力有限，窗口大小应适当减小以防止数据堆积。 发送方与接收方之间的网络状况：如果网络不稳定或丢包较多，窗口大小可能需要减小以降低丢包率并提高可靠性。 应用程序需求：根据应用程序的特点和需求，可能需要调整窗口大小来达到更好的性能和吞吐量。 因素 缓存 流量控制 拥塞控制 GBN发送窗口 时延带宽积 滑动窗口协议大小和序列号比特位数有什么关系？为什么？ 滑动窗口协议的窗口大小应该小于序列号比特位数的幂，这是为了避免发生溢出情况，确保序列号可以正确的循环使用。如果窗口大小大于序列号比特位数的幂，可能会导致序列号的重叠和混淆，从而引发错误。 来源：https://zhuanlan.zhihu.com/p/361966436 $W_s+W_r \\leq 2^n$ $W_s$和$W_r$分别代表的是发送窗口和接收窗口，n代表的是传输位数。 对于GBN协议 $W_s \\leq 2^n-1$ 如何极端停等协议的信道利用率？如何计算滑动窗口协议的信道利用率？怎么理解信道利用率？请给出表达式 极端停等协议的信道利用率可以通过以下表达式计算： 信道利用率 = 数据传输时间 / (数据传输时间 + 2 * 往返时间) 滑动窗口协议的信道利用率可以通过以下表达式计算： 信道利用率 = 数据传输时间 / (数据传输时间 + 窗口大小 * 往返时间) 信道利用率是指在一定时间内，实际传输的数据占总传输时间的比例。它是衡量通信系统中信道利用程度的指标。信道利用率越高，表示信道被更有效地利用。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-Week3-class/"},{"title":"CN-交换机","text":"[[CN-NotesView]] 链路层设备 存储-转发以太网帧 检验到达帧的目的MAC地址，选择性(selectively) 向一个或多个输出链路转发帧 利用CSMA/CD访问链路，发送帧 透明(transparent) 主机感知不到交换机的存在 即插即用(plug-and-play) 自学习(self-learning) 交换机无需配置 交换机：多端口之间同时传输主机利用独享(dedicated)链路直接连接交换机 交换机缓存帧 交换机在每段链路上利用CSMA/CD收发帧，但无冲突，且可以全双工 交换(switching):A-A’与B-B’的传输可以同时进行，没有冲突 交换机转发表：交换表Q: 交换机怎么知道A’可以通过接口4到达，而B’可以通过接口5到达? A: 每个交换机有一个交换表(switch table), 每个入口(entry): (主机的MAC地址，到达主机的接口,时间戳) 看起来很像路由表! Q: 交换表入口信息如何创建和维护的?类似于路由协议? 交换机：自学习交换机通过自学习，获知到达主机的接口信息 当收到顿时，交换机“学习”到发送顿的主机(通过顿的源MAC地址)，位于收到该顿的接口所连接的LAN网段 将发送主机MAC地址/接口信息记录到交换表中 交换机：帧过滤/转发当交换机收到帧: 记录帧的源MAC地址与输入链路接口 利用目的MAC地址检索交换表 if 在交换表中检索到与目的MAC地址匹配的入口(entry)then {if 目的主机位于收到帧的网段then 丢弃帧else 将帧转发到该入口指向的接口} else 泛洪(flood) 自学习和转发过程举例假设交换表初始的时候为空。 目的MAC地址A’，位置未知:泛洪 目的MAC地址A，位置已知:选择性转发 交换机互联交换机可以互联 层级结构 交换机可以互联 Q: 当A向G发送帧时，S1怎么知道通过S4转发?S4又怎么知道通过S3,转发? A：自学习!(工作过程与单一交换机情形相同!) Q: 请给出S,S,S,S的交换表，并说明帧的转发过程? 组织机构(Institutional)网络 称这个IP子网为广播域 交换机 vs 路由器两者均为存储-转发设备：路由器: 网络层设备(检测网络层分组首部)交换机: 链路层设备(检测链路层帧的首部) 二者均使用转发表:路由器: 利用路由算法(路由协议)计算(设置), 依据IP地址交换机: 利用自学习、泛洪构建转发表，依据MAC地址 网络设备对比 集线器 交换机 网桥 路由器 层次 1 2 3 4 流量 no yes yes yes 广播域隔离 no no no yes 即插即用 yes yes yes yes 优化路由 no no no yes 直通传输 yes yes yes no","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BA%A4%E6%8D%A2%E6%9C%BA/"},{"title":"","text":"[[CN-NotesView]] 12345678910111213141516171819202122graph TD A[Open File] --&gt; B{File Empty?} B -- No --&gt; C[Read Data from File] C --&gt; D{Window Not Full?} D -- Yes --&gt; E[Send Data] E --&gt; F{Data Sent Successfully?} F -- Yes --&gt; G[Start Timer] F -- No --&gt; H{Wait and Retry?} H -- Yes --&gt; D H -- No --&gt; J[Receive Acknowledgment] J -- Updated Window --&gt; K{End of File?} K -- Yes --&gt; L[Stop Sending] K -- No --&gt; D B -- Yes --&gt; L J -- Lost Acknowledgment --&gt; M{Resend Data} M -- Data Resent --&gt; F J -- Data Received --&gt; N[Write Data to File] N --&gt; O{Window Not Empty?} O -- Yes --&gt; P[Update Base] O -- No --&gt; Q{Continue Receiving?} Q -- Yes --&gt; J Q -- No --&gt; R[Stop Sending and Receiving]","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-lab2,3/"},{"title":"CN-以太网","text":"[[CN-NotesView]] ”统治地位“的有线LAN技术 造价低廉 应用最广泛的LAN技术 比令牌局域网和ATM等更简单、便宜 满足网络速率需求：10Mbps ~ 10Gbps 以太网：物理拓扑总线（bus）总线：上世纪90奶奶带中期之前流行 所有节点在同一个冲突域内（可能产生冲突） 星型（star）中心交换机 每个节点一个单独的冲突域（结点之间彼此不冲突） 以太网：不可靠无连接服务无连接：发送帧的网课和接收帧的网卡之间没有”握手“过程 不可靠：接收网课不向发送网卡进行确认 差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议（TCP），否则，发生数据丢失 以太网的MAC协议：采用二进制指数退避算法的CSMA/CD 以太网的CSMA/CD算法 NIC从网络层接收数据报，创建数据帧； 监听信道：如果NIC监听到信道空闲，就开始发送数据帧 NIC发送完整个帧，而没有检测到其他结点的数据发送，则NIC确认帧发送成功 如果NIC检测到其他结点传输数据，则中止发送并发送堵塞信号 (jamsignal) 中止发送后，NIC进入二进制指数退避: 第m次连续冲突之后： n = Max(m,10) NIC 从{}0，1，2，……，$2^n$-1}中随机的选择一个数K NIC等待K·512比特的传输延迟时间，再返回第2步 连续冲突次数越多，平均等待时间越长。 发送端 以太网的帧结构发送端网卡将IP数据报(或其他网络层协议分组)封装到以太网帧中： 前导码(Preamble)(8B)7个字节的10101010，第8字节为10101011用于发送端与接收端的时钟同步 目的MAC地址、源MAC地址(各6B)如果网卡的MAC地址与收到的倾的目的MAC地址匹配，或者顿的目的MAC地址为广播地址(FF-FF-FF-FF-FF-FF)，则网卡接收该帧，并将其封装的网络层分组交给相应的网络层协议。 类型(Type)(2B)指示中封装的是哪种高层协议的分组(如，IP数据报、Novell IPX数据报、AppleTalk数据报等) 数据(Data)(46-1500B): 指上层协议载荷R=10Mbps，RTTmax=512$\\mu s$，Lmin / R = RTTmaxin=512bits=64B，Datamin=Lmin-18=46B CRC(4B): 循环余校验码丢弃差错帧 802.3以太网标准：链路和物理层许多不同的以太网标准 相同的MAC协议和帧格式 不同速率: 2 Mbps,10 Mbps,100 Mbps，1 Gbps, 10 Gbps 不同物理介质: 光纤,线缆","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BB%A5%E5%A4%AA%E7%BD%91/"},{"title":"CN-传输层学习笔记","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 传输层介绍传输层位于应用层和网络层之间。在两个应用层之间提供进程到进程服务，一个进程在本地主机，另一个在远程主机，使用逻辑链接提供通信。 传输层服务传输层负责向应用层提供服务 进程到进程通信首要任务：进程到进程通信（process-to-process communicaiton） 进程：使用传输层服务的应用层实体（运行的程序） 主机到主机 vs 进程到进程： 网络层可以负责主机到主机的通信。网络层协议只把报文传递给目的计算机，但是这不是完整的传输。 报文要递交给正确的进程 $\\rightarrow$ 传输层接管的部分 寻址：端口号最常用的方式实现进程到进程通信：客户-服务器模式 两个进程有相同的名字: ex. (client)Daytime $\\iff$ (remote)Daytime 远程计算机可以运行多个服务器程序，就像许多本地计算机可以在同一时间运行一个或者多个客户应用程序一样。 通信：需要 本地主机、本地进程、远程主机、远程进程 Chapter 4 mention: 用IP地址来定义本地主机和远程主机 服务器进程必须用一个端口号定义自己。端口号 = 0~65535之间的16位整数 客户程序用端口号来定义自己，称为临时端口号。临时是因为客户的生命周期通常很短。临时端口号大于1023。 熟知端口号：全局端口号 每一个客户进程都知道相应服务器进程的数值端口号。 ICANN范围把端口号划分成为三种范围：熟知的、注册的、动态的（或者私有的） 熟知端口：端口号范围是1~1023，由ICANN分配和控制，这些事熟知的端口号 注册端口：端口号的范围是1024~49151。ICANN不分配也不控制，它们可以在ICANN注册以免重复。 动态端口：可以由任何进程使用，是临时或者私有端口号。 套接字地址 TCP协议簇中的传输层协议需要IP地址和端口号，它们各在一端建立一条连接。一个IP地址和一个端口号结合起来就称为套接字地址（socket address），客户套接字地址唯一定义了客户的进程，而服务器套接字地址唯一的定义了服务器进程。 一对套接字地址：客户套接字地址和服务器套接字地址。这四条信息是网络层分组头部和传输层分组头部的组成部分。 这四条信息是网络层分组头部和传输层分组头部的组成部分。第一个头部包含IP地址，第二个头部包含端口号。 封装和解封装将报文从一个进程发送到另一个进程，传输层协议负责封装报文。 传输层的分组称为用户数据报、段、分组 在一般讨论中，将传输层有效载荷称为分组。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E4%BC%A0%E8%BE%93%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"CN-分组交换网络中的时延、丢包和吞吐量","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 分组交换网络的时延最重要的是 节点处理时延，排队时延，传输时延，传播时延 这些时延加起来的总和就是 节点总时延 处理时延检查分组首部和决定该分组到向何处所需要的时间是处理时延的一部分。也包括其他因素，比如检查 比特级别的差错高速路由器的处理时延通常是微秒或者更低的数量级。 排队时延在队列中，分组在链路上等待传输的时候，它经受排队时延。 一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量 到达分组期待发现的返祖数量是到达该队列的流量的强度和性质的函数。实际的排队时延可以是毫秒到微妙量级 传输时延假定分组以先到先服务的方式传输——这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输之后，才能传输刚到到达的分组。 传播时延传播时延是信号通过的路程的长度，为$d/s$","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%97%B6%E5%BB%B6%E3%80%81%E4%B8%A2%E5%8C%85%E5%92%8C%E5%90%9E%E5%90%90%E9%87%8F/"},{"title":"CN-层次化路由","text":"[[CN-NotesView]] 将任意规模的网络抽象为一个图计算路由-过于理想化 表示所有的路由器 “扁平”网络 ——在实际的网络中不可行！ 网络规模：考虑6个亿的结点的网络 路由表几乎无法存储 路由计算过程的信息 链路状态分组，交换量巨大，会淹没链路 管理自治：每个网络的管理可能都期望自主控制其网内的路由。 互联网（internet）= 网络之网络 层次路由聚合路由器为每一个区域：自治系统AS(autonomous systems) 同一AS内的路由器运行相同的路由算法 自治系统内部路由协议 不同的额自治系统内的路由器可以运行不同的AS内部路由协议 网关路由器位于AS边缘 通过链路连接其他AS网关路由器 可以和其他的网关路由器之间交换信息 互联的AS一方面要通过自治系统来决定AS间的路由算法来共同配置 AS内部的路由算法设置AS内部目的网络路由入口(entries) AS内部路由算法和AS间的路由算法共同设置AS外部网络路由入口 自治系统内的路由任务假设AS1内部的某个路由器收到一个目的地址在AS1之外的数据报： 路由器应该将该数据包转发给哪个网关路由器呢？ AS1（其中一个自治系统）必须： 学习到哪些目的网络可以通过AS2到达，哪些可以通过AS3到达 将这些网络可达性信息传播给AS1内部路由器 自治系统间的路由任务！ 路由器1d的转发表设置 假设AS1学习到(通过AS间的路由协议)：子网X可以通过AS3（网关1C）到达，但是不呢个通过AS2到达 AS间路由协议向所有内部路由器传播可达性信息 路由器1d：利用AS内部路由信息，确定其到达1c的最小费用路径接口 在多个AS之间选择假设AS1通过AS间的路由协议学习到：子网X通过AS3和AS2均可以到达 为了配置转发表，路由器1d必须确定应该将去往子网X的数据包转发给哪个网关？ 这个任务也是由AS之间的路由协议完成！ 热土豆路由：将分组发送给最近的网关路由器 [!过程] 通过AS间的路由协议学习到：子网X可以通过多个网关到达 利用通过AS内路由协议获得的路悠悠喜喜确定到达每个网关的最小费用的费用 热土豆路由：选择最小费用路径的费用最小的网关 通过转发表，确定去往最小费用网关的接口/.在转发表中增加入口：（x,l）","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B1%82%E6%AC%A1%E5%8C%96%E8%B7%AF%E7%94%B1/"},{"title":"CN-差错编码","text":"[[CN-NotesView]] 差错检测：差错编码差错编码基本原理： $D \\to DR$ 其中R为差错检测和纠正bit（冗余bit） 如果是没有出错的就直接还原就好 但是即便判断出当前的R一致，也不能保证一定可靠 差错编码的检错能力差错编码可以分为检错码和纠错码 对于检错码，如果编码集的汉明距离$d_s = r+1$ 那么差错编码可以检测r位的差错。 例如，编码集{0000,0101,1010,1111}的汉明距离$d_s$=2，可以100%检测1比特差错 对于纠错码，如果编码集的汉明距离$d_s$=2r+1，则该差错编码可以纠正r位的差错 例如，编码集{000000,010101,101010,111111} 的汉明距离$d_s$=3可以纠正1比特差错，如100010纠正为101010。 奇偶校验码1bit校验位： 检测奇数位差错 编码的效率很高 二维奇偶校验 检测奇数位的差错：部分偶数位的差错 纠正同一行/列的奇数位错误 Internet校验和发送端:将数据（校验内容）划分为16位的二进制整数序列 求和 校验和 放入分组 接收端：和发送端相同的算法进行计算 计算得到checksum 循环冗余校验码检错能力更强大的校验编码 将数据bit，D，视为一个二进制数 选择一个r+1位的比特模式（生成bit模式） 目标：选择r位的CRCbit，R，满足 &lt;D,R&gt; 刚好可以被G整除 接收端检错：利用G除&lt;D,R&gt;,余式全为0，无错；否则，有错！ 可以检测所有突发长度小于r+1位差错 广泛应用于实际网络(以太网，802.11 WIFI，ATM) 期望： $D \\cdot 2^r \\ XOR = \\ nG$ 相当于如果利用G去去除$D \\cdot 2^r$，则余式即为R：","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%B7%AE%E9%94%99%E7%BC%96%E7%A0%81/"},{"title":"CN-应用层学习笔记","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 应用层 [[计算机网络]] 章节分段 C/S模式，P2P模式 讨论客户-服务器模式的概念以及这个模式是如何为英特网用户提供服务的 讨论客户-服务器模式的预定义和标准应用。（万维网、文件传输、电子邮件） 对等模式中的概念以及协议。以及协议的流行应用 给出在客户-服务器模式下怎么通过C语言编写两个程序创建一个新的应用 介绍可以把应用层的功能看作是两个应用层之间假设存在一个假想的直接连接，通过这个链接可以发送和接收报文。 因特网为全世界用户提供服务。层次结构使得因特网比其他网络更加灵活，在一层增加协议的时候要观察是不是使用了底层提供的服务；在一层删去协议的时候要关注上层是不是使用了该协议，并改写上一层的协议。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E5%BA%94%E7%94%A8%E5%B1%82%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"CN-数据报网络","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 数据报网络数据报网络和虚电路网络的最大区别就是有连接和无连接 网络层无连接 每个分组携带目的地址 路由器根据分组的目的地址转发分组 基于路由协议/算法构建转发表 检索转发表 每个分组独立选路 发送数据报 接收数据报 数据报转发表路由算法（协议）确定通过网络的端到端路径 转发表确定在本路由器如何转发分组 :question: 但是有一个问题:question: IP地址是一个32位的2进制的数，所以可能的IP地址有40多亿 针对地址范围 意味着之在一个地址范围内的数据报在一个输出链路上进行展示，将列表的地址进行了聚合 不同的IP地址通过不同的范围来确定不同的链路接口 在实际的网络中地址的划分其实并不完美 最长前缀匹配优先例如 目的地址范围 链路接口 11001000 00010111 00010### ######### 0 11001000 00010111 00011000 ######### 1 11001000 00010111 00011### ######### 2 其他 3 DA： 11001000 00010111 00010==110 10100001== 从哪个接口转发？==A : 0== 只有所有的入口都匹配不成功的时候才会进入默认路径 DA: 11001000 00010111 00011==000 10101010== 从哪个接口转发？ ==A ：1== 匹配前面的前缀越多，越长，描述的范围就越小，网络就越小；匹配前面的前缀越短，网络就越大。所以我们应该将数据报送到更具体的端口上。所以就应该选择1号接口进行转发。 称之为： 最长前缀匹配优先原则 [!最长前缀匹配优先原则] 在检索转发表的时候，优先选择和分组目的地址匹配前缀最长的入口(entry) 数据报网络 or VC网络Internet 数据报网络简化网络 复杂“边缘”计算机之间的数据交换 “弹性”服务，没有严格的时间需求 链路类型众多 特点性能各异 统一服务比较困难 ATM VC网络简化“边缘”，复杂网络电话网络演变而来 核心业务是实时对话： 严格的时间、可靠性需求 需要有保障的服务 “哑（dumb）”端系统（非智能） 电话机 传真机","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BD%91%E7%BB%9C/"},{"title":"CN-有类IP地址","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] IP子网 [[CourseNotes/计算机体系结构/CN-IP编址|CN-IP编址]] IP地址（Addresses)“有类”编址 A类地址： 0.0.0.0 ~ 127.255.255.255 B类地址：128.0.0.0 ~ 191.255.255.255.255 C类地址：192.0.0.0 ~ 233.255.255.255 定义C类地址前八位用于网络号，后面八位用于主机号 对于剩余的八分之一的地址空间进行最后一次的二分，D类地址不再确认网络号和主机号，用于特殊的目的： 用于标识一组主机，理论上可以在互联网中的所有地方。称为多播地址。 E类地址保留作为研究使用 特殊的IP地址 NetID HostID 作为IP分组源地址 作为IP分组目的地址 用途 全0 全0 可以 不可以 在本网范围内表示本机; 在路由表中用于表示默认路由相当于表示整个Internet网络 全0 特定值 不可以 可以 标识本网内某个特定的主机 全1 全1 不可以 可以 本网的广播地址（路由器不转发） 受限网络地址 特定值 全0 不可以 可以 网络地址，表示一个网络 特定值 全1 不可以 可以 直接广播地址，对特定网络上的所有主机进行广播 127 非全0或者非全1的任何数 可以 可以 用于本地软件环回测试 私有（pivate）IP地址只用于私有网络，在公共网络上这种地址是无效的 Class NetIDs Blocks A 10 1 B 172.16 to 172.31 16 C 192.168.0 to 192.168.255 256 这部分的私有地址使得IPv4的网络还能正常运行","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%9C%89%E7%B1%BBIP%E5%9C%B0%E5%9D%80/"},{"title":"CN-数据链路层服务","text":"[[CN-NotesView]] 概述术语： 主机和路由器：结点（nodes） 连接相邻结点的通信信道：链路(links) 有线链路(wired links) 无线链路(wireless links) 局域网(LANs) 链路层(第2层)数据分组：帧(frame),封装网络层数据报 数据链路层负责实现通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传输数据报 链路层服务组帧(framing) 封装数据报文构成数据帧，加上首部和尾部 帧同步 在数据帧的首位加上特殊的字符 链路接入(link access) 如果是共享介质，需要解决信道接入(channel access) 帧首部中的”MAC”地址，用于标识帧的源和目的 不同于IP地址！ 相邻结点之间可靠交付 无线链路: 误码率高，需要可靠交付","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%9C%8D%E5%8A%A1/"},{"title":"CN-网络层例题讲解","text":"[[CN-NotesView]] 某网络拓扑如下图所示，路由器R1通过接口E1、E2分别连接局域网1、局域网2，通过接口LO连接路由器R2，并通过路由器R2连接域名服务器与互联网。R1的LO接口的IP地址是202.118.2.1;R2的LO接口的IP地址是202.118.2.2，L1接口的IP地址是130.11.120.1，EO接口的IP地址是202.118.3.1;域名服务器的IP地址是202.118.3.2。 R1和R2的路由表结构为： (1)将IP地址空间202.118.1.0/24划分为2个子网，分别分配给局域网1、局域网2，每个局域网需分配的IP地址数不少于120个。请给出子网划分结果，说明理由或给出必要的计算过程 可以看出是标准的C网，202.118.1.0 ~ 202.118.1.254划分结果为：子网1：202.118.1.0，子网掩码为255.255.255.128（202.118.1.0/25）子网2：202.118.1.128，子网掩码为255.255.255.128（202.118.1.128/25） (2)请给出R1的路由表，使其明确包括到局域网1的路由、局域网2的路由、域名服务器的主机路由和互联网的路由。 目的网络IP地址 子网掩码 下一跳IP地址 接口 202.118.1.0 255.255.255.128 - E1 202.118.1.128 255.255.255.128 - E2 202.118.3.2 255.255.255.255 202.118.2.2 L0 0.0.0.0 0.0.0.0 202.118.2.2 L0 (3)请采用路由聚合技术，给出R2到局域网1和局域网2的路由。 目的IP地址 子网掩码 下一跳IP地址 L0 202.118.1.0 255.255.255.0 202.118.2.1 L0","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E4%BE%8B%E9%A2%98%E8%AE%B2%E8%A7%A3/"},{"title":"CN-网络应用层概述","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 网络应用层概述 本讲内容网络应用的体系结构 客户机和服务器 P2P 混合结构 application transport network link physical 网络应用的服务需求 可靠性 带宽 时延 Internet传输层服务模型 TCP UDP 特定协议网络模型 HTTP SMTP POP IMAP DNS P2P应用 Socket编程 TCP UDP","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%B1%82%E6%A6%82%E8%BF%B0/"},{"title":"CN-网络层服务","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 网络层从发送主机像接受主机传送数据段 发送主机： 将数据段封装到数据报中 接收主机：向传输层交付数据段 每个主机和路由器都运行网络层协议 路由器检验所有穿越它的IP数据报的头部域 网络层的核心功能 —— 转发和路由路由器怎么把数据包转发到数据端口上最终送到目的地？ [!转发（forwarding）]将分组从路由器的输入端口转移到合适的输出端口 转发表： 转发表确定在本路由器如何转发分组 每一个地址来对应一个输出链路，通过转发表来进行寻找路线。 必须事先建立起转发表，才能进行传输数据。 [!路由(routing)]确定分组从源到目的经过的路径 路由算法 （routing algorithms） 确定通过网络的端到端路径 网络层核心功能 —— 连接建立某些网络的重要功能： ATM 帧中继 X.25 数据分组传输之前两端主机需要首先建立虚拟/逻辑连接 网络设备（如路由器）参与连接的建立 网络层连接和传输层连接的对比 网络层连接：两个主机之间（路径上的路由器等网络设备参与其中） 传输层连接：两个应用进程之间（对中间网络设备透明） 网络层服务模型Q： 网络层为发送端到接收端的数据包传送通道( channel )提供什么样的服务模型(service model)？ Internet 网络层中提供的模型 Best effort model 尽力服务 作为网络层，不需要进行拥塞控制或者拥塞信息的处理 通过是否发生数据丢失来确定是否发生了数据的拥塞 ATM 网络 : CBR constant rate 固定比特率 所以带宽是保障的，不会出现拥塞。 VBR guaranteed rate 再拥塞的时候只能提供最低的传输数据带宽 ABR 无连接服务 (connection-less service) 不事先为系列分组的传输确定传输路径 每个分组独立确定传输路径（根据网络状况来动态的选择） 不同的分组可能传输路径不相同 所以发到的数据顺序可能是不一样的 数据报网络(datagram network) 连接服务(connection service) 首先 为系列分组传输确定从源到目的的经过的路径(建立连接) 然后沿该路径(连接)传输系列分组 系列分组传输路径相同 传输结束之后拆除连接 虚电路网络(virtual-sircuit network)","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%8D%E5%8A%A1/"},{"title":"CN-网络应用进程通信","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[2023-09-17]] # 网络应用进程通信 进程 主机上运行的程序 同一主机上运行的进程之间如何进行通信 进程间的**通讯机制** 操作系统来提供 不同主机上运行的进程之间如何通信 消息交换 客户机进程：发起通信的进程 服务器进程：等待通信请求的进程 套接字：Socket进程之间通信利用Socket发送和接受消息实现 类似于寄信 发送方将消息送到门外的邮箱 发送方以来（门外的）传输基础设施将消息传输到接收方所在的主机，并且送到接受方的门外 接收方从门外获取消息 传输基础设施向进程提供API 传输协议的选择 参数的设置 很自然的问题，底层的设施怎么就能正确无误的接收到传输到的进程呢？ 如何寻址进程不同主机上的进程之间通信，那么每个进程都必须拥有标识符如何寻址主机？——IP地址 Q：主机有了IP地址之后，是否**足以 定位进程？** A：不是，同一个主机可能同时有多个进程需要通信 端口号/Port Number 是主机上每个需要通信的进程都分配一个端口号 HTTP Server：80 Mail Server：25 进程的标识符 IP地址+端口号 应用层的协议网络应用都应该需要遵循应用层协议公开协议 由RFC（Request For Comments）定义 允许互相操作 HTTP，SMTP，…… 私有协议 多数P2P文件共享应用 应用层协议的内容消息的类型（type） 请求消息 响应消息 消息的语法（syntax）格式 消息中由哪些字段 每个字段如何描述 字段的语义（semantics） 字段中信息的含义 规则 进程应该何时、如何发送消息","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"},{"title":"CN-网络应用的体系结构","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 网络应用的体系结构 你使用过哪些网络应用？百度 QQ alipay weixin …… 网络应用有哪些特点呢？🤔和单机应用有什么不同？ 🤔网络应用应该有什么样的结构呢？ 网络应用的体系结构**客户机、服务器**结构（Client-Server,C） **点对点**结构（Peer-to-peer,P2P） **混合**结构 客户机/服务器结构客户机： 和服务器通信 间歇性接入网络 可能有动态的IP地址 不会和其他的客户机通信 服务器： 需要不断提供服务 永久性的访问地址 利用大量服务器实现可扩展性 例子 纯P2P结构基本上看不出来明显的服务器和客户机的差别了 🪶 **特点** 没有永远在线的服务器 任意端或者节点之间都可以直接通讯 节点间歇性的接入网络 节点可能改变IP地址 优点 高度可伸缩的 缺点 难以管理 混合结构🤔能否将两种结构混合在一起呢？并能够结合两者的优点？ 可以避免服务器的资源过度使用 Napster应用 文件传输使用P2P结构 文件的搜索采用C/S结构——**集中式** 每个节点向中央服务器登记自己的内容 每个节点向中央服务器提交查询要求，查找感兴趣的内容 思考题每种网络体系结构找出5种以上的网络应用 从多个方面/角度对比三种体系结构的优缺点","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"title":"CN-虚电路网络","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 连接服务和无连接服务数据报网络和虚电路网络是典型两类 分组交换网络 数据报网络提供网络层无连接服务 虚电路网络日工网络层的连接服务 类似于传输层的无连接服务(UDP)和面向连接服务(TCP)，但是网络层服务： 主机到主机服务(而前者是端到端的连接) 网络核心实现 虚电路(Virtual circuits) VC虚电路：一条从源主机到目的主机， 类似于电路的路径(逻辑链接) 分组交换 （和电路交换的建立的电路网络不相同） 每个分组的传输利用链路的全部带宽 源到目的路径经过的网络层设备共同完成虚电路的功能 通信过程： 呼叫建立（call setup） $\\to$ 数据传输 $\\to$ 拆除呼叫 VCID 每个分组携带虚电路标识VCID, 而不是目的主机地址 虚电路经过的每个网络设备(如路由器)，维护 每条 经过它的虚电路连接状态 链路、网络设备资源（如带宽、缓存等）可以面向VC进行预分配 预分配资源 = 可预期服务性能 如ATM 的电路仿真 VC的具体实现每条虚电路包括 源主机到目的主机的一条路径 虚电路号（VCID），沿路每段链路的一个编号，有多少的链路就表现出网络的性能 沿路每个网络层设备（路由器等），利用转发表记录经过的每条虚电路 沿某条虚电路传输的分组，携带对应虚电路的VCID，而不是目的地址 同一条VC，在每段链路上的VCID通常不同 路由器转发分组的时候根据转发表改写/替换虚电路号 VC转发表每一个网络设备都要参与记录转发表 路由器R1的VC转发表 输入接口 输入VC # 输出接口 输出VC # 1 12 3 22 2 63 1 18 …… …… …… …… VC路径上每个路由器都需要维护VC连接的状态信息 虚电路信令协议（signal protocols）用于VC的建立维护和拆除 路径选择 应用于虚电路网络 如ATM、帧中继网络等 目前的Internet不再采用 初始呼叫(通过路由) 呼叫到达 虚电路俩连接之后，就开始下一段的行动，进行连接的建立和数据的传输 接收呼叫 呼叫建立 数据流开始 接收数据","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E7%94%B5%E8%B7%AF%E7%BD%91%E7%BB%9C/"},{"title":"CN-虚拟局域网","text":"[[CN-NotesView]] VLANs：动机 考虑一下情形:CS用户迁移到EE，但是希望连接至CS交换机，怎么办? 单一广播域: 所有第2层广播流量(ARPDHCP,未知目的MAC地址位置)必须穿越整个LAN 安全/隐私，效率问题 虚拟局域网(VirtualLocal Area Network)支持VLAN划分的交换机，可以在一个物理LAN架构上配置定义多个VLAN 基于端口的VLAN: 分组交换机端口(通过交换机管理软件)，于是，单一的物理交换机 ….. 流量隔离(traffic isolation):去往/来自端口1-8的倾只到达端口1-8 也可以基于MAC地址定义VLAN,而不是交换端口 动态成员: 端口可以动态分配给不同VLAN 在VLAN间转发: 通过路由(就像在独立的交换机之间) 实践中，厂家会将交换机与路由器集成在一起 跨越多交换机的VLAN多线缆连接 每个线缆连接一个VLAN 中继端口(trunk port): 在跨越多个物理交换机定义的VLAN承载帧 为多VLAN转发802.1顿容易产生歧义(必须携带VLAN ID信息) 802.1q协议为经过中继端口转发的顿增加/去除额外的首部域 802.1Q VLAN帧格式","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91/"},{"title":"CN-计算机网络传输层-2","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] TCP可靠数据传输原理 -&gt; TCP TCP连接TCP是面向连接的，这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，两个进程必须先相互握手。 连接的双方都将初始化和TCP连接相关的许多TCP状态变量 全双工服务（full-duplex service） 点对点(point-to-point)","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82-2/"},{"title":"CN-计算机网络传输层","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); # 计算机网络传输层 传输层服务概述传输层服务和协议传输层协议为运行在不同的host上的进程提供了一种逻辑通信机制 端系统运行传输层协议 发送方：将应用递交的消息分成一个或者多个的Segment,并向下传递给网络层 接收方：将接收到的Segment组装成消息，并上交给应用层 传输层可以为应用提供多种协议 Internet上的TCP Internet上的UDP 传输层 vs 网络层网络层： 提供主机之间的逻辑通信机制 传输层：提供应用进程之间的逻辑通信机制 位于网络层之上 依赖于网络服务 对网络层服务进行（可能的）增强 家庭类比 12个孩子给12个孩子写信 应用进程 = 孩子 应用消息 = 信封里面的信 主机 = 房子 传输层协议 = 李雷和韩梅梅 网络层协议 = 邮政服务 Internet传输层协议 可靠、按序的交付服务(TCP) 拥塞控制 流量控制 连接建立 不可靠的交付服务(UDP) 基于 “尽力而为(Best-effort)” 的网路，没有做可靠性方面的拓展 两种服务均不保证 延迟 带宽 多路复用和多路分用Why? $\\rightarrow$ 如果某层的一个协议对应直接上层的多个协议/实体，那么就需要复用/分用 接收端进行多路分用 传输层依据头部信息将收到的Segment交给正确的Socket，即不同的进程 发送端进行多路复用 从多个Socket接受数据，为每块数据封装上头部信息，交给网络层 分用如何工作 主机接收到IP数据报（datagram） 每个数据报携带源IP地址、目的IP地址 每个数据报携带一个传输层的端（Segment） 每个段携带源端口号和目的端口号 主机收到Segment之后，传输层协议提取IP地址和端口号信息，将Segment导向相应的Socket 无连接分用 利用端口号创建Socket [completion:: 2023-09-26] 12DatagramSocket mySocket1 = new DatagramSocket(99111);DatagramSocket mySocket2 = new DatagramSocket(99222); UDP的Socket用二元组标识 UDP的Socket用二元组标识 主机收到UDP段之后 检查段中的目的端口号 将UDP段导向绑定在该端口号的Socket 来自不同源IP地址和/或源端口号的IP数据包被导向同一个Socket 1DatagramSocket serverSocket = new DatagramSocket(6428); SP提供返回地址 面向连接的分用 TCP的Socket用四元组标识 - 源IP地址 - 源端口号 - 目的IP地址 - 目的端口号 接收端利用所有的四个值将Segment导向合适的Socket 服务器可能同时支持多个TCPSocket - 每个人Socket用自己的四元组标识 Web服务器为每个客户端开不同的Socket UDPUDP :User Datagram Protocol [RFC 768] 基于Internet IP协议 复用/分用 简单的错误校验 “Best effort”服务，UDP段可能 丢失 非按序到达 无连接 UDP发送方和接收方之间不需要握手 每个UDP段的处理独立于其他段 常用于流媒体应用 容忍丢失 速率敏感 UDP还用于 DNS SNMP 在UDP上实现可靠数据传输 在应用层增加可靠性机制 应用特定的错误恢复机制 UDP检验和(Checksum)目的:检测UDP段是否发生错误,比如位翻转 发送方 将段的内容视为16-bit整数 检验和计算:计算所有整数的和,进位加在和的后面,将得到得知安慰囚犯,得到校验和 发送方将校验和放入校验和字段 接收方 计算所受到段的校验和 将其与校验和字段进行对比 不相等:检测出错误 相等:没有检测出错误 校验和计算实例注意: 最高位必须被加进去 示例: 可靠数据传输原理❓什么是可靠 - 不错,不乱,不丢 可靠数据传输协议 可靠数据传输对应用层/传输层/链路层都很重要 网络的Top10问题 信道的不可靠特性决定了可靠数据传输协议(rdt)的复杂性 可靠数据传输协议基本结构:接口 可靠数据传输协议 渐进的设计可靠数据传输协议的发送方和接收方 只考虑单项数据传输 但是控制信息双向流动 利用状态机(Fnite State Machine,FSM)刻画传输协议 Rdt1.0:可靠信道上的可靠数据传输 底层信道完全可靠 不会发生错误(bit error) 不会丢弃分组发送方和接收方的FSM独立 Rdt 2.0Rdt 2.0: 产生位错误的信道底层信道可能反转分组中的位 利用校验和检测为错误 如何从错误中回复？ **确认机制(Acknowledgements,ACK):**接收方显式的告知发送方分组已经正确接收 NAK：接收方显式的告知发送方的分组有错误 发送方收到NAK之后，重发分组 基于这种重传机制的rdt协议称为ARQ(Automatic Repeat reQuest) 协议 Rdt 2.0中引入的新机制 差错检测(校验和的方式) 接收方反馈控制信息：ACK/NAK 重传 Rdt 2.0:FSM规约 Rdt 2.1 和 2.2对Rst 2.0的改进，先要知道Rdt 2.0有什么缺陷？ 如果ACK和NAK消息发生错误了怎么办？ Solution 1:为NAK和NCK增加校验和，检错并纠错 Solution 2:发送方收到被破坏的ACK/NAK的时候不知道接收方发生了什么，添加额外的控制消息 Solution 3:如果ACK/NAK坏掉，就重传。但是不能简单的重传，因为会产生重复分组。 怎么解决重复分组问题？ 序列号(Sequance number):发送方给每个分组增加序列号 接收方丢弃重复分组 stop and wait: Sender sends one packet, then waits for reciever response. Rdt 2.1 vs Rdt 2.0发送方为每个分组增加了序列号 两个序号（0，1）就够用，为什么？ 需要检验ACK/NAK消息是否发生错误 状态数量翻倍 状态必须记住当前的分组序列号 接收方需要判断分组是不是重复 当前所处的状态提供了期望收到分组的序列号 注意：接收方无法知道ACK/NAK是否被正确接收到 Rdt 2.2: 无NAK消息协议我们真的需要两种确认消息(ACK+NAK)? 和rdt2.1 的功能相同，但是只使用NAK 🧐怎么实现？ 接收方通过ACK告知最后一个被正确接收的分组 在ACK消息中显式的加入被确认分组的序列号 发送方收到重复的ACK之后，采取与收到NAK消息相同的动作 重传当前的分组 Rdt 2.2 FSM片段 Rdt 3.0如果信道极可能发生错误，也可能丢失分组，怎么办 “校验和+序列号+ACK+重传”够用吗？ 方法：发送方等待”合理“时间 如果timeout，有没有收到ACK就可以采取动作了 $\\rightarrow$ 重传 ☹但是时间是很难设定的，如果只是延迟了，就会引起重复的问题 但是序列号能够处理 接收方需要在ACK中显式的告知所确认的分组 需要定时器 Rdt 3.0 发送方FSM Rdt 3.0 运行实例 ⬆ 发送方和接收方在传输过程中没有丢包的存在 ⬆ 在发送过程当中发生丢失的情况，执行停-等协议，造成超时，所以重新传输分组 ⬆ 标识收到了两个分组（相同序列号），那就丢掉一个然后进行传输ACK ⬆ 标识两次都发送了，表明第一次正确接收了，但是返回ACK的过程当中触发执行停等协议然后重新发送了一次。收到了ACK1之后会传换成发送pkt0，第二次发的ACK1到达的时候正好有了ACK0。称之为计时器时间过短、timeout早熟 Rdt 3.0 性能分析Rdt 3.0能够正常工作，但是性能很差 示例：1Gbps链路，15ms端到端传输延迟，1kB分组 $T_{transmit}=\\frac{L(packet \\ length \\ in \\ bits)}{R(transmission \\ rate, \\ bps)}=\\frac{8kb/pkt}{10^9b/sec}=8 ms$ 发送方的利用率：发送方发送时间百分比 $U_{sender}=\\frac{L/R}{RTT+L/R}=0.008/30.008=0.00027$ 在1Gbps链路上每30毫秒才能发送一个分组 $\\Rightarrow$ 33KB/s 网络协议限制了物理资源的利用 $U_{sender}=\\frac{L/R}{RTT+L/R}=0.008/30.008=0.00027$ 流水线的机制和滑动窗口协议 回顾最初的Rdt 3.0操作 可以更改为同时发多个分组，这样就能有更好的性能 $U_{sender}=\\frac{3*L/R}{RTT+L/R}=\\frac{0.024}{30.008}= 0.0008$ 允许发送方在收到ACK之前连续发送多个分组 更大的序列号范围 发送方和/或接收方需要更大的存储空间以缓存分组 很明显可以看出效率有明显提高 滑动窗口协议滑动窗口协议：Sliding-window protocol 窗口 允许使用的序列号范围 窗口尺寸为N：最多有N个等待确认的消息 滑动窗口 随着协议的运行，窗口在序列号空间内向前滑动 滑动窗口协议：GBN，SR GBN(Go-Back-N)发送方 分组头部包含k-bit序列号 窗口尺寸为N，最多允许N个分组未确认 ACK(n):确认到序列号n(包含n)的分组均已经被正确接收 可能收到重复的ACK 为空中的分组设置计时器 超时Timeout事件：重传序列号大于等于n，还没有收到ACK的所有分组 GBN：发送方扩展FSM 12345678910if(nextseqnum &lt; base + N){ //意味着还有可用的seqnum意味着还可以接着发送分组 sndpkt[nextseqnum]=make_pkt(nextseqnum.data.chksum); udt_send(sndpkt[nextseqnum]); if (base == nextseqnum){//如果base和nextseqnum相等的话，就启动定时器 start_timer(); nextseqnum++; } else refuse_data(data);//如果窗口里面的序列号已经用光了，就可以refuse掉当前的数据} Timeout事件出现的操作Timeout $\\rightarrow$ start_timer()udt_send(sndpkt[base])……udt_send(sndpkt[nextseqsum-1]) GBN：接收方扩展FSM ACK机制：发送拥有最高序列号的、已经被正确的接收的分组的ACK 可能产生重复的ACK 只需要记住唯一的expectedseqnum 乱序到达的分组： 直接丢弃 $\\rightarrow$ 接收方没有缓存 重新确认序列号最大的按照序列到达的分组 GBN的实例 练习题数据量链路层采用后退N帧的协议，发送方已经发送了编号为0~7的帧，当计时器超市的时候，如果发送方只收到了0，2，3号帧的确认，那么发送方需要重发的帧数是多少，分别是哪几个帧？ 根据GBN的工作原理，GBN协议的确认是累计确认，所以此时发送端需要重发的帧数是4个，依次次分别是4、5、6、7 SR协议Select Repeat协议GBN有什么缺陷？ 不使用累积确认机制，接收方对每个分组单独进行确认 设置缓存机制，缓存乱序到达的分组 发送方只用重传哪些没收到ACK的分组 为每个分组设置计时器 发送方窗口 N个连续的序列号 限制已经发送且未发送的分组 分布式系统的网络 Sender data from above: if next available seq # in window, send pkt timeout (n): resend pkt n, restart timer ACK(n) in [sendbase,sendBase+N]: mark pkt n as recieved if n smallest unACKed pkt, advanced window base to next unACKed seq # recevier pkt n in [revbase, revbase+N-1] send ACK(n) out-of-order:buffer in-order:deliver(also deliver buffered, in-order pkts), advance window to next not-yet-recieved pkt pkt n in [rcvbase-N,rcvbase-1] ACK(n) otherwise: ignore SR协议：困境 序列号：0，1，2，3 窗口尺寸：3 接收方能够区分开两种不同的场景吗？ (a)中发送方重发 (b)中发送了第五个分组 问题：序列号空间大小和窗口尺寸需要满足什么关系？ $N_S+N_R \\leq 2^k$","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"title":"CN-计算机网络分层结构","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 在计算机网络体系结构的各个层次里面，每个报文都分为两个部分：一是数据部分，SDU； 二是控制信息部分，即PCI；它们共同构成PDU 数据服务单元（SDU）：为完成用户所要求的功能二应该传送的数据协议控制单元（PCI）：控制协议操作的信息，第n层的协议控制信息记为n-PCI协议数据单元（PDU）：对等层次之间传送的数据单位就是PDU。 物理层的PDU是比特，数据链路层的PDU是帧，网络层的PDU称为分组，传输层的PDU称为报文段 计算机网络协议、接口、服务的概念为进行网络中的数据交换而建立的规则、标准或者约定就成为网络协议 同一结点内相邻两层之间的交换信息的连接点叫做接口 SAP（服务访问点）是一个逻辑接口而不是物理接口 服务是指下层为紧邻的上层提供的功能调用，它是垂直的。 协议和服务的概念是不一样的，协议的实现保证了服务，上层通过调用下层的服务构造协议。 并非在一层内完成的全部功能都称为服务，只有那些看得见的功能才能叫做服务。 提供的服务可以分为三类： 面向连接服务和无连接服务 面向连接服务：必须先建立连接，分配相应的资源，传输结束之后会释放连接和所占用的资源。 无连接服务：不需要先建立连接，发送数据的时候可以直接发送。 可靠服务和不可靠服务 可靠服务：指的是网络具有纠错、检错、应答机制，能够保证数据正确、可靠的传送到目的地 不可靠服务：尽量准确的可靠的传输，但是不能保证数据正确，是一种尽力而为的服务。 有应答服务和无应答服务 有应答服务：接收方在收到数据后向发送方给出的应答 无应答服务：指的是接收方收到数据之后不自动给出应答，如果要应答就用高层实现。","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/"},{"title":"CN-距离向量路由算法","text":"[[CN-NotesView]] 距离向量(Distance Vector)路由算法Bellman-Ford方程(动态规划) 令：dx(y):从x到y最短路径的费用(距离) dx(y) = min {c(x,y) + dv(y)} c(x,y) 代表的是x到邻居v的费用 dv(y) 代表从邻居v到达目的y的费用（距离） 在x的所有邻居v中取最小值 Bellman-Ford举例重点结点获得最短路径的下一跳，该信息用于转发表中。 距离向量路由算法$D_x(y)$ = 从节点x到结点y的最小费用估计 维护距离向量（DV) : $D_x = [D_x(y): y \\in N]$ 结点x： 已知到达每个邻居的费用：c(x,y) 维护其所有邻居的距离向量: $D_v$ = $D_v(y) : y \\in N$ 核心思想： 每个结点不定时的将其自身的DV估计发送给其邻居 x当收到另据的新的DV估计的时候，根据B-F方程来更新自身的距离向量估计 将最终收敛于实际的最小费用 特点异步迭代引发每次局部迭代的因素 局部链路费用改变 来自邻居的DV更新 分布式每个结点只当DV变化的时候才通告给邻居 邻居在必要的时候（其DV更新后发生改变） 邻居在必要的时候(其DV更新后发生改变)再通告它们的邻居 每个节点：等待本地局部链路费用变化或者收到邻居的DV的更新 重新计算DV估计 如果DV中到达任一目的的距离发生改变，通告所有邻居","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"},{"title":"CN-距离向量链路算法2","text":"[[CN-NotesView]] Bellman-Ford方程（动态规划） 令： $d_x(y) = min_distance(x \\to y) = min{c(x,v) + d_v(y)}$ c(x,v) 代表的是x到v的费用 $dv(y)$ 从邻居v到目的y的费用 Bellman-Ford举例显然：$d_v(z) = 5,\\ \\ \\ d_x = 3,\\ \\ \\ d_w(z)=3$ 根据B-F方程： $d_u(z) = min {c(u,v) + d_v(z), \\ \\ c(u,x) + d_x(z), \\ \\ c(u,w) + d_w (z)} \\ = min{\\ 2+5,\\ 1+3,\\ 5+3} = 4$ 重点: 结点获得最短路径的下一跳,该信息用于转发表中 距离向量路由算法$D_x(y) =$ 从结点x到结点y的最小费用估计 x 维护距离向量(DV) ： $D_x = [D_x(y): y \\in N]$ 结点x: 已知到达每个邻居的费用: c(x,y) 维护其所有邻居的距离向量：$D_v = [D_v(y): y \\in N]$ 核心思想每个结点不定时的把其自身的DV估计发送给其邻居 当接收到邻居的新的DV估计的时候，也就是根据B-F更新其自身的路由向量估计： $D_x(y) \\leftarrow min{c(x,y) \\ + \\ D_v(y)} \\ for \\ each \\ node\\ y \\in N$ 最后$D_x(y)$将会收敛到最小值。 异步迭代引发每次局部迭代的因素 局部链路费用改变 来自邻居的DV更新 分布式算法每个结点只有当DV变化的时候才通告邻居 邻居在必要的时候再通告它们的邻居 每个节点的阶段：等待：每个路由器在没有发生变化的时候就保持这种状态（邻居DV没有发生更新） 重新计算 DV估计 如果DV中到达任一一个目的距离发生改变，通告所有的邻居 然后再次进入等待状态 举例初始的距离向量为： 距离向量DV：链路费用变化链路费用的变化： 结点检测本地链路费用的变化 更新路由信息，重新计算距离向量 如果DV改变，通告所有的邻居 $t_0$ : y检测到链路费用的改变，更新DV，通告其邻居 $t_1$ : z收到y的DV更新，更新其距离向量表，计算到达x的最新最小费用，更新其DV，并发送其所有的邻居。 $t_2$ ：y收到z的DV更新，更新其距离向量表，重新计算y的DV，未发生改变，不再像z发送DV “好消息传播的快” 但是可能出现无穷计数问题（如上所示） 毒性逆转如果一个结点(e.g.z)到达某目的(e.g.X)的最小费用路径是通过某个邻居(e.g.Y)，则: 通告给该邻居结点到达该目的的距离为无穷大 毒性逆转是不是能够彻底的消除无穷计数问题？ 简单的环路是可以消除的，更复杂的环境其实未必可以满足。 定义最大的一个距离度量值(maximum metric) 定义一个最大的有效费用值，比如15跳步，16跳步标识无穷 如果一直不可达，就会在有效费用值耗尽的时候结束传输","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%952/"},{"title":"CN-路由器的工作原理","text":"MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$']] } }); [[计算机网络]] 网络层的转发功能 简要的转发问题：编址和==最长前缀匹配问题== 关键术语： 转发、交换 转发功能通常称为**路由器转发平面** 数据报流水线必须以N倍速率运行 路由器控制平面通常用软件实现并在路由选择处理器上执行 最重要的路由器部件：入口路和入口站 $\\to$ 输入端口 环形交叉路 $\\to$ 交换结构 环状交叉路出口 $\\to$ 输出端口 Q： 车站服务人员很慢会发生什么情况？（查询速度慢） 服务人员必须要多快才能确保在入口路上没有车辆拥堵？（查询速度的最低值） 对于极快的服务人员，如果汽车在环状交叉路上开的很慢将会发生什么情况？（交换结构内数据传输慢） 如果大多数进入的汽车都要在相同的出口离开会发生什么情况？（拥塞控制） 如果要为不同的汽车分配优先权，或者阻挡某些汽车进入环状交叉路，应该怎么运行？（如何让数据报有控制的进行转发） 路由器的输入端口 查找 **根据转发表** TCAM 三态内容可寻址存储器 确定了输出端口之后分组就能够发送进入交换结构。如果正在使用交换结构就会被阻塞。因此需要在输入端口的位置排队。 必须采取的动作： 物理层和链路层处理 检查分组的版本号、检验和","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"CN-路由和转发","text":"[[CN-NotesView]] 路由与转发路由算法（协议）确定去往目的网络的最佳路径 转发表确定在本路由器如何转发分组 网络抽象：图 图：G = （N,E）N = 路由器集合 = {u,v,w,x,y,z}E = 链路集合 = {(u,v),(u,x)} 图的抽象在网络领域很广泛 N是peers集合，E是TCP的集合 图抽象：费用（Costs）c(x,x’)链路(x,x’)的费用 e.g c(w,z) = 5 每段链路的费用可以总是1，描述一个链路或者路径的大小的时候称为段数；或者是，带宽的倒数、拥塞程度等。 路径费用：(x1,x2,x3,,,xp) = c(x1,x2) + c(x2,x3) + … + c(xp-1,xp) [!关键问题]源到目的的最小费用的路径是什么？ 路由算法：在网络的抽象图中寻找最小路径的算法 路由算法分类静态路由 vs 动态路由？静态路由： 手工配置 路由更新的速度慢 优先级高（在路由信息中同等条件下首选） 动态路由： 路由更新快 定期更新 及时响应链路费用或者网络拓扑变化 全局信息 vs 分散信息？全局信息：所有路由器掌握完整的网络拓扑和链路费用信息 e.g. 链路状态(LS)路由算法 分散信息（decentralized）: 路由器只掌握物理项链的邻居以及链路费用 链路之间信息交换、运算的迭代过程 e.g. 距离向量9(DV)路由算法","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%B7%AF%E7%94%B1%E5%92%8C%E8%BD%AC%E5%8F%91/"},{"title":"CN-轮转访问MAC协议","text":"[[CN-NotesView]] 信道划分MAC协议： 网络负载重的时候，共享信道的效率高，而且公平 网络负载轻的时候，信道的效率低！ 随机访问MAC协议： 网络负载重的时候产生冲突开销 网络负载轻的时候，产生冲突开销 轮转访问MAC协议： 综合两者的优点！ 轮询(polling)主节点轮流的“邀请”从属结点发送数据 典型应用：“哑”从属设备 问题： 轮询开销 等待延迟 单点故障 令牌传递控制令牌依次从一个结点传递到下一个结点 令牌：特殊帧 令牌网络会构成环形网络 问题： 令牌的开销 等待延迟 单点故障问题 MAC协议总结信道划分MAC协议：TDMA、FDMA、CDMA随机访问MAC协议：ALOHA,S-ALOHA，CSMA/CD,CSMA/CA轮转访问MAC协议：主结点轮询：令牌传递蓝牙/FDDI","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E8%BD%AE%E8%BD%AC%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/"},{"title":"CN-链路状态路由算法","text":"[[CN-NotesView]] 链路状态路由算法 网络抽象：图图： G = （N，E） 链路状态路由算法Dijstra算法 所有节点（路由器）掌握网络拓扑和链路费用 要求每一个路由器都构造一个链路状态分组，并广播出去 通过“链路状态广播” 链路状态路由算法里面利用扩散或者泛洪的方法来进行发送 任何一个路由器都会收集全了所有路由器的链路状态分组 所有节点拥有相同信息 计算从一个节点（“源”）到达所有其他节点的最短路径 获得该节点的传发表 迭代：k次迭代之后，得到到达k个目的节点的最短路径 符号 c(x,y):结点x到结点y链路费用；如果x和y不直接相连，则为无穷大 D(v): 从源到目的v的当前路径费用值 p(v): 沿从源到v的当前路径，v的前序节点 N‘ ：已经找到费用最小路径的结点集合 Dijstra 算法： 1234567891011121314初始化N’ = {u}for 所有结点 if v和u相邻 then D(v) = c(u,v) else D(v) = 无穷Loop 找出不再N’中的w，满足D（w）最小 将w加入N‘ 更新w的所有不在N’中的邻居v的D（v）: D(v) = min(D(v),D(w) + c(w,v)) //已知的到达w的最短路径费用加上w到v的费用until 所有的结点都在N‘中了 u 的最终最短路径树： u 的最终转发表： 根据上面的内容进行计算最终转发表 Dijstra 算法算法复杂性： O($n^2$) 每一次迭代：需要检测所有不在结合N’中的结点n(n+1)/2次的比较：O($n^2$)更高效的实现：O(nlogn) 存在震荡的可能：假设链路费用是该链路承载的通信量 很有可能导致数据包在DCB之间反复震荡无法传送到A，最终会因为TTL被丢弃。 所以会使用一些机制来避免这样的情况","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95/"},{"title":"CN-随机访问MAC协议","text":"[[CN-NotesView]] 多路访问控制(MAC)协议两类的链路： 点对点链路： 拨号接入的PPP 以太网交换机和主机之间的点对点链路 广播链路（共享介质） 早期的总线以太网 HFC的上行链路 802.11无线局域网 单一共享广播信道 两个或者两个以上的结点同时传输：干扰(interface) 冲突 结点同时接收到两个或者多个信号 $\\to$ 接收失败！ 多路访问控制协议采用分布式算法决定结点怎么共享信道，也就是决策结点什么时候可以传输数据 必须基于信道本身，通信信道共享协调信息！ 理想的MAC协议给定：速率为Rbos的广播信道 期望： 如果只有一个结点：R M个结点发送：R/M 完全分散控制： 不用特定协调 不用时钟，时隙同步 简单 MAC协议的分类三大类： 信道划分MAC协议多路复用技术 TDMA、FDMA、CDMA、WDMA等 随机访问MAC协议信道不划分，允许冲突 冲突的恢复机制 轮转协议结点轮流使用信道 信道划分MAC协议：TDMA、FDMAtime division multiple access 周期性的使用信道 每个站点在每个周期占用固定长度的时隙 未用的时隙空间 同理：FDMA (frequency division multiple access) 网络资源 随机访问MAC协议当结点要发送分组的时候： 利用信道全部数据速率R发送分组 没有实现的结点协调 两个或者多个结点同时传输 ： 冲突 随机访问MAC协议需要定义： 如何检测冲突 如何从冲突中恢复（延迟重传） 典型的随机访问MAC协议： ALOHA CSMA/CA 等 时隙ALOHA协议假定： 所有帧的大小相同时间被划分为等长度的时隙结点只能在时隙的开始时刻发送帧结点之间时钟同步如果两个或者两个以上的结点在同一个时隙发送帧，节点就检测到冲突 运行： 当结点有新的帧的时候，在下一个时隙(slot)发送如果冲突 以概率p重传这个帧 优点:单个结点活动时，可以连续以信道全部速率传输数据高度分散化: 只需同步时隙简单 缺点:冲突，浪费时隙空闲时隙结点也许能以远小于分组传输时间检测到冲突 效率：成功发送帧的时隙占的比例 假设：N个结点有很多的帧需要传输，每个结点在每个时隙均以概率p发送数据 效率：最大的效率为0.37 纯ALOHA协议更简单，不用时钟同步 当有新的数据帧构成的时候立刻发送数据帧 立即发送 冲突的可能性增大 比时隙ALOHA协议更差，效率为0.18 CSMA协议载波监听多路访问协议 发送帧之前，监听信道(载波)： 信道空闲：发送完整帧 信道忙：推迟发送 1-坚持CSMA 非坚持CSMA P-坚持CSMA 冲突可能仍然发生：信号传播延迟 继续发送冲突帧：浪费信道资源 CSMA/CD协议带有冲突检测的载波多路访问协议 短时间内内可以检测到冲突 冲突之后传输中止，减少信道的浪费 冲突检测： 有线局域网易于实现：测量信号强度，比较发送信号和接收信号 无线局域网很难实现：接收信号强度淹没在本地发射信号强度下 “边发边听，不发不听” CSMA/CD协议 在一个采用CSMA/CD协议的网络中，传输介质是一根完整的电缆，传输速率为1 Gbps，电缆中的信号传播速度是200 000 km/s。若最小数据帧长度减少800比特，则最远的两个站点之间的距离至少需要减少 $T_{prop} = LAN中两个结点之间的最大传播延迟$ $t_{trans} = 最长帧传输延迟$ $效率 = \\frac{1}{1+5 t_{prop}/t_{trans}}$ 远优于ALOHA并且简单分散","link":"/2023/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/CN-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AEMAC%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Cookie","slug":"Cookie","link":"/tags/Cookie/"},{"name":"Web应用","slug":"Web应用","link":"/tags/Web%E5%BA%94%E7%94%A8/"},{"name":"知识卡片","slug":"知识卡片","link":"/tags/%E7%9F%A5%E8%AF%86%E5%8D%A1%E7%89%87/"},{"name":"HTTP","slug":"HTTP","link":"/tags/HTTP/"},{"name":"计算机网络概述","slug":"计算机网络概述","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"name":"作业","slug":"作业","link":"/tags/%E4%BD%9C%E4%B8%9A/"},{"name":"模板","slug":"模板","link":"/tags/%E6%A8%A1%E6%9D%BF/"},{"name":"网络层","slug":"网络层","link":"/tags/%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"name":"传输层","slug":"传输层","link":"/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"},{"name":"数据链路层","slug":"数据链路层","link":"/tags/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"}],"categories":[{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"pages":[]}